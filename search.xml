<?xml version="1.0" encoding="utf-8"?>
<search>


    <entry>
        <title>JWT单点登录</title>
        <link href="/2021/07/27/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
        <url>/2021/07/27/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>JWT单点登录</p><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><p><strong><p class='p small'>JWT官网：https://jwt.io/#debugger-io</p></strong></p><p><strong><p class='p small'>JWT：JSON Web Tokens 是一种开放的、行业标准的 [RFC 7519](https://tools.ietf.org/html/rfc7519)方法，用于在两方之间安全地表示声明</p></strong></p><p class='p small'>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><br/><h4 id="什么时候应该用JSON-Web-Token"><a href="#什么时候应该用JSON-Web-Token" class="headerlink" title="什么时候应该用JSON Web Token"></a>什么时候应该用JSON Web Token</h4><p class='p small'>下列场景中使用JSON Web Token是很有用的：</p><p class='p small'>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p><p class='p small'>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</p><br/><h4 id="JWT认证流程"><a href="#JWT认证流程" class="headerlink" title="JWT认证流程"></a>JWT认证流程</h4><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt=""></p><p class='p small'>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程- -般是一 个HTTP POST请求。建议的方式是通过SSL加密的传输(https协议) ，从而避免敏感信息被嗅探。</p><p class='p small'>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload (负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同11. zzz. xxx的字符串。token head . payload . singurater</p><p class='p small'>后端将JWT字符串作为登录成功的返回结果返回给前端。 前端可以将返回的结果保存在localStorage或sessionStorage上， 退出登录时前端删除保存的JWT即可。</p><p class='p small'>前端在每次请求时将JWT放入HTTP Header中的Authorization位。 (解决XSS和XSRF问题)</p><p class='p small'>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确;检查Token是否过期;检查Token的接收方是否是自己(可选)</p><p class='p small'>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p>     <br/><h4 id="JWT优势在哪"><a href="#JWT优势在哪" class="headerlink" title="JWT优势在哪?"></a>JWT优势在哪?</h4><p class='p small'>1、简洁(Compact):可以通过URL，POST参 数或者在HTTP header发送，因为数据量小，传输速度也很快，自包含(Self-contained):负载中包含了所有用户所需要的信息，避免了多次查询数据库</p><p class='p small'>2、因为Token是 以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</p><p class='p small'>3、不需要在服务端保存会话信息，特别适用于分布式微服务。</p><br/><h3 id="JWT数据结构"><a href="#JWT数据结构" class="headerlink" title="JWT数据结构"></a>JWT数据结构</h3><p class='p small'>形如 xxxx.yyy.zzz 由三部分组成，每部分用英文句号连接</p><p><strong><p class='p small'>JWT的三个部分： header 头部 payload 负载 signature 签名</p></strong></p><p><strong><p class='p small'>也就是 Header.Payload.Signature</p></strong></p><p class='p small'>例如：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6IumZhuS9s-aZqCIsImV4cCI6MTYyNzM2NTQzNiwidXNlcklkIjoyMH0.34HAEE_8BhCMdnnx7MpqNMz6DuSW3yaGp49AmY3ZW10</p><h5 id="1、Header-头部"><a href="#1、Header-头部" class="headerlink" title="1、Header 头部"></a>1、Header 头部</h5><p class='p small'>是一个JSON 对象，描述JWT的元数据，形如： {alg: HS256</p><p class='p small'>alg属性表示签名的算法（algorithm），默认是 HMAC SHA256</p><p class='p small'>typ属性表示这个令牌的类型（type），JWT 令牌统一写为JWT</p><h5 id="2、payload-负载"><a href="#2、payload-负载" class="headerlink" title="2、payload 负载"></a>2、payload 负载</h5><p class='p small'>是一个JSON 对象，用来存放实际需要传递的数据，形如： {sub: 1234567890</p><p class='p small'>一般是在这个部分定义私有字段： 例如{userId:1，"userName":jack</p><p class='p small'>其中payload官方规定了7个字段：</p><p><strong><p class='p small'>iss (issuer)：签发人</p></strong></p><p><strong><p class='p small'>exp (expiration time)：过期时间</p></strong></p><p><strong><p class='p small'>sub (subject)：主题</p></strong></p><p><strong><p class='p small'>aud (audience)：受众</p></strong></p><p><strong><p class='p small'>nbf (Not Before)：生效时间</p></strong></p><p><strong><p class='p small'>iat (Issued At)：签发时间</p></strong></p><p><strong><p class='p small'>jti (JWT ID)：编号</p></strong></p><p><strong><p class='p small'>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把机密信息放在这个部分。</p></strong></p><h5 id="3、signature-签名"><a href="#3、signature-签名" class="headerlink" title="3、signature 签名"></a>3、signature 签名</h5><p class='p small'>signature 是对前两部分的签名，防止数据篡改</p><p class='p small'>1、需要指定一个密钥（secret）</p><p class='p small'>2、这个密钥只有服务器才知道，不能泄露给客户端</p><p class='p small'>3、使用 Header 里面指定的签名算法，按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;HMACSHA256(</span><br><span class="line">   base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">   base64UrlEncode(payload),</span><br><span class="line">   secret</span><br><span class="line"> )&#96;</span><br></pre></td></tr></table></figure><p class='p small'>也就是signature等于上面公式算出来的</p><p class='p small'>把 Header、Payload、Signature 三个部分拼成一个字符串: xxxx.yyy.zzz</p><p class='p small'>其中base64UrlEncode是串型化算法，处理特殊字符，=被省略、+替换成-，/替换成_</p><br/><h4 id="JWT-使用方式"><a href="#JWT-使用方式" class="headerlink" title="JWT 使用方式"></a>JWT 使用方式</h4><p class='p small'>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage 以后客户端每次与服务器通信，都要带上这个 JWT</p><p class='p small'>方式1、可以放在 Cookie 里面自动发送，但是这样不能跨域</p><p class='p small'>方式2、更好的做法是放在 HTTP 请求的头信息Authorization字段里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p class='p small'>方式3、JWT放在POST请求的数据体body里面</p><br/><h4 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h4><p class='p small'>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p class='p small'>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p class='p small'>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p class='p small'>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p class='p small'>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p class='p small'>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><br/><h3 id="JWT案例"><a href="#JWT案例" class="headerlink" title="JWT案例"></a>JWT案例</h3><p class='p small'>1、引入JWT的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JWT--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.4.0&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p class='p small'>2、编写生成JWT的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 生成JWT密钥</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Test</span><br><span class="line">   void getToken() &#123;</span><br><span class="line">       HashMap&lt;String, Object&gt; hashMap &#x3D; new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">       Calendar instance &#x3D; Calendar.getInstance();</span><br><span class="line">       instance.add(Calendar.MINUTE,5);                &#x2F;&#x2F; 以分钟为单位</span><br><span class="line"></span><br><span class="line">       String token &#x3D; JWT.create()</span><br><span class="line">               .withHeader(hashMap)                            &#x2F;&#x2F; header</span><br><span class="line">               .withClaim(&quot;userId&quot;, 20)               &#x2F;&#x2F; payload</span><br><span class="line">               .withClaim(&quot;userName&quot;, &quot;陆佳晨&quot;)       &#x2F;&#x2F; payload</span><br><span class="line">               .withExpiresAt(instance.getTime())              &#x2F;&#x2F; 指定令牌的过期时间</span><br><span class="line">               .sign(Algorithm.HMAC256(&quot;SIGNATURE&quot;));&#x2F;&#x2F; 签名</span><br><span class="line"></span><br><span class="line">       System.out.println(token);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p class='p small'>3、解析JWT密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void verify()&#123;</span><br><span class="line">        &#x2F;&#x2F; 创建验证对象</span><br><span class="line">        JWTVerifier jwtVerifier &#x3D; JWT.require(Algorithm.HMAC256(&quot;SIGNATURE&quot;)).build();</span><br><span class="line">        &#x2F;&#x2F; 进行解析操作</span><br><span class="line">        DecodedJWT verify &#x3D; jwtVerifier.verify(&quot;填写你刚刚生成的JWT密钥&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取到登陆信息</span><br><span class="line">        System.out.println(verify.getClaim(&quot;userId&quot;).asInt());</span><br><span class="line">        System.out.println(verify.getClaim(&quot;userName&quot;).asString());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取令牌的过期时间</span><br><span class="line">        System.out.println(verify.getExpiresAt());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><h4 id="JWT工具包"><a href="#JWT工具包" class="headerlink" title="JWT工具包"></a>JWT工具包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package com.xj.jwt.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.auth0.jwt.JWT;</span><br><span class="line">import com.auth0.jwt.JWTCreator;</span><br><span class="line">import com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line">import com.auth0.jwt.interfaces.Claim;</span><br><span class="line">import com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JwtUtil &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 切记不要将令牌泄露</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final String SING &#x3D; &quot;SIGNATURE&quot;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取token</span><br><span class="line">     *</span><br><span class="line">     * @param map</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getToken(Map&lt;String, String&gt; map, Integer expire) &#123;</span><br><span class="line">        Calendar instance &#x3D; Calendar.getInstance();</span><br><span class="line">        &#x2F;&#x2F; 以小时为单位</span><br><span class="line">        instance.add(Calendar.HOUR,expire);</span><br><span class="line"></span><br><span class="line">        JWTCreator.Builder builder &#x3D; JWT.create();</span><br><span class="line"></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            builder.withClaim(k, v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return builder.withExpiresAt(instance.getTime())</span><br><span class="line">                .sign(Algorithm.HMAC256(SING));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解析token</span><br><span class="line">     * @param token</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Map&lt;String,String&gt; verify(String token)&#123;</span><br><span class="line"></span><br><span class="line">        DecodedJWT verify &#x3D; JWT.require(Algorithm.HMAC256(SING))</span><br><span class="line">                .build().verify(token);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; resultMap&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Claim&gt; claims &#x3D; verify.getClaims();</span><br><span class="line">        </span><br><span class="line">        claims.forEach((k,v)-&gt;&#123;</span><br><span class="line">            resultMap.put(k,v.asString());</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        return resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 验证token是否合法</span><br><span class="line">     * @param token</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static DecodedJWT lawful(String token)&#123;</span><br><span class="line">        return JWT.require(Algorithm.HMAC256(SING)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="JWT常见报错"><a href="#JWT常见报错" class="headerlink" title="JWT常见报错"></a>JWT常见报错</h4><p class='p small'>JWT密钥不一致:</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E5%AF%86%E9%92%A5%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt=""></p><p class='p small'>JWT密钥已过期：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E5%AF%86%E9%92%A5%E8%BF%87%E6%9C%9F.png" alt=""></p><p class='p small'>JWT加密和解析度算法不一致：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E7%AE%97%E6%B3%95%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt=""></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Eureka集群的搭建</title>
        <link href="/2021/07/23/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
        <url>/2021/07/23/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Eureka服务注册与发现</p><p><strong><p class='p small'>首先在开始搭建Eureka服务之前，我们要了解Eureka的基础知识！</p></strong></p><h3 id="Eureka基础知识"><a href="#Eureka基础知识" class="headerlink" title="Eureka基础知识"></a>Eureka基础知识</h3><h4 id="什么是服务治理？"><a href="#什么是服务治理？" class="headerlink" title="什么是服务治理？"></a>什么是服务治理？</h4><p class='p small'>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理</p><p class='p small'>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><br/><h4 id="什么是服务注册与发现？"><a href="#什么是服务注册与发现？" class="headerlink" title="什么是服务注册与发现？"></a>什么是服务注册与发现？</h4><p class='p small'>Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p><p class='p small'>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</p><p><strong><p class='p small'>下图是Eureka系统架构</p></strong></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E7%9A%84%E6%9E%B6%E6%9E%84.png" alt=""></p><br/><h4 id="Eureka的两大核心组件"><a href="#Eureka的两大核心组件" class="headerlink" title="Eureka的两大核心组件"></a>Eureka的两大核心组件</h4><p><strong><p class='p small'>Eureka Server提供服务注册服务</p></strong></p><p class='p small'>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p><strong><p class='p small'>EurekaClient通过注册中心进行访问</p></strong></p><p class='p small'>EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><br/><h3 id="单机Eureka构建步骤"><a href="#单机Eureka构建步骤" class="headerlink" title="单机Eureka构建步骤"></a>单机Eureka构建步骤</h3><h4 id="搭建eurekaServer端服务注册中心"><a href="#搭建eurekaServer端服务注册中心" class="headerlink" title="搭建eurekaServer端服务注册中心"></a>搭建eurekaServer端服务注册中心</h4><p class='p small'>1、新建一个名称为cloud-eureka-server7001的maven工程</p><p class='p small'>2、在pom文件中添加坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-server--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--boot web actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--一般通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在resources下新建application.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001  #端口号</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">    #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>4、新建EurekaMain7001主启动类</p><p><strong><p class='p small'>注意：@EnableEurekaServer 注解的作用在与将项目作为SpringCloud中的注册中心</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer  </span><br><span class="line">public class EurekaMain7001</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>5、启动项目访问端口http://localhost:7001/</p><p class='p small'>No instances available没有服务被发现，因为没有注册服务进来当然不可能有服务被发现</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/%E8%AE%BF%E9%97%AEEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt=""></p><br/><h4 id="搭建EurekaClient端的服务提供者provider"><a href="#搭建EurekaClient端的服务提供者provider" class="headerlink" title="搭建EurekaClient端的服务提供者provider"></a>搭建EurekaClient端的服务提供者provider</h4><p class='p small'>1、创建一个名称为cloud-provider-payment8001的maven工程</p><p class='p small'>目的是将cloud-provider-payment8001注册进EurekaServer成为服务提供者provider</p><p class='p small'>2、引入cloud-provider-payment8001工程的pom坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--mysql-connector-java--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--jdbc--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在resources目录下新建application.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service   #注册到Eureka的服务名</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</span><br><span class="line">    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</span><br><span class="line">    url: 填写你自己的mysql地址</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.atguigu.springcloud.entities    # 所有Entity别名类所在包</span><br></pre></td></tr></table></figure><p class='p small'>4、新建PaymentMain8001主启动类</p><p><strong><p class='p small'>注意：@EnableEurekaClient注解表示能够让注册中心发现、并扫描到PaymentMain8001服务</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class PaymentMain8001</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>5、在启动cloud-eureka-server7001服务的前提下启动cloud-provider-payment8001服务</p><p class='p small'>访问http://localhost:7001/} ![](https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png) **{% p small</p>**<p><strong><p class='p small'>表示Eureka开启了自我保护机制</p></strong></p><br/><h4 id="搭建EurekaClient端的服务消费者consumer"><a href="#搭建EurekaClient端的服务消费者consumer" class="headerlink" title="搭建EurekaClient端的服务消费者consumer"></a>搭建EurekaClient端的服务消费者consumer</h4><p class='p small'>1、新建一个cloud-consumer-order80的maven工程</p><p class='p small'>目的是将其注册进EurekaServer成为服务消费者consumer（有服务提供者必然就会出现消费者）</p><p class='p small'>2、引入cloud-consumer-order80的pom坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在resources目录下新建application.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: cloud-order-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br></pre></td></tr></table></figure><p class='p small'>4、新建OrderMain80的主启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class OrderMain80</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>到此，我们的Eureka的单机版就已经全部搭建完成了</p><br/><h3 id="Eureka集群的搭建"><a href="#Eureka集群的搭建" class="headerlink" title="Eureka集群的搭建"></a>Eureka集群的搭建</h3><h4 id="Eureka集群原理说明"><a href="#Eureka集群原理说明" class="headerlink" title="Eureka集群原理说明"></a>Eureka集群原理说明</h4><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86.png" alt=""></p><p class='p small'>微服务RPC远程服务调用最核心的是什么 ?</p><p class='p small'>高可用，试想你的注册中心只有一个only one， 它出故障了那就呵呵(￣▽￣)了，会导致整个为服务环境不可用，也就是俗称的单点故障。%}{% p small</p><p class='p small'>2、导入7002的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-server--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--boot web actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--一般通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、修改映射配置</p><p class='p small'>找到C:\Windows\System32\drivers\etc路径下的hosts文件</p><p class='p small'>新增映射配置添加进hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1  eureka7001.com</span><br><span class="line">127.0.0.1  eureka7002.com</span><br></pre></td></tr></table></figure><p class='p small'>4、修改之前单机的yml配置文件（7001，7002）</p><p class='p small'>7001：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>7002：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>5、将支付服务8001微服务发布到上面2台Eureka集群配置中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      #defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka  # 集群版</span><br></pre></td></tr></table></figure><p class='p small'>6、将订单服务80微服务发布到上面2台Eureka集群配置中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: cloud-order-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br></pre></td></tr></table></figure><br/><h4 id="支付服务提供者8001集群环境构建"><a href="#支付服务提供者8001集群环境构建" class="headerlink" title="支付服务提供者8001集群环境构建"></a>支付服务提供者8001集群环境构建</h4><p class='p small'>1、参考cloud-provider-payment8001新建cloud-provider-payment8002</p><p class='p small'>2、导入8002的pom依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--mysql-connector-java--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--jdbc--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、写入8002的yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br></pre></td></tr></table></figure><p class='p small'>至此，Eureka的集群就搭建好了</p><br/><h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p class='p small'>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p><p class='p small'>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：</p><p><strong><p class='p small'>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE</p></strong></p><h4 id="为什么会产生Eureka自我保护机制？"><a href="#为什么会产生Eureka自我保护机制？" class="headerlink" title="为什么会产生Eureka自我保护机制？"></a>为什么会产生Eureka自我保护机制？</h4><p class='p small'>为了防止EurekaClient可以正常运行，但是 与 EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</p><h4 id="什么是自我保护模式？"><a href="#什么是自我保护模式？" class="headerlink" title="什么是自我保护模式？"></a>什么是自我保护模式？</h4><p class='p small'>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.png" alt=""></p><p><strong><p class='p small'>一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存</p></strong></p><p><strong><p class='p small'>属于CAP里面的AP分支</p></strong></p><h4 id="怎么禁止自我保护"><a href="#怎么禁止自我保护" class="headerlink" title="怎么禁止自我保护"></a>怎么禁止自我保护</h4><p class='p small'>在yml中Eureka的配置进行修改</p><p class='p small'>使用eureka.server.enable-self-preservation = false 可以禁用自我保护模式</p><p class='p small'>或者修改Eureka的注销实例的默认时间（单位为秒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.lease-expiration-duration-in-seconds&#x3D;90</span><br></pre></td></tr></table></figure><p class='p small'>到此，Eureka的入门就完成了!</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud Netflix</tag>

        </tags>

    </entry>


    <entry>
        <title>为什么要使用Optional?</title>
        <link href="/2021/07/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Optional/"/>
        <url>/2021/07/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Optional/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Java8_Optional类</p><h2 id="理解Optional"><a href="#理解Optional" class="headerlink" title="理解Optional"></a>理解Optional</h2><p><strong><p class='p small'>设计目的：</p></strong></p><p><strong><p class='p small'>我们的目的是为方法的返回类型提供一种有限的机制，其中需要一种明确的方式来表示“无结果”，并且对于这样的方法使用null绝对可能导致错误。</p></strong></p><p class='p small'>Optional 是一个可以包含NULL值的容器，或者叫做一个包装类，只包装了一个属性，这个属性的值可有可无。</p><br/><h2 id="Optional方法摘要"><a href="#Optional方法摘要" class="headerlink" title="Optional方法摘要"></a>Optional方法摘要</h2><p class='p small'>Optional继承自java.lang.Object类的方法</p><p class='p small'>所有方法：</p><table><thead><tr><th align="center">Method</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center"><code>empty()</code></td><td align="center">返回一个空的 <code>Optional</code>实例。</td></tr><tr><td align="center"><code>equals()</code></td><td align="center">指示某个其他对象是否等于此可选项。</td></tr><tr><td align="center"><code>filter()</code></td><td align="center">如果一个值存在，并且该值给定的谓词相匹配时，返回一个 <code>Optional</code>描述的值，否则返回一个空的 <code>Optional</code></td></tr><tr><td align="center"><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td align="center">如果一个值存在，应用提供的 <code>Optional</code>映射函数给它，返回该结果，否则返回一个空的 <code>Optional</code></td></tr><tr><td align="center"><code>get()</code></td><td align="center">如果 <code>Optional</code>中有一个值，返回值，否则抛出 <code>NoSuchElementException</code></td></tr><tr><td align="center"><code>hashCode()</code></td><td align="center">返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）</td></tr><tr><td align="center"><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code></td><td align="center">如果存在值，则使用该值调用指定的消费者，否则不执行任何操作</td></tr><tr><td align="center"><code>isPresent()</code></td><td align="center">返回 <code>true</code>如果存在值，否则为 <code>false</code></td></tr><tr><td align="center"><code>map(Function&lt;? super T,? extends U&gt; mapper)</code></td><td align="center">如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个 <code>Optional</code>结果的 <code>Optional</code></td></tr><tr><td align="center"><code>of(T value)</code></td><td align="center">返回具有 <code>Optional</code>的当前非空值的Optional</td></tr><tr><td align="center"><code>ofNullable(T value)</code></td><td align="center">返回一个 <code>Optional</code>指定值的Optional，如果非空，则返回一个空的 <code>Optional</code></td></tr><tr><td align="center"><code>orElse(T other)</code></td><td align="center">返回值如果存在，否则返回 <code>other</code></td></tr><tr><td align="center"><code>orElseGet(Supplier&lt;? extends T&gt; other)</code></td><td align="center">返回值（如果存在），否则调用 <code>other</code>并返回该调用的结果</td></tr><tr><td align="center"><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td><td align="center">返回包含的值（如果存在），否则抛出由提供的供应商创建的异常</td></tr><tr><td align="center"><code>toString()</code></td><td align="center">返回此可选的非空字符串表示，适用于调试</td></tr></tbody></table><br/><h2 id="Optional例子"><a href="#Optional例子" class="headerlink" title="Optional例子"></a>Optional例子</h2><h3 id="做为接口提供者"><a href="#做为接口提供者" class="headerlink" title="做为接口提供者"></a>做为接口提供者</h3><p class='p small'>我有一个方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">获取用户</span><br><span class="line">@param id 唯一id</span><br><span class="line">@return 用户 可能为null,代表不存在</span><br><span class="line">*&#x2F;</span><br><span class="line">public User getUser(Long id) &#123;</span><br><span class="line"> if (null !&#x3D; id) &#123;</span><br><span class="line">   return new User();</span><br><span class="line"> &#125;</span><br><span class="line"> return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>尽管已经在方法注释中说明返回的User可能为空，可我依然不敢保证其他开发成员都会进行 if (user == null) 判断，当没有这一步时，那么接下来就是大家最常见的NullPointerException</p><p class='p small'>此时，调用者会不会内心：MD</p><p class='p small'>提供者：（捂脸）冤枉啊！你自己不看方法注释，还怪我……</p><p><strong><p class='p small'>这个时候Optional就该上场了？</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;User&gt; getUser(Long id) &#123;</span><br><span class="line">if (null !&#x3D; id) &#123;</span><br><span class="line">return Optional.of(new User());</span><br><span class="line">&#125;</span><br><span class="line">return Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>你们看！现在已经明确的告诉了调用者，返回的用户对象是可能存在也可能不存在，你要注意两者的不同处理。</p><p><strong><p class='p small'>此时，仅仅改变一个返回值，就能很大程度上帮助调用者避免NPE的问题</p></strong></p><br/><h3 id="做为调用者"><a href="#做为调用者" class="headerlink" title="做为调用者"></a>做为调用者</h3><p>提供者返回的类型为Optional，那么就是说返回的对象可能为null,那么我要分别判断存在和不存在该如何处理了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">  Optional&lt;User&gt; userOp &#x3D; getUser(110L);</span><br><span class="line">  if (userOp.isPresent())&#123;</span><br><span class="line">    User user &#x3D; userOp.get();</span><br><span class="line">    &#x2F;&#x2F; TODO</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我现在只想对不为空的情况处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userOp.isPresent(user -&gt; log.info(user));</span><br></pre></td></tr></table></figure><p>如果现在我想获取用户住址中的国家：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userOp.map(User::getAddress).map(Address::getCountry);</span><br></pre></td></tr></table></figure><p>如果用户不存在或地址不存在，我需要抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userOp.map(User::getAddress)</span><br><span class="line">  .map(Address::getCountry)</span><br><span class="line">  .orElseThrow(NotExistException::new);</span><br></pre></td></tr></table></figure><p>如果想要设置默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userOp.map(User::getAddress)</span><br><span class="line">  .map(Address::getCountry)</span><br><span class="line">  .orElse(&quot;默认值&quot;);</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Redis持久化</title>
        <link href="/2021/07/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
        <url>/2021/07/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Redis 持久化</p><h2 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h2><p class='p small'>Redis 提供了一系列不同的持久性选项：</p><ul><li><strong>RDB</strong>（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。</li><li><strong>AOF</strong>（Append Only File）：AOF 持久化记录服务器收到的每个写操作，在服务器启动时会再次播放，重建原始数据集。命令使用与 Redis 协议本身相同的格式以仅附加的方式记录。当日志变得太大时，Redis 能够在后台重写日志。</li><li><strong>无持久性</strong>：如果您希望数据在服务器运行时一直存在，您可以完全禁用持久性。</li><li><strong>RDB + AOF</strong>：可以在同一个实例中组合 AOF 和 RDB。请注意，在这种情况下，当 Redis 重新启动时，AOF 文件将用于重建原始数据集，因为它保证是最完整的。</li></ul><br/><h2 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h2><p class='p small'>RDB是指在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p> <p class='p small'>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p><strong><p class='p small'>Fork：</p></strong></p><p class='p small'>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p><br/><h3 id="如何触发RDB快照？"><a href="#如何触发RDB快照？" class="headerlink" title="如何触发RDB快照？"></a>如何触发RDB快照？</h3><p class='p small'>RDB是redis配置文件中默认的快照配置</p><p class='p small'>或执行命令来进行保存save或者是bgsave</p><p class='p small'>Save：save时只管保存，其它不管，全部阻塞</p><p class='p small'>BGSAVE：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间</p><p><strong><p class='p small'>Rdb 保存的是dump.rdb文件</p></strong></p><br/><h3 id="如何恢复？"><a href="#如何恢复？" class="headerlink" title="如何恢复？"></a>如何恢复？</h3><p class='p small'>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p><br/><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止?"></a>如何停止?</h3><p class='p small'>动态所有停止RDB保存规则的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config set save &quot;&quot;</span><br></pre></td></tr></table></figure><br/><h3 id="RDB的优劣势"><a href="#RDB的优劣势" class="headerlink" title="RDB的优劣势"></a>RDB的优劣势</h3><p class='p small'>优势：</p><p class='p small'>1、适合大规模的数据恢复</p><p class='p small'>2、对数据完整性和一致性要求不高</p><p class='p small'>劣势：</p><p class='p small'>1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</p><p class='p small'>2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/RDB%E6%80%BB%E7%BB%93.png" alt="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/RDB%E6%80%BB%E7%BB%93.png"></p><br/><h2 id="AOF是什么？"><a href="#AOF是什么？" class="headerlink" title="AOF是什么？"></a>AOF是什么？</h2><p class='p small'>AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><br/><h3 id="AOF启动-修复-恢复"><a href="#AOF启动-修复-恢复" class="headerlink" title="AOF启动/修复/恢复"></a>AOF启动/修复/恢复</h3><p><strong><p class='p small'>启动：</p></strong></p><p class='p small'>修改Redis配置文件中默认的appendonly no，改为yes</p><p><strong><p class='p small'>正常恢复：</p></strong></p><p class='p small'>重启redis之后会自动加载appendonly.aof文件</p><p><strong><p class='p small'>异常修复：</p></strong></p><p class='p small'>使用命令进行修复然后重启redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-check-aof --fix</span><br></pre></td></tr></table></figure><br/><h3 id="Rewrite是什么？"><a href="#Rewrite是什么？" class="headerlink" title="Rewrite是什么？"></a>Rewrite是什么？</h3><p class='p small'>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制</p><p><strong><p class='p small'>重写原理：</p></strong></p><p class='p small'>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p><p><strong><p class='p small'>触发机制：</p></strong></p><p class='p small'>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><br/><h3 id="AOF的优劣势"><a href="#AOF的优劣势" class="headerlink" title="AOF的优劣势"></a>AOF的优劣势</h3><p><strong><p class='p small'>优势：</p></strong></p><p class='p small'>每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p class='p small'>每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p class='p small'>不同步：appendfsync no 从不同步</p><p><strong>劣势：</strong></p><p class='p small'>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</p><p class='p small'>Aof运行效率要慢于rdb</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/AOF%E6%80%BB%E7%BB%93.png" alt="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/AOF%E6%80%BB%E7%BB%93.png"></p><br/><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p class='p small'>总得来说RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储，而AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p><p><strong><p class='p small'>一般建议两种持久化同时开启</p></strong></p><p class='p small'>在这种情况下</p><p class='p small'>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p><p><strong><p class='p small'>性能建议：</p></strong></p><p class='p small'>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p><p class='p small'>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</p><p class='p small'>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</p><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Redis</tag>

        </tags>

    </entry>


    <entry>
        <title>热部署Devtools</title>
        <link href="/2021/07/13/%E7%83%AD%E9%83%A8%E7%BD%B2Devtools/"/>
        <url>/2021/07/13/%E7%83%AD%E9%83%A8%E7%BD%B2Devtools/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>热部署Devtools</p><p class='p small'>1、将Devtools添加到pom中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p class='p small'>2、将插件添加到pom文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">        &lt;addResources&gt;true&lt;&#x2F;addResources&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">  &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在idea中找到File-Settings-Build-Compiler</p><p class='p small'>将以下四个选项全部勾上</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E7%83%AD%E9%83%A8%E7%BD%B2/%E7%83%AD%E9%83%A8%E7%BD%B2Dectools.png" alt=""></p><p class='p small'>4、在idea中使用ctrl+shift+Alt+/打开Registry配置</p><p class='p small'>将以下两个选项勾上</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E7%83%AD%E9%83%A8%E7%BD%B2/%E7%83%AD%E9%83%A8%E7%BD%B2Dectools02.png" alt=""></p><p class='p small'>5、重启idea查看热部署是否生效</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>热部署Devtools</tag>

        </tags>

    </entry>


    <entry>
        <title>Java的深拷贝和浅拷贝</title>
        <link href="/2021/07/12/Java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
        <url>/2021/07/12/Java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Java的浅拷贝和深拷贝</p><p class='p small'>关于Java的深拷贝和浅拷贝，简单来说就是创建一个和已知对象一模一样的对象。可能日常编码过程中用的不多，但是这是一个面试经常会问的问题，而且了解深拷贝和浅拷贝的原理，对于Java中的所谓值传递或者引用传递将会有更深的理解。</p><br/><h3 id="1、创建对象的5种方式"><a href="#1、创建对象的5种方式" class="headerlink" title="1、创建对象的5种方式"></a>1、创建对象的5种方式</h3><p><strong><p class='p small'>①、通过 new 关键字</p></strong></p><p class='p small'>这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。</p><p class='p small'>比如 Object obj = new Object();</p><p><strong><p class='p small'>②、通过 Class 类的 newInstance() 方法</p></strong></p><p class='p small'>这种默认是调用类的无参构造方法创建对象。比如 Person p2 = (Person) Class.forName(com.ys.test.Person).newInstance();</p><p><strong><p class='p small'>③、通过 Constructor 类的 newInstance 方法</p></strong></p><p class='p small'>这和第二种方法类时，都是通过反射来实现。通过 java.lang.relect.Constructor 类的 newInstance() 方法指定某个构造器来创建对象。</p><p class='p small'>Person p3 = (Person) Person.class.getConstructors()[0].newInstance();</p><p class='p small'>实际上第二种方法利用 Class 的 newInstance() 方法创建对象，其内部调用还是 Constructor 的newInstance() 方法。</p><p><strong><p class='p small'>④、利用 Clone 方法</p></strong></p><p class='p small'>Clone 是 Object 类中的一个方法，通过 对象A.clone() 方法会创建一个内容和对象 A 一模一样的对象 B，clone 克隆，顾名思义就是创建一个一模一样的对象出来。</p><p class='p small'>Person p4 = (Person) p3.clone();</p><p><strong><p class='p small'>⑤、反序列化</p></strong></p><p class='p small'>序列化是把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。而反序列化则是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。</p><br/><h3 id="2、Clone-方法"><a href="#2、Clone-方法" class="headerlink" title="2、Clone 方法"></a>2、Clone 方法</h3><p class='p small'>Java 的深拷贝和浅拷贝，其实现方式正是通过调用 Object 类的 clone() 方法来完成。在 Object.class 类中，源码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p class='p small'>这是一个用 native 关键字修饰的方法，不理解也没关系，只需要知道用 native 修饰的方法就是告诉操作系统，这个方法我不实现了，让操作系统去实现。具体怎么实现我们不需要了解，只需要知道 clone方法的作用就是复制对象，产生一个新的对象。那么这个新的对象和原对象是什么关系呢？</p><br/><h3 id="3、基本类型和引用类型"><a href="#3、基本类型和引用类型" class="headerlink" title="3、基本类型和引用类型"></a>3、基本类型和引用类型</h3><p class='p small'>这里再给大家普及一个概念，在 Java 中基本类型和引用类型的区别。</p><p class='p small'>在 Java 中数据类型可以分为两大类：基本类型和引用类型。</p><p class='p small'>基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。</p><p class='p small'>引用类型则包括类、接口、数组、枚举等。</p><p class='p small'>Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p><p>　　<img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt=""></p><p class='p small'>上图定义的 a 和 b 都是基本类型，其值是直接存放在栈中的；而 c 和 d 是 String 声明的，这是一个引用类型，引用地址是存放在 栈中，然后指向堆的内存空间。</p><p class='p small'>下面 d = c；这条语句表示将 c 的引用赋值给 d，那么 c 和 d 将指向同一块堆内存空间。</p><br/><h3 id="4、浅拷贝"><a href="#4、浅拷贝" class="headerlink" title="4、浅拷贝"></a>4、浅拷贝</h3><p class='p small'>以下代码为浅拷贝例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public Address address;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display(String name) &#123;</span><br><span class="line">        System.out.println(name + &quot;:&quot; + &quot;name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;,&quot; + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Address &#123;</span><br><span class="line">    private String provinces;</span><br><span class="line">    private String city;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address [provinces&#x3D;&quot; + provinces + &quot;, city&#x3D;&quot; + city + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address(String provinces, String city) &#123;</span><br><span class="line">        this.provinces &#x3D; provinces;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void testShallowClone() throws Exception &#123;</span><br><span class="line">        Person p1 &#x3D; new Person(&quot;张三&quot;, 21);</span><br><span class="line">        p1.setAddress(new Address(&quot;湖北省&quot;, &quot;武汉市&quot;));</span><br><span class="line">        Person p2 &#x3D; (Person) p1.clone();</span><br><span class="line">        System.out.println(&quot;p1:&quot; + p1.hashCode());</span><br><span class="line">        System.out.println(&quot;p1.getName:&quot; + p1.getName().hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;p2:&quot; + p2.hashCode());</span><br><span class="line">        System.out.println(&quot;p2.getName:&quot; + p2.getName().hashCode());</span><br><span class="line"></span><br><span class="line">        p1.display(&quot;p1&quot;);</span><br><span class="line">        p2.display(&quot;p2&quot;);</span><br><span class="line">        p2.setAddress(new Address(&quot;湖北省&quot;, &quot;荆州市&quot;));</span><br><span class="line">        System.out.println(&quot;将复制之后的对象地址修改：&quot;);</span><br><span class="line">        p1.display(&quot;p1&quot;);</span><br><span class="line">        p2.display(&quot;p2&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p class='p small'>测试结果为：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E4%BE%8B.png" alt=""></p><p class='p small'>首先看原始类 Person 实现 Cloneable 接口，并且覆写 clone 方法</p><p class='p small'>接着看测试内容，首先我们创建一个Person 类的对象 p1，其pname 为zhangsan</p><p class='p small'>代码中我们只是更改了克隆对象 p2 的属性 Address 为湖北省荆州市（原对象 p1 是湖北省武汉市） ，但是从打印结果来看，原对象 p1 和克隆对象 p2 的 Address 属性都被修改了。</p><p class='p small'>也就是说对象 Person 的属性 Address，经过 clone 之后，其实只是复制了其引用，他们指向的还是同一块堆内存空间，当修改其中一个对象的属性 Address，另一个也会跟着变化。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt=""></p><p><strong><p class='p small'>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</p></strong></p><br/><h3 id="5、深拷贝"><a href="#5、深拷贝" class="headerlink" title="5、深拷贝"></a>5、深拷贝</h3><p class='p small'>弄清楚了浅拷贝，那么深拷贝就很容易理解了。</p><p><strong><p class='p small'>深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。</p></strong></p><p>　　<img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt=""></p><p><strong><p class='p small'>Object 类提供的 clone 是只能实现 浅拷贝的。</p></strong></p><br/><h3 id="6、如何实现深拷贝？"><a href="#6、如何实现深拷贝？" class="headerlink" title="6、如何实现深拷贝？"></a>6、如何实现深拷贝？</h3><p class='p small'>深拷贝的原理我们知道了，就是要让原始对象和克隆之后的对象所具有的引用类型属性不是指向同一块堆内存，这里有三种实现思路。</p><p><strong><p class='p small'>①、让每个引用类型属性内部都重写clone() 方法</p></strong></p><p class='p small'>既然引用类型不能实现深拷贝，那么我们将每个引用类型都拆分为基本类型，分别进行浅拷贝。比如上面的例子，Person 类有一个引用类型 Address(其实String 也是引用类型，但是String类型有点特殊，后面会详细讲解)，我们在 Address 类内部也重写 clone 方法。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String provices;</span><br><span class="line">    private String city;</span><br><span class="line">    public void setAddress(String provices,String city)&#123;</span><br><span class="line">        this.provices &#x3D; provices;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address [provices&#x3D;&quot; + provices + &quot;, city&#x3D;&quot; + city + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>Person.class 的 clone() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Person p &#x3D; (Person) super.clone();</span><br><span class="line">        p.address &#x3D; (Address) address.clone();</span><br><span class="line">        return p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p class='p small'>测试还是和上面一样，我们会发现更改了p2对象的Address属性，p1 对象的 Address 属性并没有变化。</p><p class='p small'>但是这种做法有个弊端，这里我们Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p><p><strong><p class='p small'>②、利用序列化</p></strong></p><p class='p small'>序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。</p><p class='p small'>注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;深度拷贝</span><br><span class="line">public Object deepClone() throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F; 序列化</span><br><span class="line">    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">    oos.writeObject(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 反序列化</span><br><span class="line">    ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">    ObjectInputStream ois &#x3D; new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">    return ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。</p></strong></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Nginx的安装及高可用配置</title>
        <link href="/2021/07/11/Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
        <url>/2021/07/11/Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Nginx 简介</p><h3 id="1-1-Nginx-概述"><a href="#1-1-Nginx-概述" class="headerlink" title="1.1 Nginx 概述"></a>1.1 Nginx 概述</h3><p class='p small'>Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负 载的考验</p><br/><h3 id="1-2-正向代理"><a href="#1-2-正向代理" class="headerlink" title="1.2 正向代理"></a>1.2 正向代理</h3><p class='p small'>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p><br/><h3 id="1-3-反向代理"><a href="#1-3-反向代理" class="headerlink" title="1.3 反向代理"></a>1.3 反向代理</h3><p class='p small'>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p><br/><h3 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h3><p class='p small'>第一步 联网下载 pcre 压缩文件依赖并放置到usr/src目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;pcre&#x2F;pcre&#x2F;8.37&#x2F;pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure><p class='p small'>博主链接：</p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/nginx-1.12.2.tar.gz" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/nginx-1.12.2.tar.gz</a></p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/pcre-8.37.tar.gz" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/pcre-8.37.tar.gz</a></p><p class='p small'>第二步 解压压缩文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –zxvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure><p class='p small'>第三步./configure</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><p class='p small'>第四步 回到 pcre 目录下执行 make，最后执行 make install</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p class='p small'>第五步 安装 openssl 、zlib 、 gcc 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure><p class='p small'>第六步安装Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.12.2</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p class='p small'>第七步进入/usr/local/nginx/sbin/nginx目录启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p class='p small'>第八步测试nginx是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep ngix</span><br></pre></td></tr></table></figure><br/><h3 id="Nginx-的常用的命令（进入nginx-sbin目录中）"><a href="#Nginx-的常用的命令（进入nginx-sbin目录中）" class="headerlink" title="Nginx 的常用的命令（进入nginx/sbin目录中）"></a>Nginx 的常用的命令（进入nginx/sbin目录中）</h3><p class='p small'>1、查看 nginx 版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v</span><br></pre></td></tr></table></figure><p class='p small'>2、启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p class='p small'>3、停止nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure><p class='p small'>4、重新加载nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><br/><h3 id="Nginx-配置高可用的集群"><a href="#Nginx-配置高可用的集群" class="headerlink" title="Nginx 配置高可用的集群"></a>Nginx 配置高可用的集群</h3><p class='p small'>配置前操作</p><p class='p small'>（1）需要两台服务器 192.168.17.129 和 192.168.17.131</p><p class='p small'>（2）在两台服务器安装 nginx</p><p class='p small'>（3）在两台服务器安装 keepalived</p><p class='p small'>1、第一步安装 keepalived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived –y</span><br></pre></td></tr></table></figure><p class='p small'>2、第二步完成高可用配置（主从配置）</p><p><strong><p class='p small'>修改/etc/keepalived/keepalivec.conf 配置文件</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line"> notification_email &#123;</span><br><span class="line"> acassen@firewall.loc</span><br><span class="line"> failover@firewall.loc</span><br><span class="line"> sysadmin@firewall.loc</span><br><span class="line"> &#125;</span><br><span class="line"> notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line"> smtp_server 192.168.17.129</span><br><span class="line"> smtp_connect_timeout 30</span><br><span class="line"> router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line"> script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line"> interval 2 #（检测脚本执行的间隔）</span><br><span class="line"> weight 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line"> state BACKUP # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line"> interface ens33 &#x2F;&#x2F;网卡</span><br><span class="line"> virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同</span><br><span class="line"> priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line"> advert_int 1</span><br><span class="line"> authentication &#123;</span><br><span class="line"> auth_type PASS</span><br><span class="line"> auth_pass 1111</span><br><span class="line"> &#125;</span><br><span class="line"> virtual_ipaddress &#123;</span><br><span class="line"> 192.168.17.50 &#x2F;&#x2F; VRRP H 虚拟地址</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>3、第三步在/usr/local/src 添加检测脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx –no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line"> &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line"> sleep 2</span><br><span class="line"> if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line"> killall keepalived</span><br><span class="line"> fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p class='p small'>4、第四步，克隆一台虚拟机</p><p><strong><p class='p small'>右键虚拟机，选择管理，选择克隆，选择完整性克隆，接下来就是漫长的等待了</p></strong></p><p class='p small'>5、把两台服务器上 nginx 和 keepalived 启动</p><p><strong><p class='p small'>启动 nginx：./nginx</p></strong><br><strong><p class='p small'>启动 keepalived：systemctl start keepalived.service</p></strong></p><br/><h3 id="Nginx-的原理"><a href="#Nginx-的原理" class="headerlink" title="Nginx 的原理"></a>Nginx 的原理</h3><p class='p small'>1、mater 和 worker</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/Nginx%E5%8E%9F%E7%90%86.png'><p class='p small'>2、worker 如何进行工作的</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/worker%20%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B7%A5%E4%BD%9C%E7%9A%84.png'><p class='p small'>3、一个 master 和多个 woker 有好处</p><p class='p small'>（1）可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作</p><p class='p small'>（2）每个 woker 是独立的进程，如果有其中的一个 woker 出现问题，其他 woker 独立的，继续进行争抢，实现请求过程，不会造成服务中断</p><p class='p small'>4、设置多少个 woker 合适</p><p><strong><p class='p small'>worker 数和服务器的 cpu 数相等是最为适宜的</p></strong></p><p class='p small'>5、连接数 worker_connection</p><p class='p small'>第一个：发送请求，占用了 woker 的几个连接数？</p><p class='p small'>答案：2 或者 4 个</p><p class='p small'>第二个：nginx 有一个 master，有四个 woker，每个 woker 支持最大的连接数 1024，支持的 最大并发数是多少？</p><p class='p small'>普通的静态访问最大并发数是： worker_connections * worker_processes /2，</p><p class='p small'>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Nginx</tag>

        </tags>

    </entry>


    <entry>
        <title>SpringBoot面试题</title>
        <link href="/2021/07/10/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
        <url>/2021/07/10/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>SpringBoot面试题</p><p><strong><p class='p small'>1、Spring 是什么?</p></strong></p><p class='p small'>Spring 是一个轻量级的 IoC 和 AOP 容器框架。是为 Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的 开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于 XML 的配置、基于注解的配置、基于 Java 的配置。主要由以下几个模块组成：</p><p class='p small'>Spring Core：核心容器，提供 IOC 服务；核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</p><p class='p small'>Spring Context：应用上下文。Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p><p class='p small'>Spring AOP：Spring面向切面编程。通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p><p class='p small'>Spring DAO：JDBC和DAO模块。JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</p><p class='p small'>Spring ORM：对象实体映射。Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事务和DAO异常层次结构。</p><p class='p small'>Spring Web：Web模块。Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><p class='p small'>Spring MVC：MVC模块。MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI、FreeMarker等，模型来有JavaBean来构成，存放于m当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</p><br/><p><strong><p class='p small'>2、Resource 是如何被查找、加载的？</p></strong></p><p class='p small'>Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。 Spring 为 Resource 接口提供了如下实现类：</p><ul><li><p class='p small'>UrlResource：访问网络资源的实现类。</p></li><li><p class='p small'>ClassPathResource：访问类加载路径里资源的实现类。</p></li><li><p class='p small'>FileSystemResource：访问文件系统里资源的实现类。</p></li><li><p class='p small'>ServletContextResource：访问相对于 ServletContext 路径里的资源的实现类</p></li><li><p class='p small'>InputStreamResource：访问输入流资源的实现类。</p></li><li><p class='p small'>ByteArrayResource：访问字节数组资源的实现类。</p></li></ul><p class='p small'>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><br/><p><strong><p class='p small'>3、Spring 的AOP 理解：</p></strong></p><p class='p small'>OOP 面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些不业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系 统的可维护性。可用于权限认证、日志、事务处理。</p><p class='p small'>AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。</p><p class='p small'>（1）AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为编译时增强，他 会在编译阶段将 AspectJ(切面)织入到 Java 字节码中，运行的时候就是增强后的 AOP 对象。</p><p class='p small'>（2）Spring AOP 使用的动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p><strong><p class='p small'>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理：</p></strong></p><p class='p small'>①JDK 动态代理只提供接口的代理，不支持类的代理。核心 InvocationHandler 接口和 Proxy 类，InvocationHandler 通 过 invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy 利用 InvocationHandler 动态创建一个符合某一接口的的实例</p><p class='p small'>②如果代理类没有实现 InvocationHandler接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现 AOP。CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p><p class='p small'>（3）静态代理不动态代理区别在于生成 AOP 代理对象的时机不同，相对来说 AspectJ 的静态代理方式具有更好的性能，但是 AspectJ 需要特定的编译器动行处理，而 Spring AOP 则无需特定的编译器处理。</p><p><strong><p class='p small'>InvocationHandler 的 invoke(Object proxy，Method method，Object[] args)：proxy 是最终生成的代理实例，method 是被代理目 标实例的某个具体方法， args 是被代理目标实例某个方法的具体入参，在方法反射调用时使用。</p></strong></p> <br/><p><strong><p class='p small'>4、Spring 的 IoC 理解：</p></strong></p><p class='p small'>（1）IOC 就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖 IoC容器来动态注入对象需要的外部资源。</p><p class='p small'>（2）最直观的表达就是，IOC 让对象的创建不用去 new 了，可以由 spring 自动生产，使用 java 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p class='p small'>（3）Spring 的 IOC 有三种注入方式 ：极造器注入、setter 方法注入、根据注解注入。</p><p><strong><p class='p small'>IoC 让相互协作的组件保持松散的耦合，而 AOP 编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></strong></p> <br/><p><strong><p class='p small'>5、BeanFactory 和 ApplicationContext 有什么区别？</p></strong></p><p class='p small'>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p><p class='p small'>（1）BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制</p><p class='p small'>bean 的生命周期，维护 bean 之间的依赖关系。ApplicationContext接口作为 BeanFactory 的派生，除了提供BeanFactory 所具有的 功能外，还提供了更完整的框架功能：</p><p class='p small'>①继承 MessageSource，因此支持国际化。</p><p class='p small'>②统一的资源文件访问方式。</p><p class='p small'>③提供在监听器中注册 bean 的事件。</p><p class='p small'>④同时加载多个配置文件。</p><p class='p small'>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都与注于一个特定的层次，比如应用的 web 层。</p><p class='p small'>（2）①BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 动行加载实 例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使 用调用 getBean 方法才会抛出异常。</p><p class='p small'>②ApplicationContext，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的 配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean</p><p class='p small'>③相对于基本的 BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置 Bean较多时，程序启动较慢。</p><p class='p small'>（3）BeanFactory 通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</p><p class='p small'>（4）BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：</p><p><strong><p class='p small'>BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。</p></strong></p><table><thead><tr><th><strong>BeanFactory</strong></th><th><strong>ApplicationContext</strong></th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table> <br/><p><strong><p class='p small'>6、请解释 Spring Bean 的生命周期？</p></strong></p><p class='p small'>1、Bean 容器找到配置文件中 Spring Bean 的定义。</p><p class='p small'>2、Bean 容器利用 Java 反射创建一个Bean的实例。</p><p class='p small'>3、如果涉及到一些属性值 利用 set()方法设置一些属性值。</p><p class='p small'>4、如果Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。</p><p class='p small'>5、如果Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</p><p class='p small'>6、如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</p><p class='p small'>7、与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</p><p class='p small'>8、 如果有和加载这个 Bean 的 Spring 容器相关的BeanPostProcessor 对象，执行postProcessBeforeInitialization()方法</p><p class='p small'>9、如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</p><p class='p small'>10、如果Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</p><p class='p small'>11、如果有和加载这个 Bean的 Spring 容器相关的BeanPostProcessor 对象，执行postProcessAfterInitialization()方法</p><p class='p small'>12、当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</p><p class='p small'>13、当要销毁 Bean 的时候，如果 Bean在配置文件中的定义destroy-method 属性，执行指定的方法。</p><br/><p><strong><p class='p small'>7、 解释 Spring 支持的几种 bean 的作用域。</p></strong></p><p class='p small'>Spring 容器中的 bean 可以分为 5 个范围：</p><p class='p small'>（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。</p><p class='p small'>（2）prototype：为每一个 bean 请求提供一个实例。</p><p class='p small'>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。</p><p class='p small'>（4）session：与request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</p><p class='p small'>（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与Servlet 中的 session 作用域效果相同</p> <br/><p><strong><p class='p small'>8、Spring 框架中的单例 Beans 是线程安全的么？</p></strong></p><p class='p small'>Spring 框架并没有对单例 bean 动行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。</p> <br/><p><strong><p class='p small'>9、Spring 如何处理线程并发问题？</p></strong></p><p class='p small'>在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 动行处理，解决线程安全问题。ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的 方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时 间”的方式。</p><p class='p small'>ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程 都拥有自己的变量副本，从而也就没有必要对该变量动行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程 代码时，可以把不安全的变量封装动 ThreadLocal。</p> <br/><p><strong><p class='p small'>10-1、Spring 基于 xml 注入bean 的几种方式：</p></strong></p><p class='p small'>平常的 Java 开发中，程序员在某个类中需要依赖其它类的方法。通常是 new 一个依赖类的实例再调用该实例的方 法，这种开发存在的问题是new 的类实例不好统一管理。</p><p class='p small'>Spring 提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过 Spring 容器帮我们 new 指定实例并且将实例注入 到需要该对象的类中。依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们 new 一个实例，这个实例的控制 权是我们程序员。而控制反转是指 new 实例工作不由我们程序员来做而是交给 Spring 容器来做。Spring 有多种依赖注入 的形式</p><p><strong><p class='p small'>（1） Set 方法注入；</p></strong></p><p><strong><p class='p small'>（2）极造器注入：①通过 index 设置参数的位置；②通过 type 设置参数类型；</p></strong></p><p><strong><p class='p small'>（3）静态工厂注入；</p></strong></p><p><strong><p class='p small'>（4）实例工厂；</p></strong></p><br/><p><strong><p class='p small'>10-2、Spring 的自动装配：</p></strong></p><p class='p small'>在 Spring 框架 xml 配置中共有 5 种自动装配：</p><p class='p small'>（1）no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。</p><p class='p small'>（2）byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 不另一bean 的 name 相同，就进行自动 装配。</p><p class='p small'>（3）byType：通过参数的数据类型进行自动装配。</p><p class='p small'>（4）constructor：利用极造函数进行装配，并且极造函数的参数通过 byType 进行装配。</p><p class='p small'>（5）autodetect：自动探测，如果有极造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。</p><p class='p small'>基于注解的方式：</p><p class='p small'>使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置，<context:annotation-config />。在吭动 spring IoC 时，容器自动装载了一个 AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该 对象的属性。在使用@Autowired 时，首先在容器中查询对应类型的 bean：</p><p><strong><p class='p small'>如果查询结果刚好为一个，就将该bean 装配给@Autowired 指定的数据；</p></strong></p><p><strong><p class='p small'>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p></strong></p><p><strong><p class='p small'>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用 required=false。</p></strong></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringBoot</tag>

        </tags>

    </entry>


    <entry>
        <title>RabbitMQ集群</title>
        <link href="/2021/07/10/RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4/"/>
        <url>/2021/07/10/RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>RabbitMQ 集群</p><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><p class='p small'>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键</p><br/><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p><strong><p class='p small'>1.修改 3 台机器的主机名称</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure><p class='p small'>分别修改为node1，node2，node3</p><p><strong><p class='p small'>2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.186.110 node1</span><br><span class="line">192.168.186.111 node2</span><br><span class="line">192.168.186.112 node3</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>3.以确保各个节点的 cookie 文件使用的是同一个值</p></strong></p><p class='p small'>在 node1 上执行远程操作命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</span><br><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node3:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>4.启动 RabbitMQ 服务</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>5.在节点2 分别执行</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>6.在节点 3 分别执行</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>7.查看集群状态</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>8.需要重新设置用户</p></strong></p><p class='p small'>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123123</span><br></pre></td></tr></table></figure><p class='p small'>设置用户角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p class='p small'>设置用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><br/><h3 id="如何解除集群节点-node2-和-node3-机器分别执行"><a href="#如何解除集群节点-node2-和-node3-机器分别执行" class="headerlink" title="如何解除集群节点(node2 和 node3 机器分别执行)"></a>如何解除集群节点(node2 和 node3 机器分别执行)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>RabbitMQ</tag>

        </tags>

    </entry>


    <entry>
        <title>Mysql面试题总结</title>
        <link href="/2021/07/08/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
        <url>/2021/07/08/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Mysql面试题总结</p><h2 id="Q1：MySQL-的逻辑架构了解吗？"><a href="#Q1：MySQL-的逻辑架构了解吗？" class="headerlink" title="Q1：MySQL 的逻辑架构了解吗？"></a>Q1：MySQL 的逻辑架构了解吗？</h2><p class='p small'>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。</p><p class='p small'>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</p><p class='p small'>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p><br/><h2 id="Q2：谈一谈-MySQL-的读写锁"><a href="#Q2：谈一谈-MySQL-的读写锁" class="headerlink" title="Q2：谈一谈 MySQL 的读写锁"></a>Q2：谈一谈 MySQL 的读写锁</h2><p class='p small'>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p><p class='p small'>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。</p><br/><h2 id="Q3：MySQL-的锁策略有什么？"><a href="#Q3：MySQL-的锁策略有什么？" class="headerlink" title="Q3：MySQL 的锁策略有什么？"></a>Q3：MySQL 的锁策略有什么？</h2><p class='p small'>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。</p><p class='p small'>行锁可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。</p><br/><h2 id="Q4：数据库死锁如何解决？"><a href="#Q4：数据库死锁如何解决？" class="headerlink" title="Q4：数据库死锁如何解决？"></a>Q4：数据库死锁如何解决？</h2><p class='p small'>死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资源时也会产生死锁。</p><p class='p small'>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持有最少行级排它锁的事务进行回滚。</p><p class='p small'>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p><br/><h2 id="Q5：事务是什么"><a href="#Q5：事务是什么" class="headerlink" title="Q5：事务是什么?"></a>Q5：事务是什么?</h2><p class='p small'>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。</p><br/><h2 id="Q6：事务有什么特性？"><a href="#Q6：事务有什么特性？" class="headerlink" title="Q6：事务有什么特性？"></a>Q6：事务有什么特性？</h2><p><strong><p class='p small'>原子性 atomicity</p></strong></p><p class='p small'>一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。</p><p><strong><p class='p small'>一致性 consistency</p></strong></p><p class='p small'>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p><p><strong><p class='p small'>隔离性 isolation</p></strong></p><p class='p small'>针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong><p class='p small'>持久性 durability</p></strong></p><p class='p small'>一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p><br/><h2 id="Q7：MySQL-的隔离级别有哪些？"><a href="#Q7：MySQL-的隔离级别有哪些？" class="headerlink" title="Q7：MySQL 的隔离级别有哪些？"></a>Q7：MySQL 的隔离级别有哪些？</h2><p><strong><p class='p small'>未提交读 READ UNCOMMITTED</p></strong></p><p class='p small'>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有比其他级别好很多，很少使用。</p><p><strong><p class='p small'>提交读 READ COMMITTED</p></strong></p><p class='p small'>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能"看见"已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。</p><p><strong><p class='p small'>可重复读 REPEATABLE READ</p></strong>（MySQL默认的隔离级别）</p><p class='p small'>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。</p><p><strong><p class='p small'>可串行化 SERIALIZABLE</p></strong></p><p class='p small'>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。</p><br/><h2 id="Q8：MVCC-是什么？"><a href="#Q8：MVCC-是什么？" class="headerlink" title="Q8：MVCC 是什么？"></a>Q8：MVCC 是什么？</h2><p class='p small'>MVCC 是多版本并发控制，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p class='p small'>InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p class='p small'>MVCC 只能在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作，因为 `READ UNCOMMITTED` 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 `SERIALIZABLE` 则会对所有读取的行都加锁。</p><br/><h2 id="Q9：谈一谈-InnoDB"><a href="#Q9：谈一谈-InnoDB" class="headerlink" title="Q9：谈一谈 InnoDB"></a>Q9：谈一谈 InnoDB</h2><p class='p small'>InnoDB 是 MySQL 的默认事务型引擎，用来处理大量短期事务。InnoDB 的性能和自动崩溃恢复特性使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB。</p><p class='p small'>InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。</p><p class='p small'>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 `REPEATABLE READ`，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p><p class='p small'>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。</p><p class='p small'>InnoDB 的存储格式是平***立的，可以将数据和索引文件从一个平台复制到另一个平台。</p><p class='p small'>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><br/><h2 id="Q10：谈一谈-MyISAM"><a href="#Q10：谈一谈-MyISAM" class="headerlink" title="Q10：谈一谈 MyISAM"></a>Q10：谈一谈 MyISAM</h2><p class='p small'>MySQL5.1及之前，MyISAM 是默认存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。</p><p class='p small'>MyISAM 将表存储在数据文件和索引文件中，分别以 `.MYD` 和 `.MYI` 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。</p><p class='p small'>MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。</p><p class='p small'>对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。</p><p class='p small'>对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p><p class='p small'>MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。</p><br/><h2 id="Q11：谈一谈-Memory"><a href="#Q11：谈一谈-Memory" class="headerlink" title="Q11：谈一谈 Memory"></a>Q11：谈一谈 Memory</h2><p class='p small'>如果需要快速访问数据且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有数据都保存在内存，不需要磁盘 IO，Memory 表的结构在重启后会保留，但数据会丢失。</p><p class='p small'>Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存数据分析中产生的中间数据。</p><p class='p small'>Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。</p><p class='p small'>如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。</p><br/><h2 id="Q12：查询执行流程是什么？"><a href="#Q12：查询执行流程是什么？" class="headerlink" title="Q12：查询执行流程是什么？"></a>Q12：查询执行流程是什么？</h2><p class='p small'>简单来说分为五步： ① 客户端发送一条查询给服务器。 ② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。 ③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。 ④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。 ⑤ 将结果返回给客户端。</p><br/><h2 id="Q13：VARCHAR-和-CHAR-的区别？"><a href="#Q13：VARCHAR-和-CHAR-的区别？" class="headerlink" title="Q13：VARCHAR 和 CHAR 的区别？"></a>Q13：VARCHAR 和 CHAR 的区别？</h2><p class='p small'>VARCHAR用于存储可变字符串，是最常见的字符串数据类型。它比 CHAR 更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1 或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要 1 字节。VARCHAR 不会删除末尾空格。</p><p class='p small'>VARCHAR 适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。</p><p class='p small'>CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。</p><p class='p small'>CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。</p><br/><h2 id="Q14：DATETIME-和-TIMESTAMP-的区别？"><a href="#Q14：DATETIME-和-TIMESTAMP-的区别？" class="headerlink" title="Q14：DATETIME 和 TIMESTAMP 的区别？"></a>Q14：DATETIME 和 TIMESTAMP 的区别？</h2><p class='p small'>DATETIME能保存大范围的值，从 1001~9999 年，精度为秒。把日期和时间封装到了一个整数中，与时区无关，使用 8 字节存储空间。</p><p class='p small'>TIMESTAMP 和 UNIX 时间戳相同，只使用 4 字节的存储空间，范围比 DATETIME 小得多，只能表示 1970 ~2038 年，并且依赖于时区。</p><br/><h2 id="Q15：数据类型有哪些优化策略？"><a href="#Q15：数据类型有哪些优化策略？" class="headerlink" title="Q15：数据类型有哪些优化策略？"></a>Q15：数据类型有哪些优化策略？</h2><p><strong><p class='p small'>更小的通常更好</p></strong></p><p class='p small'>一般情况下尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常也更快，因为它们占用更少的磁盘、内存和 CPU 缓存。</p><p><strong><p class='p small'>尽可能简单</p></strong></p><p class='p small'>简单数据类型的操作通常需要更少的 CPU 周期，例如整数比字符操作代价更低，因为字符集和校对规则使字符相比整形更复杂。应该使用 MySQL 的内建类型 date、time 和 datetime 而不是字符串来存储日期和时间，另一点是应该使用整形存储 IP 地址。</p><p><strong><p class='p small'>尽量避免 NULL</p></strong></p><p class='p small'>通常情况下最好指定列为 NOT NULL，除非需要存储 NULL值。因为如果查询中包含可为 NULL 的列对 MySQL 来说更难优化，可为 NULL 的列使索引、索引统计和值比较都更复杂，并且会使用更多存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外字节，在MyISAM 中还可能导致固定大小的索引变成可变大小的索引。</p><p class='p small'>如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。</p><br/><h2 id="Q16：索引有什么作用？"><a href="#Q16：索引有什么作用？" class="headerlink" title="Q16：索引有什么作用？"></a>Q16：索引有什么作用？</h2><p class='p small'>索引也叫键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</p><p class='p small'>索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免排序和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。</p><p class='p small'>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能使用索引的最左前缀。</p><br/><h2 id="Q17：谈一谈-MySQL-的-B-Tree-索引"><a href="#Q17：谈一谈-MySQL-的-B-Tree-索引" class="headerlink" title="Q17：谈一谈 MySQL 的 B-Tree 索引"></a>Q17：谈一谈 MySQL 的 B-Tree 索引</h2><p class='p small'>大多数 MySQL 引擎都支持这种索引，但底层的存储引擎可能使用不同的存储结构，例如 NDB 使用 T-Tree，而 InnoDB 使用 B+ Tree。</p><p class='p small'>B-Tree 通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。</p><p class='p small'>B-Tree索引的限制：</p><ul><li><p class='p small'>如果不是按照索引的最左列开始查找，则无法使用索引。</p></li><li><p class='p small'>不能跳过索引中的列，例如索引为 (id，name，sex)，不能只使用 id 和 sex 而跳过 name。</p></li><li><p class='p small'>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</p></li></ul><br/><h2 id="Q18：了解-Hash-索引吗？"><a href="#Q18：了解-Hash-索引吗？" class="headerlink" title="Q18：了解 Hash 索引吗？"></a>Q18：了解 Hash 索引吗？</h2><p class='p small'>哈希索引基于[哈希表](https://www.cxyxiaowu.com/7741.html)实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在[哈希表](https://www.cxyxiaowu.com/7741.html)中保存指向每个数据行的指针。</p><p class='p small'>只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。</p><p class='p small'>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：</p><ul><li><p class='p small'>哈希索引数据不是按照索引值顺序存储的，无法用于排序。</p></li><li><p class='p small'>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a，b)上建立哈希索引，如果查询的列只有a就无法使用该索引。</p></li><li><p class='p small'>哈希索引只支持等值比较查询，不支持任何范围查询。</p></li></ul><br/><h2 id="Q19：什么是自适应哈希索引？"><a href="#Q19：什么是自适应哈希索引？" class="headerlink" title="Q19：什么是自适应哈希索引？"></a>Q19：什么是自适应哈希索引？</h2><p class='p small'>自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</p><br/><h2 id="Q20-：什么是空间索引？"><a href="#Q20-：什么是空间索引？" class="headerlink" title="Q20 ：什么是空间索引？"></a>Q20 ：什么是空间索引？</h2><p class='p small'>MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。</p><br/><h2 id="Q21：什么是全文索引？"><a href="#Q21：什么是全文索引？" class="headerlink" title="Q21：什么是全文索引？"></a>Q21：什么是全文索引？</h2><p class='p small'>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><p class='p small'>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的"文档指针"。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p><br/><h2 id="Q22：什么是聚簇索引？"><a href="#Q22：什么是聚簇索引？" class="headerlink" title="Q22：什么是聚簇索引？"></a>Q22：什么是聚簇索引？</h2><p class='p small'>聚簇索引不是一种索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p class='p small'>优点：① 可以把相关数据保存在一起。② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p><p class='p small'>缺点：① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。② 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。③ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</p><br/><h2 id="Q23：什么是覆盖索引？"><a href="#Q23：什么是覆盖索引？" class="headerlink" title="Q23：什么是覆盖索引？"></a>Q23：什么是覆盖索引？</h2><p class='p small'>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p><p class='p small'>优点：① 索引条目通常远小于数据行大小，可以极大减少数据访问量。② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</p><br/><h2 id="Q24：你知道哪些索引使用原则？"><a href="#Q24：你知道哪些索引使用原则？" class="headerlink" title="Q24：你知道哪些索引使用原则？"></a>Q24：你知道哪些索引使用原则？</h2><p><strong><p class='p small'>建立索引</p></strong></p><p class='p small'>对查询频次较高且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，应当挑选最常用、过滤效果最好的列的组合。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p><p><strong><p class='p small'>使用前缀索引</p></strong></p><p class='p small'>索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p><p><strong><p class='p small'>选择合适的索引顺序</p></strong></p><p class='p small'>当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。</p><p><strong><p class='p small'>删除无用索引</p></strong></p><p class='p small'>MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A，B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p><br/><h2 id="Q25：索引失效的情况有哪些？"><a href="#Q25：索引失效的情况有哪些？" class="headerlink" title="Q25：索引失效的情况有哪些？"></a>Q25：索引失效的情况有哪些？</h2><p class='p small'>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p><p class='p small'>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</p><p class='p small'>MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做比较。这种情况下 MySQL 只能提取数据行的值而不是索引值来做比较。</p><p class='p small'>如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。</p><p class='p small'>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。</p><p class='p small'>如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p><p class='p small'>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><br/><h2 id="Q26：如何定位低效-SQL？"><a href="#Q26：如何定位低效-SQL？" class="headerlink" title="Q26：如何定位低效 SQL？"></a>Q26：如何定位低效 SQL？</h2><p class='p small'>可以通过两种方式来定位执行效率较低的 SQL 语句。一种是通过慢查询日志定位，可以通过慢查询日志定位那些已经执行完毕的 SQL 语句。另一种是使用 SHOW PROCESSLIST 查询，慢查询日志在查询结束以后才记录，所以在应用反应执行效率出现问题的时候查询慢查询日志不能定位问题，此时可以使用 SHOW PROCESSLIST 命令查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实时查看 SQL 的执行情况，同时对一些锁表操作进行优化。找到执行效率低的 SQL 语句后，就可以通过 SHOW PROFILE、EXPLAIN 或 trace 等丰富来继续优化语句。</p><br/><h2 id="Q27：SHOW-PROFILE-的作用？"><a href="#Q27：SHOW-PROFILE-的作用？" class="headerlink" title="Q27：SHOW PROFILE 的作用？"></a>Q27：SHOW PROFILE 的作用？</h2><p class='p small'>通过 SHOW PROFILE 可以分析 SQL 语句性能消耗，例如查询到 SQL 会执行多少时间，并显示 CPU、内存使用量，执行过程中系统锁及表锁的花费时间等信息。例如 `SHOW PROFILE CPU/MEMORY/BLOCK IO FOR QUERY N` 分别查询 id 为 N 的 SQL 语句的 CPU、内存以及 IO 的消耗情况。</p><br/><h2 id="Q28：trace-是干什么的？"><a href="#Q28：trace-是干什么的？" class="headerlink" title="Q28：trace 是干什么的？"></a>Q28：trace 是干什么的？</h2><p class='p small'>从 MySQL5.6 开始，可以通过 trace 文件进一步获取优化器是是如何选择执行计划的，在使用时需要先打开设置，然后执行一次 SQL，最后查看 information_schema.optimizer_trace 表而都内容，该表为联合i表，只能在当前会话进行查询，每次查询后返回的都是最近一次执行的 SQL 语句。</p><br/><h2 id="Q29：EXPLAIN-的字段有哪些，具有什么含义？"><a href="#Q29：EXPLAIN-的字段有哪些，具有什么含义？" class="headerlink" title="Q29：EXPLAIN 的字段有哪些，具有什么含义？"></a>Q29：EXPLAIN 的字段有哪些，具有什么含义？</h2><p class='p small'>执行计划是 SQL 调优的一个重要依据，可以通过 EXPLAIN 命令查看 SQL 语句的执行计划，如果作用在表上，那么该命令相当于 DESC。EXPLAIN 的指标及含义如下：</p><table><thead><tr><th>指标名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>表示 SELECT 子句或操作表的顺序，执行顺序从大到小执行，当 id 一样时，执行顺序从上往下。</td></tr><tr><td>select_type</td><td>表示查询中每个 SELECT 子句的类型，例如 SIMPLE 表示不包含子查询、表连接或其他复杂语法的简单查询，PRIMARY 表示复杂查询的最外层查询，SUBQUERY 表示在 SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>type</td><td>表示访问类型，性能由差到好为：ALL 全表扫描、index 索引全扫描、range 索引范围扫描、ref 返回匹配某个单独值得所有行，常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找，也经常出现在 join 操作中、eq_ref 唯一性索引扫描，对于每个索引键只有一条记录与之匹配、const 当 MySQL 对查询某部分进行优化，并转为一个常量时，使用这些访问类型，例如将主键或唯一索引置于 WHERE 列表就能将该查询转为一个 const、system 表中只有一行数据或空表，只能用于 MyISAM 和 Memory 表、NULL 执行时不用访问表或索引就能得到结果。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</td></tr><tr><td>possible_keys</td><td>表示查询时可能用到的索引，但不一定使用。列出大量可能索引时意味着备选索引数量太多了。</td></tr><tr><td>key</td><td>显示 MySQL 在查询时实际使用的索引，如果没有使用则显示为 NULL。</td></tr><tr><td>key_len</td><td>表示使用到索引字段的长度，可通过该列计算查询中使用的索引的长度，对于确认索引有效性以及多列索引中用到的列数目很重要。</td></tr><tr><td>ref</td><td>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</td></tr><tr><td>rows</td><td>表示 MySQL 根据表统计信息及索引选用情况，估算找到所需记录所需要读取的行数。</td></tr><tr><td>Extra</td><td>表示额外信息，例如 Using temporary 表示需要使用临时表存储结果集，常见于排序和分组查询。Using filesort 表示无法利用索引完成的文件排序，这是 ORDER BY 的结果，可以通过合适的索引改进性能。Using index 表示只需要使用索引就可以满足查询表得要求，说明表正在使用覆盖索引。</td></tr></tbody></table><br/><h2 id="Q30：有哪些优化-SQL-的策略？"><a href="#Q30：有哪些优化-SQL-的策略？" class="headerlink" title="Q30：有哪些优化 SQL 的策略？"></a>Q30：有哪些优化 SQL 的策略？</h2><p><strong><p class='p small'>优化 COUNT 查询</p></strong></p><p class='p small'>COUNT 是一个特殊的函数，它可以统计某个列值的数量，在统计列值时要求列值是非空的，不会统计 NULL 值。如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。</p><p class='p small'>COUNT 的另一个作用是统计结果集的行数，当 MySQL 确定括号内的表达式不可能为 NULL 时，实际上就是在统计行数。当使用 COUNT(*) 时，\* 不会扩展成所有列，它会忽略所有的列而直接统计所有的行数。</p><p class='p small'>某些业务场景并不要求完全精确的 COUNT 值，此时可以使用近似值来代替，EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，因为执行 EXPLAIN 并不需要真正地执行查询。</p><p class='p small'>通常来说 COUNT 都需要扫描大量的行才能获取精确的结果，因此很难优化。在 MySQL 层还能做的就只有覆盖扫描了，如果还不够就需要修改应用的架构，可以增加汇总表或者外部缓存系统。</p><p><strong><p class='p small'>优化关联查询</p></strong></p><p class='p small'>确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p><p class='p small'>确保任何 GROUP BY 和 ORDER BY 的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化这个过程。</p><p class='p small'>在 MySQL 5.5 及以下版本尽量避免子查询，可以用关联查询代替，因为执行器会先执行外部的 SQL 再执行内部的 SQL。</p><p><strong><p class='p small'>优化 GROUP BY</p></strong></p><p class='p small'>如果没有通过 ORDER BY 子句显式指定要[排序](https://www.cxyxiaowu.com/11390.html)的列，当查询使用 GROUP BY 时，结果***自动按照分组的字段进行[排序](https://www.cxyxiaowu.com/11390.html)，如果不关心结果集的顺序，可以使用 ORDER BY NULL 禁止[排序](https://www.cxyxiaowu.com/11390.html)。</p><p><strong><p class='p small'>优化 LIMIT 分页</p></strong></p><p class='p small'>在偏移量非常大的时候，需要查询很多条数据再舍弃，这样的代价非常高。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。最简单的办法是尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p><p class='p small'>还有一种方法是从上一次取数据的位置开始扫描，这样就可以避免使用 OFFSET。其他优化方法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做[排序](https://www.cxyxiaowu.com/11390.html)的数据列。</p><p><strong><p class='p small'>优化 UNION 查询</p></strong></p><p class='p small'>MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。</p><p><strong><p class='p small'>使用用户自定义变量</p></strong></p><p class='p small'>在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在，可以在任何可以使用表达式的地方使用自定义变量。例如可以使用变量来避免重复查询刚刚更新过的数据、统计更新和插入的数量等。</p><p><strong><p class='p small'>优化 INSERT</p></strong></p><p class='p small'>需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句，这种方式将缩减客户端与数据库之间的连接、关闭等消耗，效率比多条插入单个值的 INSERT 语句高。也可以关闭事务的自动提交，在插入完数据后提交。当插入的数据是按主键的顺序插入时，效率更高。</p><br/><h2 id="Q31：MySQL-主从复制的作用？"><a href="#Q31：MySQL-主从复制的作用？" class="headerlink" title="Q31：MySQL 主从复制的作用？"></a>Q31：MySQL 主从复制的作用？</h2><p class='p small'>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。</p><p class='p small'>MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p><p class='p small'>MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。</p><p class='p small'>复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。</p><br/><h2 id="Q32：MySQL-主从复制的步骤？"><a href="#Q32：MySQL-主从复制的步骤？" class="headerlink" title="Q32：MySQL 主从复制的步骤？"></a>Q32：MySQL 主从复制的步骤？</h2><p class='p small'>① 在主库上把数据更改记录到二进制日志中。</p><p class='p small'>② 备库将主库的日志复制到自己的中继日志中。</p><p class='p small'>③ 备库读取中继日志中的事件，将其重放到备库数据之上。</p><p class='p small'>第一步是在主库上记录二进制日志，每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p><p class='p small'>下一步，备库将主库的二进制日志复制到其本地的中继日志中。备库首先会启动一个工作的 IO 线程，IO 线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库 IO 线程会将接收到的事件记录到中继日志中。</p><p class='p small'>备库的 SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当 SQL 线程追赶上 IO 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL 线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>Redis的五大数据类型及操作命令</title>
        <link href="/2021/07/07/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
        <url>
            /2021/07/07/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/
        </url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Redis的五大数据类型及常用命令</p><h3 id=""><a href="#" class="headerlink" title=""></a><p class='p small'>Redis 键(key) 的常用命令</p></h3><p class='p small'>该命令用在key存在时删除key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Del key</span><br></pre></td></tr></table></figure><p class='p small'>序列化给定key，并返回被序列化的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DUMP key</span><br></pre></td></tr></table></figure><p class='p small'>检查给定的key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS key</span><br></pre></td></tr></table></figure><p class='p small'>为给定key设置过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure><p class='p small'>EXPIREAT的作用和EXPIRE类似，都用于为key设置过期时间，不同在于EXPIREAT命令接受的时间参数是时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure><p class='p small'>设置key的过期时间以毫秒计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure><p class='p small'>查找所以符合给定模式的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure><p class='p small'>将当前数据库的key移动到给定的数据库db当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVE key db</span><br></pre></td></tr></table></figure><p class='p small'>移除key的过期时间，key将持久保持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSIST key</span><br></pre></td></tr></table></figure><p class='p small'>以毫秒为单位返回key的剩余过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTTL key</span><br></pre></td></tr></table></figure><p class='p small'>以秒为单位返回key的剩余过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL key</span><br></pre></td></tr></table></figure><p class='p small'>从当前库中随机返回一个key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANDOMKEY</span><br></pre></td></tr></table></figure><p class='p small'>修改key的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME key newkey</span><br></pre></td></tr></table></figure><p class='p small'>返回key所储存值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure><br/><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><p class='p small'>String（字符串）</p></h3><p class='p small'>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value，String类型是二进制安全的，意思是Redis的String可以包含任何数据，比如jpg图片或者序列化的对象</p><p><strong><p class='p small'>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p></strong></p><h4 id="Redis中String的常用命令"><a href="#Redis中String的常用命令" class="headerlink" title="Redis中String的常用命令"></a>Redis中String的常用命令</h4><p class='p small'>设置指定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure><p class='p small'>获取指定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><p class='p small'>获返回key中字符串值的子字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETRANGE key start end</span><br></pre></td></tr></table></figure><p class='p small'>将给定的key的值设为value，并返回key的旧值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><p class='p small'>对key所存储的字符串值，获取指定偏移量上的位（bit）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure><p class='p small'>获取一个或多个给定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key1 key2 key3......</span><br></pre></td></tr></table></figure><p class='p small'>对key所存储的字符串值，设置或清除指定偏移量上的位（bit）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure><p class='p small'>只有在key不存在时设置key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p class='p small'>将值value关联到key，并设置key的过期时间（秒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br></pre></td></tr></table></figure><p class='p small'>返回key所存储的字符串值的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p class='p small'>同时设置多个key value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>同时设置一个或者多个键值对，仅当前所有key都不存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSETNX k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>以毫秒为单位设置key的生存时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSETEX key milliseconds value</span><br></pre></td></tr></table></figure><p class='p small'>将key中存储的数字值增1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值加上给定的增量值（inceement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key inceement</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值加上给定的浮点增量值（inceement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><p class='p small'>将key中存储的数字减一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值减去给定的减量值（decrement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><p class='p small'>如果key存在并且是一个字符串，将值追加到key的末尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><br/><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><p class='p small'>Hash（哈希，类似java里的Map）</p></h3><p class='p small'>Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p class='p small'>类似Java里面的Map<String</p><p class='p small'>删除一个或多个哈西表字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key fieId2 field2.....</span><br></pre></td></tr></table></figure><p class='p small'>查看哈西表key中，指定的字段是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p class='p small'>获取存储在哈希表中指定字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p class='p small'>获取在哈希表中指定key的所有字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p class='p small'>为哈希表key中的指定字段的整数值加上增量increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure><p class='p small'>为哈希表key中的指定字段的浮点数值加上增量increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBYELOAT key field increment</span><br></pre></td></tr></table></figure><p class='p small'>获取所有哈希表中的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p class='p small'>获取哈希表中字段的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p class='p small'>获取所有给定字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field1 field2</span><br></pre></td></tr></table></figure><p class='p small'>同时将多个field-value对设置到哈希表key中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key firld1 value1 firld2 value2</span><br></pre></td></tr></table></figure><p class='p small'>将哈希表key中的字段firld的值设value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key firld value</span><br></pre></td></tr></table></figure><p class='p small'>只有在字段field不存在时，设置哈希表字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key firld value</span><br></pre></td></tr></table></figure><p class='p small'>获取哈希表中所有值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p class='p small'>迭代哈希表中的键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><br/><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><p class='p small'>List（列表）</p></h3><p class='p small'>Redis 列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素导列表的头部（左边）或者尾部（右边）它的底层实际是个链表</p><p class='p small'>通过索引获取列表中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p class='p small'>在列表的元素前或后插入元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFOREIAFTER pivot value</span><br></pre></td></tr></table></figure><p class='p small'>获取列表长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p class='p small'>移出并获取列表的第一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br></pre></td></tr></table></figure><p class='p small'>将一个或多个值插入到列表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>将一个或多个值插入到已存在的列表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>获取列表指定范围内的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p class='p small'>移除列表元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></table></figure><p class='p small'>通过索引设置列表元素的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表最后一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p class='p small'>移除列表最后一个元素，并将该元素添加到另一个列表并返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure><p class='p small'>在列表中添加一个或多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key v1 v2 v3......</span><br></pre></td></tr></table></figure><p class='p small'>为已存在的列表添加值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSHX key value</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表第一个元素，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLPOP k1 k2 timeout</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表最后一个元素，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP k1 k2 timeout</span><br></pre></td></tr></table></figure><p class='p small'>从列表弹出一个值，并将该元素插入到另一个列表中并返回他，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOPLPUSH source destination timeout</span><br></pre></td></tr></table></figure><br/><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><p class='p small'>Set（集合）</p></h3><p class='p small'>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的</p><p class='p small'>向集合添加一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 member2</span><br></pre></td></tr></table></figure><p class='p small'>获取集合的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key1 key2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的差集并存储在destination中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的交集并存储在destination中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>判断member元素是否是集合key的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p class='p small'>返回集合中所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p class='p small'>将member元素从source集合移动到destination集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p class='p small'>移除并返回集合中一个随机元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></table></figure><p class='p small'>返回集合中一个或多个随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key count</span><br></pre></td></tr></table></figure><p class='p small'>移除集合中一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member1 member2</span><br></pre></td></tr></table></figure><p class='p small'>返回所有给定集合的并集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>所有给定集合的并集存储在destination集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>迭代集合中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSCAN key cursor [MATCH pattem][COUNT count]</span><br></pre></td></tr></table></figure><br/><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><p class='p small'>Zset(sorted set：有序集合)</p></h3><p class='p small'>Redis zset 和 set 一样也是string类型元素的集合</p><p class='p small'>Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的</p><p class='p small'>向有序集合添加一个或多个成员，或者更新已存在成员的分数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure><p class='p small'>获取有序集合的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p class='p small'>计算在有序集合中指定区间分数的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p class='p small'>有序集合中对指定成员的分数加上增量 increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p class='p small'>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><p class='p small'>在有序集合中计算指定字典区间内成员数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZLEXCOUNT key min max</span><br></pre></td></tr></table></figure><p class='p small'>通过索引区间返回有序集合指定区间内的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>通过字典区间返回有序集合的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br></pre></td></tr></table></figure><p class='p small'>通过分数返回有序集合指定区间内的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集合中指定成员的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中的一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的字典区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYLEX key min max</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的排名区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的排名区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中指定区间内的成员，通过索引，分数从高到低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中指定分数区间内的成员，分数从高到低排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中，成员的分数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p class='p small'>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><p class='p small'>迭代有序集合中的元素（包括元素成员和元素分值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Redis</tag>

        </tags>

    </entry>


    <entry>
        <title>RabbitMQ安装教程及安装包</title>
        <link href="/2021/07/05/RabbitMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/"/>
        <url>/2021/07/05/RabbitMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p class='p small'>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><br/><h2 id="RabbitMQ-的概念"><a href="#RabbitMQ-的概念" class="headerlink" title="RabbitMQ 的概念"></a>RabbitMQ 的概念</h2><p class='p small'>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><br/><h2 id="RabbitMQ四大核心概念"><a href="#RabbitMQ四大核心概念" class="headerlink" title="RabbitMQ四大核心概念"></a>RabbitMQ四大核心概念</h2><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p class='p small'>产生数据发送消息的程序是生产者</p><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p class='p small'>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p class='p small'>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p class='p small'>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者</p><h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><h5 id="1、下载RabbitMQ，官网地址"><a href="#1、下载RabbitMQ，官网地址" class="headerlink" title="1、下载RabbitMQ，官网地址"></a>1、下载RabbitMQ，官网地址</h5><p><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p><p class='p small'>博主链接：</p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/erlang-21.3-1.el7.x86_64.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/erlang-21.3-1.el7.x86_64.rpm</a></p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/rabbitmq-server-3.8.8-1.el7.noarch.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p><h5 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h5><p class='p small'>上传到/usr/local/software 目录下(如果没有 software 需要自己创建)</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8501.png'><h5 id="3、安装文件-分别按照以下顺序安装"><a href="#3、安装文件-分别按照以下顺序安装" class="headerlink" title="3、安装文件(分别按照以下顺序安装)"></a>3、安装文件(分别按照以下顺序安装)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h5 id="4、常用命令-按照以下顺序执行"><a href="#4、常用命令-按照以下顺序执行" class="headerlink" title="4、常用命令(按照以下顺序执行)"></a>4、常用命令(按照以下顺序执行)</h5><p class='p small'>添加开机启动 RabbitMQ 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure><p class='p small'>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server start</span><br></pre></td></tr></table></figure><p class='p small'>查看服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server status</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8502.png'><p class='p small'>停止服务(选择执行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server stop</span><br></pre></td></tr></table></figure><p class='p small'>开启 web 管理插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p class='p small'>第一次用默认账号密码(guest)访问地址 http://127.0.0.1:15672/出现权限问题</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8503.png'><h5 id="5、添加一个新的用户"><a href="#5、添加一个新的用户" class="headerlink" title="5、添加一个新的用户"></a>5、添加一个新的用户</h5><p class='p small'>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123</span><br></pre></td></tr></table></figure><p class='p small'>设置用户角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p class='p small'>设置用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><p class='p small'>查看RabbitMQ中当前所有用户和角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h5 id="6、再次利用-admin-用户登录"><a href="#6、再次利用-admin-用户登录" class="headerlink" title="6、再次利用 admin 用户登录"></a>6、再次利用 admin 用户登录</h5><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8504.png'><h5 id="7、重置命令"><a href="#7、重置命令" class="headerlink" title="7、重置命令"></a>7、重置命令</h5><p class='p small'>关闭应用的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p class='p small'>清除的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure><p class='p small'>重新启动命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>RabbitMQ</tag>

        </tags>

    </entry>


    <entry>
        <title>Centos7防火墙设置</title>
        <link href="/2021/07/01/Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/"/>
        <url>/2021/07/01/Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Centos7防火墙设置</p><p class='p small'>查看已开放的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p class='p small'>开放端口（开放后需要要重启防火墙才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3338&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p class='p small'>关闭端口（关闭后需要要重启防火墙才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --remove-port&#x3D;3338&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p class='p small'>重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p class='p small'>开机启动防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p class='p small'>开启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p class='p small'>禁止防火墙开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p class='p small'>停止防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Liunx</tag>

        </tags>

    </entry>


</search>
