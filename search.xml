<?xml version="1.0" encoding="utf-8"?>
<search>


    <entry>
        <title>SpringBoot实现钉钉机器人消息推送异常信息</title>
        <link href="/2022/01/13/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/"/>
        <url>
            /2022/01/13/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/
        </url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="SpringBoot实现钉钉机器人消息推送异常信息"><a href="#SpringBoot实现钉钉机器人消息推送异常信息" class="headerlink" title="SpringBoot实现钉钉机器人消息推送异常信息"></a>SpringBoot实现钉钉机器人消息推送异常信息</h2><h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 全局异常处理器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class OverallExceptionResolver implements HandlerExceptionResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object o, Exception e) &#123;</span><br><span class="line">        log.error(&quot;&#123;&#125;中异常-----》&#123;&#125;&quot;, ((HandlerMethod) o).getBeanType(), e);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring MVC中，所有用于处理在请求处理过程中抛出的异常，都要实现HandlerExceptionResolver接口。HandlerExceptionResolver是Spring MVC提供的非常好的通用异常处理工具，不过需要注意的是，它只能处理请求过程中抛出的异常，异常处理本身所抛出的异常和视图解析过程中抛出的异常它是不能处理的</p><h3 id="实现钉钉通知"><a href="#实现钉钉通知" class="headerlink" title="实现钉钉通知"></a>实现钉钉通知</h3><p>打开需要进行消息提醒的钉钉群———》找到智能群助手——》添加机器人</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/01.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/02.png" alt=""></p><p>添加——》点击自定义——-》添加——-勾选加签</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/03.png" alt=""></p><p>然后点击设置中智能群助手，找到你刚刚添加的机器人并点击，我们可以看到Webhook的地址，保存好这一段地址（切勿泄露）</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/04.png" alt=""></p><p>下滑找到加签地址，复制保存好（切勿泄露）</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/05.png" alt=""></p><p>编写工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class DingDingServer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 告警提醒</span><br><span class="line">     * @param cls 类名称</span><br><span class="line">     * @param text 消息体</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void sendMessage(Class cls,  String text) &#123;</span><br><span class="line">        String atPhones &#x3D; &quot;&quot;;</span><br><span class="line">        String phones &#x3D; &quot;&quot;;</span><br><span class="line">     sendDingDingUtils2(&quot;填写你自己Webhook地址中的token&quot;,</span><br><span class="line">                &quot;填写你的加签地址&quot;,</span><br><span class="line">                &quot;类名：【&quot;+cls.getName()+&quot;】\n文字提示：&quot; + text , atPhones, phones);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 钉钉消息发送</span><br><span class="line">     * @param accessToken accessToken</span><br><span class="line">     * @param secret 加密的密钥</span><br><span class="line">     * @param text 内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void sendDingDingUtils2(String accessToken, String secret, String text, String atPhones, String phones) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Long timestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">            String stringToSign &#x3D; timestamp + &quot;\n&quot; + secret;</span><br><span class="line">            Mac mac &#x3D; Mac.getInstance(&quot;HmacSHA256&quot;);</span><br><span class="line">            mac.init(new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), &quot;HmacSHA256&quot;));</span><br><span class="line">            byte[] signData &#x3D; mac.doFinal(stringToSign.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            String encode &#x3D; URLEncoder.encode(new String(Base64.encodeBase64(signData)), StandardCharsets.UTF_8.name());</span><br><span class="line">            String url &#x3D; &quot;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;robot&#x2F;send?access_token&#x3D;&quot; + accessToken + &quot;&amp;timestamp&#x3D;&quot; + timestamp + &quot;&amp;sign&#x3D;&quot; + encode;</span><br><span class="line">            String  bodyContent &#x3D; &quot;&#123;\n&quot; +</span><br><span class="line">                    &quot;    \&quot;msgtype\&quot;: \&quot;text\&quot;,\n&quot; +</span><br><span class="line">                    &quot;    \&quot;text\&quot;: &#123;\n&quot; +</span><br><span class="line">                    &quot;        \&quot;content\&quot;: \&quot;&quot;+ text + &quot;\&quot;\n&quot; +</span><br><span class="line">                    &quot;    &#125;&quot; +</span><br><span class="line">                    &quot;&#125;&quot;;</span><br><span class="line">            if (StringUtils.isNotEmpty(phones)) &#123;</span><br><span class="line">                bodyContent &#x3D; &quot;&#123;\n&quot; +</span><br><span class="line">                        &quot;    \&quot;msgtype\&quot;: \&quot;text\&quot;,\n&quot; +</span><br><span class="line">                        &quot;    \&quot;text\&quot;: &#123;\n&quot; +</span><br><span class="line">                        &quot;        \&quot;content\&quot;: \&quot;&quot;+ text + &quot;\&quot;\n&quot; +</span><br><span class="line">                        &quot;    &#125;,\n&quot; +</span><br><span class="line">                        &quot;    \&quot;at\&quot;: &#123;\n&quot; +</span><br><span class="line">                        &quot;        \&quot;atMobiles\&quot;: [\n&quot; + phones +</span><br><span class="line">                        &quot;        ],\n&quot; +</span><br><span class="line">                        &quot;        \&quot;isAtAll\&quot;: true\n&quot; +</span><br><span class="line">                        &quot;    &#125;\n&quot; +</span><br><span class="line">                        &quot;&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            String body &#x3D; post(url,bodyContent);</span><br><span class="line">            System.out.println(body);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是修改刚刚异常捕获器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 全局异常处理器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class OverallExceptionResolver implements HandlerExceptionResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object o, Exception e) &#123;</span><br><span class="line">        DingDingServer.sendMessage(((HandlerMethod) o).getBeanType(),&quot;******[全局异常捕获]:异常---》&quot;+ e);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一块异常代码</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/06.png" alt=""></p><p>使用postmen请求后钉钉就会收到异常消息提醒啦</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringBoot%E5%AE%9E%E7%8E%B0%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/07.png" alt=""></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringBoot</tag>

        </tags>

    </entry>


    <entry>
        <title>MYSQL递归查询</title>
        <link href="/2021/12/27/MYSQL%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/"/>
        <url>/2021/12/27/MYSQL%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="MySQL中实现递归查询"><a href="#MySQL中实现递归查询" class="headerlink" title="MySQL中实现递归查询"></a>MySQL中实现递归查询</h2><p>对于数据库中的树形结构数据，如部门表，有时候，我们需要知道某部门的所有下属部分或者某部分的所有上级部门，这时候就需要用到mysql的递归查询</p><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;t_areainfo&#96;;</span><br><span class="line">CREATE TABLE &#96;t_areainfo&#96; (</span><br><span class="line"> &#96;id&#96; int(11) NOT &#39;0&#39; AUTO_INCREMENT,</span><br><span class="line"> &#96;level&#96; int(11) DEFAULT &#39;0&#39;,</span><br><span class="line"> &#96;name&#96; varchar(255) DEFAULT &#39;0&#39;,</span><br><span class="line"> &#96;parentId&#96; int(11) DEFAULT &#39;0&#39;,</span><br><span class="line"> &#96;status&#96; int(11) DEFAULT &#39;0&#39;,</span><br><span class="line"> PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;65 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><h3 id="2、初始数据"><a href="#2、初始数据" class="headerlink" title="2、初始数据"></a>2、初始数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;1&#39;, &#39;0&#39;, &#39;中国&#39;, &#39;0&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;2&#39;, &#39;0&#39;, &#39;华北区&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;3&#39;, &#39;0&#39;, &#39;华南区&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;4&#39;, &#39;0&#39;, &#39;北京&#39;, &#39;2&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;5&#39;, &#39;0&#39;, &#39;海淀区&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;6&#39;, &#39;0&#39;, &#39;丰台区&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;7&#39;, &#39;0&#39;, &#39;朝阳区&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;8&#39;, &#39;0&#39;, &#39;北京XX区1&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;9&#39;, &#39;0&#39;, &#39;北京XX区2&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;10&#39;, &#39;0&#39;, &#39;北京XX区3&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;11&#39;, &#39;0&#39;, &#39;北京XX区4&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;12&#39;, &#39;0&#39;, &#39;北京XX区5&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;13&#39;, &#39;0&#39;, &#39;北京XX区6&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;14&#39;, &#39;0&#39;, &#39;北京XX区7&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;15&#39;, &#39;0&#39;, &#39;北京XX区8&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;16&#39;, &#39;0&#39;, &#39;北京XX区9&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;17&#39;, &#39;0&#39;, &#39;北京XX区10&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;18&#39;, &#39;0&#39;, &#39;北京XX区11&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;19&#39;, &#39;0&#39;, &#39;北京XX区12&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;20&#39;, &#39;0&#39;, &#39;北京XX区13&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;21&#39;, &#39;0&#39;, &#39;北京XX区14&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;22&#39;, &#39;0&#39;, &#39;北京XX区15&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;23&#39;, &#39;0&#39;, &#39;北京XX区16&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;24&#39;, &#39;0&#39;, &#39;北京XX区17&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;25&#39;, &#39;0&#39;, &#39;北京XX区18&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;26&#39;, &#39;0&#39;, &#39;北京XX区19&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;27&#39;, &#39;0&#39;, &#39;北京XX区1&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;28&#39;, &#39;0&#39;, &#39;北京XX区2&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;29&#39;, &#39;0&#39;, &#39;北京XX区3&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;30&#39;, &#39;0&#39;, &#39;北京XX区4&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;31&#39;, &#39;0&#39;, &#39;北京XX区5&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;32&#39;, &#39;0&#39;, &#39;北京XX区6&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;33&#39;, &#39;0&#39;, &#39;北京XX区7&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;34&#39;, &#39;0&#39;, &#39;北京XX区8&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;35&#39;, &#39;0&#39;, &#39;北京XX区9&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;36&#39;, &#39;0&#39;, &#39;北京XX区10&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;37&#39;, &#39;0&#39;, &#39;北京XX区11&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;38&#39;, &#39;0&#39;, &#39;北京XX区12&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;39&#39;, &#39;0&#39;, &#39;北京XX区13&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;40&#39;, &#39;0&#39;, &#39;北京XX区14&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;41&#39;, &#39;0&#39;, &#39;北京XX区15&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;42&#39;, &#39;0&#39;, &#39;北京XX区16&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;43&#39;, &#39;0&#39;, &#39;北京XX区17&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;44&#39;, &#39;0&#39;, &#39;北京XX区18&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;45&#39;, &#39;0&#39;, &#39;北京XX区19&#39;, &#39;4&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;46&#39;, &#39;0&#39;, &#39;xx省1&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;47&#39;, &#39;0&#39;, &#39;xx省2&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;48&#39;, &#39;0&#39;, &#39;xx省3&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;49&#39;, &#39;0&#39;, &#39;xx省4&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;50&#39;, &#39;0&#39;, &#39;xx省5&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;51&#39;, &#39;0&#39;, &#39;xx省6&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;52&#39;, &#39;0&#39;, &#39;xx省7&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;53&#39;, &#39;0&#39;, &#39;xx省8&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;54&#39;, &#39;0&#39;, &#39;xx省9&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;55&#39;, &#39;0&#39;, &#39;xx省10&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;56&#39;, &#39;0&#39;, &#39;xx省11&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;57&#39;, &#39;0&#39;, &#39;xx省12&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;58&#39;, &#39;0&#39;, &#39;xx省13&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;59&#39;, &#39;0&#39;, &#39;xx省14&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;60&#39;, &#39;0&#39;, &#39;xx省15&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;61&#39;, &#39;0&#39;, &#39;xx省16&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;62&#39;, &#39;0&#39;, &#39;xx省17&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;63&#39;, &#39;0&#39;, &#39;xx省18&#39;, &#39;1&#39;, &#39;0&#39;);</span><br><span class="line">INSERT INTO &#96;t_areainfo&#96; VALUES (&#39;64&#39;, &#39;0&#39;, &#39;xx省19&#39;, &#39;1&#39;, &#39;0&#39;);</span><br></pre></td></tr></table></figure><h3 id="3、向下递归"><a href="#3、向下递归" class="headerlink" title="3、向下递归"></a>3、向下递归</h3><p>利用find_in_set()函数和group_concat()函数实现递归查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS queryChildrenAreaInfo;DELIMITER ;;</span><br><span class="line">CREATE FUNCTION queryChildrenAreaInfo(areaId INT)</span><br><span class="line">RETURNS VARCHAR(4000)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sTemp VARCHAR(4000);</span><br><span class="line">DECLARE sTempChd VARCHAR(4000);</span><br><span class="line"></span><br><span class="line">SET sTemp&#x3D;&#39;$&#39;;</span><br><span class="line">SET sTempChd &#x3D; CAST(areaId AS CHAR);</span><br><span class="line"></span><br><span class="line">WHILE sTempChd IS NOT NULL DO</span><br><span class="line">SET sTemp&#x3D; CONCAT(sTemp,&#39;,&#39;,sTempChd);</span><br><span class="line">SELECT GROUP_CONCAT(id) INTO sTempChd FROM t_areainfo WHERE FIND_IN_SET(parentId,sTempChd)&gt;0;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN sTemp;</span><br><span class="line">END;;DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="4、调用方式"><a href="#4、调用方式" class="headerlink" title="4、调用方式"></a>4、调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT queryChildrenAreaInfo(1);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/01.png" alt=""></p><p>查询id为”4”下面的所有节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_areainfo WHERE FIND_IN_SET(id,queryChildrenAreaInfo(4));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/02.png" alt=""></p><h3 id="5、向上递归"><a href="#5、向上递归" class="headerlink" title="5、向上递归"></a>5、向上递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS queryChildrenAreaInfo1;DELIMITER;;</span><br><span class="line">CREATE FUNCTION queryChildrenAreaInfo1(areaId INT)</span><br><span class="line">RETURNS VARCHAR(4000)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sTemp VARCHAR(4000);</span><br><span class="line">DECLARE sTempChd VARCHAR(4000);</span><br><span class="line"></span><br><span class="line">SET sTemp&#x3D;&#39;$&#39;;</span><br><span class="line">SET sTempChd &#x3D; CAST(areaId AS CHAR);</span><br><span class="line">SET sTemp &#x3D; CONCAT(sTemp,&#39;,&#39;,sTempChd);</span><br><span class="line"></span><br><span class="line">SELECT parentId INTO sTempChd FROM t_areainfo WHERE id &#x3D; sTempChd;</span><br><span class="line">WHILE sTempChd &lt;&gt; 0 DO</span><br><span class="line">SET sTemp &#x3D; CONCAT(sTemp,&#39;,&#39;,sTempChd);</span><br><span class="line">SELECT parentId INTO sTempChd FROM t_areainfo WHERE id &#x3D; sTempChd;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN sTemp;</span><br><span class="line">END;;DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="6、调用方式"><a href="#6、调用方式" class="headerlink" title="6、调用方式"></a>6、调用方式</h3><p>查询id为”7”的节点的所有上级节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from t_areainfo where FIND_IN_SET(id,queryChildrenAreaInfo1(7));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/03.png" alt=""></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>docker可视化工具Portainer部署与汉化</title>
        <link href="/2021/12/27/docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7Portainer%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B1%89%E5%8C%96/"/>
        <url>
            /2021/12/27/docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7Portainer%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B1%89%E5%8C%96/
        </url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="docker可视化工具Portainer部署与汉化"><a href="#docker可视化工具Portainer部署与汉化" class="headerlink" title="docker可视化工具Portainer部署与汉化"></a>docker可视化工具Portainer部署与汉化</h2><p>为了更好的观察Docker运行状态，我们采用Portainer工具进行可视化，下面是部署过程总结：</p><p>环境：</p><p>Liunx:CentOS Linux release 7.6.1810 (Core)</p><p>Docker:19.03.5（备注：默认版本存在问题）</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>1、查询当前Portainer镜像，选择start值比较高的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search portainer</span><br></pre></td></tr></table></figure><p>2、下载指定portainer镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer&#x2F;portainer</span><br></pre></td></tr></table></figure><p>3、本次只部署单机版，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data --name prtainer-test portainer&#x2F;portainer</span><br></pre></td></tr></table></figure><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p>-d：容器在后台运行；<br>-p 9000:9000 ：宿主机9000端口映射容器中的9000端口<br>–restart 标志会检查容器的退出代码，并据此来决定是否要重启容器，默认是不会重启。</p><p>–restart=always：自动重启该容器<br>-v /var/run/docker.sock:/var/run/docker.sock ：把宿主机的Docker守护进程(Docker daemon)默认监听的Unix域套接字挂载到容器中<br>-v portainer_data:/data ：把宿主机portainer_data数据卷挂载到容器/data目录<br>–name prtainer-test ： 给容器起名为portainer-test</p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>如果需要汉化，可以下载<a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E8%BD%AF%E4%BB%B6/public.zip" target="_blank" rel="noopener">汉化包</a>，之后解压，并将解压后的public文件夹上传到centos系统的根目录下</p><p>然后执行以下命令：（如果已部署，需要将之前的容器删除）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart&#x3D;always  -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data -v &#x2F;public:&#x2F;public --name prtainer-test  portainer&#x2F;portainer</span><br></pre></td></tr></table></figure><h3 id="Portainer的web页面登录"><a href="#Portainer的web页面登录" class="headerlink" title="Portainer的web页面登录"></a>Portainer的web页面登录</h3><p>在浏览器输入部署服务器的IP:9000，回车，显示如下界面：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Portainer/01.png" alt=""></p><p> 由于是本地docker，所以选择local</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Portainer/02.png" alt=""></p><p> 之后点击“Connect”，成功后跳转到主页界面（汉化后），如下图：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Portainer/03.png" alt=""></p><p> 点击“local”，进入该docker内，展示相关容器、堆栈、镜像等信息，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Portainer/04.png" alt=""></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Docker</tag>

        </tags>

    </entry>


    <entry>
        <title>Centos7中yapi的搭建</title>
        <link href="/2021/12/27/Centos7%E4%B8%ADyapi%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
        <url>/2021/12/27/Centos7%E4%B8%ADyapi%E7%9A%84%E6%90%AD%E5%BB%BA/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="Centos7-安装配置-Yapi"><a href="#Centos7-安装配置-Yapi" class="headerlink" title="Centos7 安装配置 Yapi"></a>Centos7 安装配置 Yapi</h2><h3 id="安装-nodejs-和-Yapi"><a href="#安装-nodejs-和-Yapi" class="headerlink" title="安装 nodejs 和 Yapi"></a>安装 nodejs 和 Yapi</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line">cd &#x2F;root</span><br><span class="line">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v12.18.2&#x2F;node-v12.18.2-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">tar -xf node-v12.18.2-linux-x64.tar.xz -C &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">mv node-v12.18.2-linux-x64&#x2F; nodejs&#x2F;</span><br><span class="line">ll</span><br><span class="line">chown root:root nodejs</span><br><span class="line">cd nodejs</span><br><span class="line">chown root:root * -R</span><br><span class="line">cd bin</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;nodejs&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm config get registry</span><br><span class="line">npm install -g pm2</span><br><span class="line">npm install -g yapi-cli --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;nodejs&#x2F;bin&#x2F;pm2 &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;nodejs&#x2F;bin&#x2F;yapi &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;nodejs&#x2F;bin&#x2F;yapi-cli &#x2F;usr&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure><h3 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;linux&#x2F;mongodb-linux-x86_64-4.0.0.tgz</span><br><span class="line">tar zxvf mongodb-linux-x86_64-4.0.0.tgz</span><br><span class="line">mv mongodb-linux-x86_64-4.0.0 &#x2F;usr&#x2F;local&#x2F;mongodb</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;</span><br><span class="line">touch mongodb.conf</span><br><span class="line">mkdir db log</span><br><span class="line">chmod 777 db</span><br><span class="line">chmod 777 log</span><br><span class="line"></span><br><span class="line"># 下面一段是写入配置</span><br><span class="line">cat &lt;&lt;&quot;EOF&quot; &gt; &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongodb.conf</span><br><span class="line">port&#x3D;27017</span><br><span class="line">dbpath&#x3D; &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;db</span><br><span class="line">logpath&#x3D; &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;log&#x2F;mongodb.log</span><br><span class="line">logappend&#x3D;true</span><br><span class="line">fork&#x3D;true</span><br><span class="line">maxConns&#x3D;100</span><br><span class="line">noauth&#x3D;true</span><br><span class="line">journal&#x3D;true</span><br><span class="line">storageEngine&#x3D;wiredTiger</span><br><span class="line">bind_ip &#x3D; 0.0.0.0</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#  创建软连接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line"># 启动 mongod</span><br><span class="line">mongod --config &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongodb.conf</span><br></pre></td></tr></table></figure><h3 id="初始化-Yapi"><a href="#初始化-Yapi" class="headerlink" title="初始化 Yapi"></a>初始化 Yapi</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yapi server   </span><br><span class="line"># 访问 http:&#x2F;&#x2F;127.0.0.1:9090 ,根据页面配置</span><br><span class="line"># 看到页面配置成功后可以 ctrl + c 停止本进程</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 如果 mongod 已运行，本条命令可以跳过</span><br><span class="line">mongod --config &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongodb.conf</span><br><span class="line"></span><br><span class="line"># pm2 启动</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;my-yapi</span><br><span class="line">pm2 start &quot;vendors&#x2F;server&#x2F;app.js&quot; --name yapi</span><br><span class="line"></span><br><span class="line"># 访问 http:&#x2F;&#x2F;127.0.0.1:3000，这个端口看初始化的时候配置是哪个就用哪个</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Linux</tag>

        </tags>

    </entry>


    <entry>
        <title>一千行MySQL学习笔记</title>
        <link href="/2021/09/07/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
        <url>/2021/09/07/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Windows服务 *&#x2F;</span><br><span class="line">-- 启动MySQL</span><br><span class="line">    net start mysql</span><br><span class="line">-- 创建Windows服务</span><br><span class="line">    sc create mysql binPath&#x3D; mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line">&#x2F;* 连接与断开服务器 *&#x2F;</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据库操作 *&#x2F; ------------------</span><br><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE &#39;PATTERN&#39;]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure><h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET &#x3D; charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE &#x3D; engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory&#x2F;Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">    AUTO_INCREMENT &#x3D; 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY &#x3D; &#39;目录&#39;</span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT &#x3D; &#39;string&#39;</span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE &#39;pattern&#39;]</span><br><span class="line">    SHOW TABLES FROM  库名</span><br><span class="line">-- 查看表结构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 &#x2F; DESCRIBE 表名 &#x2F; EXPLAIN 表名 &#x2F; SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE&#x3D;MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据操作 *&#x2F; ------------------</span><br><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名&#x3D;值[, 字段名&#x3D;值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名&#x3D;新值[, 字段名&#x3D;新值] [更新条件]</span><br></pre></td></tr></table></figure><h3 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 字符集编码 *&#x2F; ------------------</span><br><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE &#39;character_set_%&#39;   -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 &#x3D; 变量值</span><br><span class="line">    SET character_set_client &#x3D; gbk;</span><br><span class="line">    SET character_set_results &#x3D; gbk;</span><br><span class="line">    SET character_set_connection &#x3D; gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE &#39;pattern&#39;]&#x2F;SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure><h3 id="数据类型-列类型"><a href="#数据类型-列类型" class="headerlink" title="数据类型(列类型)"></a>数据类型(列类型)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 数据类型（列类型） *&#x2F; ------------------</span><br><span class="line">1. 数值类型</span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;</span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br><span class="line">2. 字符串类型</span><br><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2&#x3D;65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset&#x3D;utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)&#x2F;3</span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line">4. 枚举和集合</span><br><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );</span><br><span class="line">    insert into tab values (&#39;男, 女&#39;);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure><h3 id="列属性-列约束"><a href="#列属性-列约束" class="headerlink" title="列属性(列约束)"></a>列属性(列约束)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 列属性（列约束） *&#x2F; ------------------</span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null, &#39;val&#39;);</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment &#x3D; x进行设置，或 alter table tbl auto_increment &#x3D; x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment &#39;注释内容&#39;;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint &#96;t1_t2_fk&#96; foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure><h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 建表规范 *&#x2F; ------------------</span><br><span class="line">    -- Normal Format, NF</span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个ID字段作为主键</span><br><span class="line">        - ID主键 + 原子表</span><br><span class="line">    -- 1NF, 第一范式</span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    -- 2NF, 第二范式</span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除复合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    -- 3NF, 第三范式</span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SELECT *&#x2F; ------------------</span><br><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1&#x3D;1 AND key2&#x3D;2 AND key3&#x3D;3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            &#x3D;, &lt;&#x3D;&gt;, &lt;&gt;, !&#x3D;, &lt;&#x3D;, &lt;, &gt;&#x3D;, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is&#x2F;is not 加上ture&#x2F;false&#x2F;unknown，检验某个值的真假</span><br><span class="line">            &lt;&#x3D;&gt;与&lt;&gt;功能相同，&lt;&#x3D;&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段&#x2F;别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段&#x2F;别名 排序方式 [,排序字段&#x2F;别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* UNION *&#x2F; ------------------</span><br><span class="line">    将多个select查询的结果组合成一个结果集合。</span><br><span class="line">    SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line">    默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line">    ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各select查询的字段数量一样。</span><br><span class="line">    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 子查询 *&#x2F; ------------------</span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money &#x3D; (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    !&#x3D; all()    相当于 not in</span><br><span class="line">    &#x3D; some()    相当于 in。any 是 some 的别名</span><br><span class="line">    !&#x3D; some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure><h3 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 连接查询(join) *&#x2F; ------------------</span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num &#x3D; extra_info.stu_id;</span><br></pre></td></tr></table></figure><h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* TRUNCATE *&#x2F; ------------------</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure><h3 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 备份与还原 *&#x2F; ------------------</span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:&#x2F;a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">　　source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure><h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据完整性方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit &#x3D; 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure><h3 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 锁表 *&#x2F;</span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 触发器 *&#x2F; ------------------</span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure><h3 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SQL编程 *&#x2F; ------------------</span><br><span class="line">--&#x2F;&#x2F; 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line">--&#x2F;&#x2F; 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var &#x3D; value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免&#x3D;被当作关系运算符看待，使用:&#x3D;代替。（set语句可以使用&#x3D; 和 :&#x3D;）。</span><br><span class="line">select @var:&#x3D;20;</span><br><span class="line">select @v1:&#x3D;id, @v2&#x3D;name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:&#x3D;30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var&#x3D;10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line">--&#x2F;&#x2F; 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line">--&#x2F;&#x2F; 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) &#x3D; 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) &#x3D; 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) &#x3D; 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) &#x3D; 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3&#x3D;1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分</span><br><span class="line">time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分</span><br><span class="line">date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line">--&#x2F;&#x2F; 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE &#39;partten&#39;</span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line">--&#x2F;&#x2F; 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br></pre></td></tr></table></figure><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 存储过程 *&#x2F; ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 用户和权限管理 *&#x2F; ------------------</span><br><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE &#96;user&#96; SET PASSWORD&#x3D;PASSWORD(&quot;密码&quot;) WHERE &#96;user&#96; &#x3D; &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;</span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;密码&#39;)  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 &#x3D; PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限&#x2F;添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON &#96;pms&#96;.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure><h3 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 表维护 *&#x2F;</span><br><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option &#x3D; &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 杂项 *&#x2F; ------------------</span><br><span class="line">1. 可用反引号（&#96;）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 &#x2F;* 注释内容 *&#x2F;</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&#39;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure><br/><h3 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h3><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>MySQL事务隔离级别</title>
        <link href="/2021/09/07/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
        <url>/2021/09/07/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h3><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png" alt="事务的特性"></p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<ul><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li></ul></li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为     1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导        致A再读自己的工资时工资变为  2000；这就是不可重复读。</p><p> 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><p><del>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</del></p><p>🐛 问题更正：<strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p><blockquote><p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p></blockquote><h3 id="实际情况演示"><a href="#实际情况演示" class="headerlink" title="实际情况演示"></a>实际情况演示</h3><p>在下面我会使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。</p><p>MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TARNSACTION</code>。</p><p>我们可以通过下面的命令来设置隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">SESSION</span>|<span class="keyword">GLOBAL</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> [<span class="keyword">READ</span> UNCOMMITTED|<span class="keyword">READ</span> COMMITTED|REPEATABLE <span class="keyword">READ</span>|<span class="keyword">SERIALIZABLE</span>]</span><br></pre></td></tr></table></figure><p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p><ul><li><code>START TARNSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li><li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li><li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li></ul><h4 id="脏读-读未提交"><a href="#脏读-读未提交" class="headerlink" title="脏读(读未提交)"></a>脏读(读未提交)</h4><div align="center">  <img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2019-31-1%E8%84%8F%E8%AF%BB%28%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%29%E5%AE%9E%E4%BE%8B.jpg" width="800px"/></div><h4 id="避免脏读-读已提交"><a href="#避免脏读-读已提交" class="headerlink" title="避免脏读(读已提交)"></a>避免脏读(读已提交)</h4><div align="center">  <img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2019-31-2%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%AE%9E%E4%BE%8B.jpg" width="800px"/></div><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p><div align="center">  <img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2019-32-1%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%9E%E4%BE%8B.jpg"/></div><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><div align="center">  <img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2019-33-2%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpg"/></div><h4 id="防止幻读-可重复读"><a href="#防止幻读-可重复读" class="headerlink" title="防止幻读(可重复读)"></a>防止幻读(可重复读)</h4><div align="center">  <img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2019-33%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB%28%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%29.jpg"/></div><p>一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?</p><p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>Docker教程</title>
        <link href="/2021/09/07/Docker%E6%95%99%E7%A8%8B/"/>
        <url>/2021/09/07/Docker%E6%95%99%E7%A8%8B/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h3 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h3><h4 id="Docker为什么出现？"><a href="#Docker为什么出现？" class="headerlink" title="Docker为什么出现？"></a>Docker为什么出现？</h4><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p><p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p><p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p><p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p><p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p><p>开发环境Windows，最后发布到Linux！</p><p>传统：开发jar，运维来做！</p><p>现在：开发打包部署上线，一套流程做完！</p><p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p><p>Docker给以上的问题，提出了解决方案！</p><p>Docker的思想就来自于集装箱！</p><p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p><p><strong>Docker通过隔离机制，可以将服务器利用到极致！</strong></p><h4 id="比较Docker和虚拟机技术的不同"><a href="#比较Docker和虚拟机技术的不同" class="headerlink" title="比较Docker和虚拟机技术的不同"></a>比较Docker和虚拟机技术的不同</h4><p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p><p>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</p><p>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p><p>DevOps（开发、运维）</p><p>应用更快速的交付和部署</p><p>传统：一对帮助文档，安装程序。</p><p>Docker：打包镜像发布测试一键运行。</p><p>更便捷的升级和扩缩容</p><p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p><p>更简单的系统运维<br>在容器化之后，我们的开发，测试环境都是高度一致的</p><p>更高效的计算资源利用</p><p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>Docker的基本组成</p><p><strong>镜像（image)：</strong></p><p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像&gt;run&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）</p><p><strong>容器(container)：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p><p><strong>仓库(repository)：</strong></p><p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>我是虚拟机装的<strong>Centos7，linux 3.10 内核，docker官方说至少3.8以上，建议3.10以上</strong>（ubuntu下要linux内核3.8以上， RHEL/Centos 的内核修补过， centos6.5的版本就可以——这个可以试试）</p><p>1，root账户登录，查看内核版本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>2，把yum包更新到最新<strong>（温馨提示：新环境或测试环境可随意操作，生产环境酌情慎重更新）</strong>（期间要选择确认，输入 y 即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p>3，安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>4、设置yum源（阿里仓库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">yum-config-manager --add-repo</span><br></pre></td></tr></table></figure><p>5，可以查看所有仓库中所有docker版本，并选择特定版本安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>6，安装Docker，命令：yum install docker-ce-版本号，我选的是docker-ce-18.03.1.ce，如下（期间要选择确认，输入 y 即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.03.1.ce</span><br></pre></td></tr></table></figure><p>7， 启动Docker，命令：systemctl start docker，然后加入开机启动，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>8、查看Docker的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><strong>附一些常用Docker命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker ps 查看当前正在运行的容器</span><br><span class="line"></span><br><span class="line">docker ps -a 查看所有容器的状态</span><br><span class="line"></span><br><span class="line">docker start&#x2F;stop id&#x2F;name 启动&#x2F;停止某个容器</span><br><span class="line"></span><br><span class="line">docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)</span><br><span class="line"></span><br><span class="line">docker exec -ti id 启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）</span><br><span class="line"></span><br><span class="line">docker images 查看本地镜像</span><br><span class="line">docker rm id&#x2F;name 删除某个容器</span><br><span class="line">docker rmi id&#x2F;name 删除某个镜像</span><br><span class="line"></span><br><span class="line">docker run --name test -ti ubuntu &#x2F;bin&#x2F;bash  复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash</span><br><span class="line"></span><br><span class="line">docker build -t soar&#x2F;centos:7.1 .  通过当前目录下的Dockerfile创建一个名为soar&#x2F;centos:7.1的镜像</span><br><span class="line"></span><br><span class="line">docker run -d -p 2222:22 --name test soar&#x2F;centos:7.1  以镜像soar&#x2F;centos:7.1创建名为test的容器，并以后台模式运行，并做端口映射到宿主机2222端口，P参数重启容器宿主机端口会发生改变</span><br></pre></td></tr></table></figure><h3 id="搭建docker基本开发环境"><a href="#搭建docker基本开发环境" class="headerlink" title="搭建docker基本开发环境"></a>搭建docker基本开发环境</h3><h4 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h4><p>1、下载镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:8</span><br></pre></td></tr></table></figure><p>2、创建实例并启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name Mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:8</span><br></pre></td></tr></table></figure><p>参数说明</p><p>–name  指定容器名字 </p><p>-p  指定端口映射  </p><p>-e  设置mysql参数 </p><p>-d  后台运行</p><p>3、进入容器内部，修改时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>修改mysql的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</span><br></pre></td></tr></table></figure><p>在文件最后新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-time_zone &#x3D; &#39;+8:00&#39;</span><br></pre></td></tr></table></figure><p>如果未安装vim命令，可使用以下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><p>1、拉取docker镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>2、运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><p>3、最后我们可以通过浏览器可以直接访问 8080 端口的 nginx 服务：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/docker/docker%E6%95%99%E7%A8%8B/docker-nginx6.png" alt=""></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Docker</tag>

        </tags>

    </entry>


    <entry>
        <title>MySQL高性能优化规范建议</title>
        <link href="/2021/09/06/MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/"/>
        <url>/2021/09/06/MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h2><ul><li>所有数据库对象名称必须使用小写字母并用下划线分割</li><li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</li><li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><hr><h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="1-所有表必须使用-Innodb-存储引擎"><a href="#1-所有表必须使用-Innodb-存储引擎" class="headerlink" title="1. 所有表必须使用 Innodb 存储引擎"></a>1. 所有表必须使用 Innodb 存储引擎</h3><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p><p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h3 id="2-数据库和表的字符集统一使用-UTF8"><a href="#2-数据库和表的字符集统一使用-UTF8" class="headerlink" title="2. 数据库和表的字符集统一使用 UTF8"></a>2. 数据库和表的字符集统一使用 UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><p>参考文章：<a href="https://blog.csdn.net/horses/article/details/107243447" target="_blank" rel="noopener">MySQL 字符集不一致导致索引失效的一个真实案例</a></p><h3 id="3-所有表和字段都需要添加注释"><a href="#3-所有表和字段都需要添加注释" class="headerlink" title="3. 所有表和字段都需要添加注释"></a>3. 所有表和字段都需要添加注释</h3><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h3 id="4-尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#4-尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="4. 尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h3><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h3 id="5-谨慎使用-MySQL-分区表"><a href="#5-谨慎使用-MySQL-分区表" class="headerlink" title="5. 谨慎使用 MySQL 分区表"></a>5. 谨慎使用 MySQL 分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h3 id="6-尽量做到冷热数据分离-减小表的宽度"><a href="#6-尽量做到冷热数据分离-减小表的宽度" class="headerlink" title="6.尽量做到冷热数据分离,减小表的宽度"></a>6.尽量做到冷热数据分离,减小表的宽度</h3><blockquote><p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p></blockquote><p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p><p>更有效的利用缓存，避免读入无用的冷数据；</p><p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p><h3 id="7-禁止在表中建立预留字段"><a href="#7-禁止在表中建立预留字段" class="headerlink" title="7. 禁止在表中建立预留字段"></a>7. 禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义。</p><p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p><p>对预留字段类型的修改，会对表进行锁定。</p><h3 id="8-禁止在数据库中存储图片-文件等大的二进制数据"><a href="#8-禁止在数据库中存储图片-文件等大的二进制数据" class="headerlink" title="8. 禁止在数据库中存储图片,文件等大的二进制数据"></a>8. 禁止在数据库中存储图片,文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p><p>通常存储于文件服务器，数据库只存储文件地址信息</p><h3 id="9-禁止在线上做数据库压力测试"><a href="#9-禁止在线上做数据库压力测试" class="headerlink" title="9. 禁止在线上做数据库压力测试"></a>9. 禁止在线上做数据库压力测试</h3><h3 id="10-禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#10-禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="10. 禁止从开发环境,测试环境直接连接生产环境数据库"></a>10. 禁止从开发环境,测试环境直接连接生产环境数据库</h3><hr><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><h3 id="1-优先选择符合存储需要的最小的数据类型"><a href="#1-优先选择符合存储需要的最小的数据类型" class="headerlink" title="1. 优先选择符合存储需要的最小的数据类型"></a>1. 优先选择符合存储需要的最小的数据类型</h3><p><strong>原因：</strong></p><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p><p><strong>方法：</strong></p><p><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li>​                                                                                                                         把 ip 转为无符号整型 (4-8 位)</li><li>inet_ntoa 把整型的 ip 转为地址</li></ul><p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p><p><strong>原因：</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SIGNED INT -2147483648~2147483647</span><br><span class="line">UNSIGNED INT 0~4294967295</span><br></pre></td></tr></table></figure><p>VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。<strong>过大的长度会消耗更多的内存。</strong></p><h3 id="2-避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#2-避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a>2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p><p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487885&idx=1&sn=65b1bf5f7d4505502620179669a9c2df&chksm=ebd62ea1dca1a7b7bf884bcd9d538d78ba064ee03c09436ca8e57873b1d98a55afd6d7884cfc&scene=21#wechat_redirect" target="_blank" rel="noopener">MySQL</a> 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><h3 id="3-避免使用-ENUM-类型"><a href="#3-避免使用-ENUM-类型" class="headerlink" title="3. 避免使用 ENUM 类型"></a>3. 避免使用 ENUM 类型</h3><p>修改 ENUM 值需要使用 ALTER 语句</p><p>ENUM 类型的 ORDER BY 操作效率低，需要额外操作</p><p>禁止使用数值作为 ENUM 的枚举值</p><h3 id="4-尽可能把所有列定义为-NOT-NULL"><a href="#4-尽可能把所有列定义为-NOT-NULL" class="headerlink" title="4. 尽可能把所有列定义为 NOT NULL"></a>4. 尽可能把所有列定义为 NOT NULL</h3><p><strong>原因：</strong></p><p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p><p>进行比较和计算时要对 NULL 值做特别的处理</p><h3 id="5-使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间"><a href="#5-使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间" class="headerlink" title="5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间"></a>5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p><p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p><p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p><p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p><ul><li>缺点 1：无法用日期函数进行计算和比较</li><li>缺点 2：用字符串存储日期要占用更多的空间</li></ul><h3 id="6-同财务相关的金额类数据必须使用-decimal-类型"><a href="#6-同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="6. 同财务相关的金额类数据必须使用 decimal 类型"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h3><ul><li>非精准浮点：float,double</li><li>精准浮点：decimal</li></ul><p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p><p>占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节</p><p>可用于存储比 bigint 更大的整型数据</p><hr><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><h3 id="1-限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#1-限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="1. 限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>1. 限制每张表上的索引数量,建议单张表索引不超过 5 个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h3 id="2-禁止给表中的每一列都建立单独的索引"><a href="#2-禁止给表中的每一列都建立单独的索引" class="headerlink" title="2. 禁止给表中的每一列都建立单独的索引"></a>2. 禁止给表中的每一列都建立单独的索引</h3><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h3 id="3-每个-Innodb-表必须有个主键"><a href="#3-每个-Innodb-表必须有个主键" class="headerlink" title="3. 每个 Innodb 表必须有个主键"></a>3. 每个 Innodb 表必须有个主键</h3><p>Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>Innodb 是按照主键索引的顺序来组织表的</p><ul><li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><hr><h3 id="4-常见索引列建议"><a href="#4-常见索引列建议" class="headerlink" title="4. 常见索引列建议"></a>4. 常见索引列建议</h3><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><hr><h3 id="5-如何选择索引列的顺序"><a href="#5-如何选择索引列的顺序" class="headerlink" title="5.如何选择索引列的顺序"></a>5.如何选择索引列的顺序</h3><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><hr><h3 id="6-避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#6-避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><hr><h3 id="7-对于频繁的查询优先考虑使用覆盖索引"><a href="#7-对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="7. 对于频繁的查询优先考虑使用覆盖索引"></a>7. 对于频繁的查询优先考虑使用覆盖索引</h3><blockquote><p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p><strong>覆盖索引的好处：</strong></p><ul><li><strong>避免 Innodb 表进行索引的二次查询:</strong> Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><hr><h3 id="8-索引-SET-规范"><a href="#8-索引-SET-规范" class="headerlink" title="8.索引 SET 规范"></a>8.索引 SET 规范</h3><p><strong>尽量避免使用外键约束</strong></p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><hr><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><h3 id="1-建议使用预编译语句进行数据库操作"><a href="#1-建议使用预编译语句进行数据库操作" class="headerlink" title="1. 建议使用预编译语句进行数据库操作"></a>1. 建议使用预编译语句进行数据库操作</h3><p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</p><p>只传参数，比传递 SQL 语句更高效。</p><p>相同语句可以一次解析，多次使用，提高处理效率。</p><h3 id="2-避免数据类型的隐式转换"><a href="#2-避免数据类型的隐式转换" class="headerlink" title="2. 避免数据类型的隐式转换"></a>2. 避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,phone from customer where id &#x3D; &#39;111&#39;;</span><br></pre></td></tr></table></figure><h3 id="3-充分利用表上已经存在的索引"><a href="#3-充分利用表上已经存在的索引" class="headerlink" title="3. 充分利用表上已经存在的索引"></a>3. 充分利用表上已经存在的索引</h3><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h3 id="4-数据库设计时，应该要对以后扩展进行考虑"><a href="#4-数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="4. 数据库设计时，应该要对以后扩展进行考虑"></a>4. 数据库设计时，应该要对以后扩展进行考虑</h3><h3 id="5-程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#5-程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="5. 程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>5. 程序连接不同的数据库使用不同的账号，禁止跨库查询</h3><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h3 id="6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#6-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3><p><strong>原因：</strong></p><ul><li>消耗更多的 CPU 和 IO 以网络带宽资源</li><li>无法使用覆盖索引</li><li>可减少表结构变更带来的影响</li></ul><h3 id="7-禁止使用不含字段列表的-INSERT-语句"><a href="#7-禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="7. 禁止使用不含字段列表的 INSERT 语句"></a>7. 禁止使用不含字段列表的 INSERT 语句</h3><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br></pre></td></tr></table></figure><h3 id="8-避免使用子查询，可以把子查询优化为-join-操作"><a href="#8-避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="8. 避免使用子查询，可以把子查询优化为 join 操作"></a>8. 避免使用子查询，可以把子查询优化为 join 操作</h3><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong></p><p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h3 id="9-避免使用-JOIN-关联太多的表"><a href="#9-避免使用-JOIN-关联太多的表" class="headerlink" title="9. 避免使用 JOIN 关联太多的表"></a>9. 避免使用 JOIN 关联太多的表</h3><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><h3 id="10-减少同数据库的交互次数"><a href="#10-减少同数据库的交互次数" class="headerlink" title="10. 减少同数据库的交互次数"></a>10. 减少同数据库的交互次数</h3><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h3 id="11-对应同一列进行-or-判断时，使用-in-代替-or"><a href="#11-对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="11. 对应同一列进行 or 判断时，使用 in 代替 or"></a>11. 对应同一列进行 or 判断时，使用 in 代替 or</h3><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h3 id="12-禁止使用-order-by-rand-进行随机排序"><a href="#12-禁止使用-order-by-rand-进行随机排序" class="headerlink" title="12. 禁止使用 order by rand() 进行随机排序"></a>12. 禁止使用 order by rand() 进行随机排序</h3><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h3 id="13-WHERE-从句中禁止对列进行函数转换和计算"><a href="#13-WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="13. WHERE 从句中禁止对列进行函数转换和计算"></a>13. WHERE 从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where date(create_time)&#x3D;&#39;20190101&#39;</span><br></pre></td></tr></table></figure><p><strong>推荐：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where create_time &gt;&#x3D; &#39;20190101&#39; and create_time &lt; &#39;20190102&#39;</span><br></pre></td></tr></table></figure><h3 id="14-在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#14-在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul><h3 id="15-拆分复杂的大-SQL-为多个小-SQL"><a href="#15-拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="15. 拆分复杂的大 SQL 为多个小 SQL"></a>15. 拆分复杂的大 SQL 为多个小 SQL</h3><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul><hr><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><h3 id="1-超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#1-超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，<br>而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h3 id="2-对于大表使用-pt-online-schema-change-修改表结构"><a href="#2-对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="2. 对于大表使用 pt-online-schema-change 修改表结构"></a>2. 对于大表使用 pt-online-schema-change 修改表结构</h3><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h3 id="3-禁止为程序使用的账号赋予-super-权限"><a href="#3-禁止为程序使用的账号赋予-super-权限" class="headerlink" title="3. 禁止为程序使用的账号赋予 super 权限"></a>3. 禁止为程序使用的账号赋予 super 权限</h3><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账号使用</li></ul><h3 id="4-对于程序连接数据库账号-遵循权限最小原则"><a href="#4-对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="4. 对于程序连接数据库账号,遵循权限最小原则"></a>4. 对于程序连接数据库账号,遵循权限最小原则</h3><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>Mysql索引</title>
        <link href="/2021/09/04/Mysql%E7%B4%A2%E5%BC%95/"/>
        <url>/2021/09/04/Mysql%E7%B4%A2%E5%BC%95/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="覆盖索引介绍"><a href="#覆盖索引介绍" class="headerlink" title="覆盖索引介绍"></a>覆盖索引介绍</h2><h3 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><h3 id="覆盖索引使用实例"><a href="#覆盖索引使用实例" class="headerlink" title="覆盖索引使用实例"></a>覆盖索引使用实例</h3><p>现在我创建了索引(username,age)，我们执行下面的 sql 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username , age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="string">'Java'</span> <span class="keyword">and</span> age = <span class="number">22</span></span><br></pre></td></tr></table></figure><p>在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表。</p><h2 id="选择索引和编写利用这些索引的查询的3个原则"><a href="#选择索引和编写利用这些索引的查询的3个原则" class="headerlink" title="选择索引和编写利用这些索引的查询的3个原则"></a>选择索引和编写利用这些索引的查询的3个原则</h2><ol><li>单行访问是很慢的。特别是在机械硬盘存储中（SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。</li><li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 I/O 不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。</li><li>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。</li></ol><h2 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h2><h3 id="先从-MySQL-的基本存储结构说起"><a href="#先从-MySQL-的基本存储结构说起" class="headerlink" title="先从 MySQL 的基本存储结构说起"></a>先从 MySQL 的基本存储结构说起</h3><p>MySQL的基本存储结构是页(记录都存在页里边)：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E7%B4%A2%E5%BC%95/InnoDB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="MySQL的基本存储结构是页"></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E7%B4%A2%E5%BC%95/InnoDB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE2.jpg" alt=""></p><ul><li><strong>各个数据页可以组成一个双向链表</strong></li><li><strong>每个数据页中的记录又可以组成一个单向链表</strong><ul><li>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li></ul></li></ul><p>所以说，如果我们写select * from user where indexname = ‘xxx’这样没有进行任何优化的sql语句，默认会这样做：</p><ol><li><strong>定位到记录所在的页：需要遍历双向链表，找到所在的页</strong></li><li><strong>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</strong></li></ol><p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O(n)。</p><h3 id="使用索引之后"><a href="#使用索引之后" class="headerlink" title="使用索引之后"></a>使用索引之后</h3><p>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E7%B4%A2%E5%BC%95/InnoDB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE3.jpg" alt=""></p><p>要找到id为8的记录简要步骤：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E7%B4%A2%E5%BC%95/InnoDB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE4.jpg" alt=""></p><p>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 <strong>“目录”</strong> 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）</p><p>其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。</p><br/><h2 id="关于索引其他重要的内容补充"><a href="#关于索引其他重要的内容补充" class="headerlink" title="关于索引其他重要的内容补充"></a>关于索引其他重要的内容补充</h2><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引</span><br></pre></td></tr></table></figure><p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p><p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p><h3 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h3><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city）和（name）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><p>MySQL 5.7 版本后，可以通过查询 sys 库的 <code>schema_redundant_indexes</code> 表来查看冗余索引。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>Java中的BigDecimal类用法介绍</title>
        <link href="/2021/09/04/Java%E4%B8%AD%E7%9A%84BigDecimal%E7%B1%BB%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
        <url>/2021/09/04/Java%E4%B8%AD%E7%9A%84BigDecimal%E7%B1%BB%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Java中的BigDecimal类用法介绍</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java中提供了大数字(超过16位有效位)的操作类,即 <strong>java.math.BinInteger</strong> 类和 <strong>java.math.BigDecimal</strong> 类,用于高精度计算<br>其中 <strong>BigInteger</strong> 类是针对大整数的处理类,而 <strong>BigDecimal</strong> 类则是针对大小数的处理类<br><strong>BigDecimal</strong> 类的实现用到了 <strong>BigInteger</strong>类,不同的是 <strong>BigDecimal</strong> 加入了小数的概念</p><br/><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>float</strong>和<strong>Double</strong>只能用来做科学计算或者是工程计算;在商业计算中,对数字精度要求较高,必须使用 <strong>BigInteger</strong> 类和 <strong>BigDecimal</strong> 类,它支持任何精度的定点数,可以用它来精确计算货币值<br><strong>BigDecimal</strong>类创建的是对象,不能使用传统的+、-、x、/等算术运算符直接对其进行数学运算,而必须调用其对应的方法.方法的参数也必须是<strong>BigDecimal</strong>类型的对象</p><br/><h3 id="BigDecimal-对象常用方法"><a href="#BigDecimal-对象常用方法" class="headerlink" title="BigDecimal 对象常用方法"></a>BigDecimal 对象常用方法</h3><p>构造 BigDecimal 对象常用以下方法:<br>BigDecimal BigDecimal(double d);        <strong>//  不允许使用</strong><br>BigDecimal BigDecimal(String s);         <strong>//  常用,推荐使用</strong><br>static BigDecimal valueOf(double d);    <strong>//  常用,推荐使用</strong></p><p>其中,</p><ol><li>double 参数的构造方法,不允许使用!!!!因为它不能精确的得到相应的值;</li><li>String 构造方法是完全可预知的: 写入 new BigDecimal(“0.1”) 将创建一个 BigDecimal,它正好等于预期的0.1; 因此,通常建议优先使用 String 构造方法;</li><li>静态方法 valueOf(double val) 内部实现,仍是将 double 类型转为 String 类型; 这通常是将 double(或float)转化为 BigDecimal 的首选方法;</li></ol><br/><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>测试代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">double d1 &#x3D; 0.10334;</span><br><span class="line">double d2 &#x3D; 1234.0;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;new BigDecimal(&quot;+d1+&quot;)&#x3D;&quot; + new BigDecimal(d1)); &#x2F;&#x2F;此种方式绝对不允许!!!!!</span><br><span class="line">System.out.println(&quot;new BigDecimal(&quot;+d2+&quot;)&#x3D;&quot; + new BigDecimal(d2)); &#x2F;&#x2F;此种方式绝对不允许!!!!!</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;new BigDecimal(String.valueOf(&quot;+d1+&quot;))&#x3D;&quot; + new BigDecimal(String.valueOf(d1)));</span><br><span class="line">System.out.println(&quot;new BigDecimal(String.valueOf(&quot;+d2+&quot;))&#x3D;&quot; + new BigDecimal(String.valueOf(d2)));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;new BigDecimal(String.valueOf(&quot;+d1+&quot;))&#x3D;&quot; + new BigDecimal(Double.toString(d1)));</span><br><span class="line">System.out.println(&quot;new BigDecimal(String.valueOf(&quot;+d2+&quot;))&#x3D;&quot; + new BigDecimal(Double.toString(d2)));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;BigDecimal.valueOf(&quot;+d1+&quot;)&#x3D;&quot; + BigDecimal.valueOf(d1));</span><br><span class="line">System.out.println(&quot;BigDecimal.valueOf(&quot;+d2+&quot;)&#x3D;&quot; + BigDecimal.valueOf(d2));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"> </span><br><span class="line">BigDecimal b1 &#x3D; BigDecimal.valueOf(1);</span><br><span class="line">BigDecimal b2 &#x3D; BigDecimal.valueOf(1.00000);</span><br><span class="line">System.out.println(b1.equals(b2));</span><br><span class="line">System.out.println(b1.compareTo(b2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new BigDecimal(0.10334)&#x3D;0.10334000000000000130118138486068346537649631500244140625</span><br><span class="line">new BigDecimal(1234.0)&#x3D;1234</span><br><span class="line"> </span><br><span class="line">new BigDecimal(String.valueOf(0.10334))&#x3D;0.10334</span><br><span class="line">new BigDecimal(String.valueOf(1234.0))&#x3D;1234.0</span><br><span class="line"> </span><br><span class="line">new BigDecimal(String.valueOf(0.10334))&#x3D;0.10334</span><br><span class="line">new BigDecimal(String.valueOf(1234.0))&#x3D;1234.0</span><br><span class="line"> </span><br><span class="line">BigDecimal.valueOf(0.10334)&#x3D;0.10334</span><br><span class="line">BigDecimal.valueOf(1234.0)&#x3D;1234.0</span><br><span class="line"> </span><br><span class="line">false</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br/><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>BigDecimal 类的 valueOf()方法源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static BigDecimal valueOf(double val) &#123;</span><br><span class="line">return new BigDecimal(Double.toString(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BigDecimal类的几个常用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 求余数</span><br><span class="line"> * 返回值为 (this % divisor) 的 BigDecimal</span><br><span class="line"> *&#x2F;</span><br><span class="line">BigDecimal remainder(BigDecimal divisor);</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 求相反数</span><br><span class="line"> * 返回值是 (-this) 的 BigDecimal</span><br><span class="line"> *&#x2F;</span><br><span class="line">BigDecimal negate();</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将此 BigDecimal 与指定的 BigDecimal 比较</span><br><span class="line"> * 根据此方法,值相等但具有不同标度的两个 BigDecimal 对象（如，2.0 和 2.00）被认为是相等的;</span><br><span class="line"> * 相对六个 boolean 比较运算符 (&lt;, &#x3D;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;, &lt;&#x3D;) 中每一个运算符的各个方法,优先提供此方法;</span><br><span class="line"> * 建议使用以下语句执行上述比较：(x.compareTo(y) &lt;op&gt; 0), 其中 &lt;op&gt; 是六个比较运算符之一;</span><br><span class="line"> *</span><br><span class="line"> * 指定者：接口 Comparable&lt;BigDecimal&gt; 中的 compareTo</span><br><span class="line"> * 返回：当此 BigDecimal 在数字上小于、等于或大于 val 时，返回 -1、0 或 1</span><br><span class="line"> *&#x2F;</span><br><span class="line">int compareTo(BigDecimal val);</span><br></pre></td></tr></table></figure><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package com.util;</span><br><span class="line"> </span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 提供精确的浮点数运算(包括加、减、乘、除、四舍五入)工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArithUtil &#123;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 除法运算默认精度</span><br><span class="line">private static final int DEF_DIV_SCALE &#x3D; 10;</span><br><span class="line"> </span><br><span class="line">private ArithUtil() &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 精确加法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double add(double value1, double value2) &#123;</span><br><span class="line">BigDecimal b1 &#x3D; BigDecimal.valueOf(value1);</span><br><span class="line">BigDecimal b2 &#x3D; BigDecimal.valueOf(value2);</span><br><span class="line">return b1.add(b2).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 精确减法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double sub(double value1, double value2) &#123;</span><br><span class="line">BigDecimal b1 &#x3D; BigDecimal.valueOf(value1);</span><br><span class="line">BigDecimal b2 &#x3D; BigDecimal.valueOf(value2);</span><br><span class="line">return b1.subtract(b2).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 精确乘法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double mul(double value1, double value2) &#123;</span><br><span class="line">BigDecimal b1 &#x3D; BigDecimal.valueOf(value1);</span><br><span class="line">BigDecimal b2 &#x3D; BigDecimal.valueOf(value2);</span><br><span class="line">return b1.multiply(b2).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 精确除法 使用默认精度</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double div(double value1, double value2) throws IllegalAccessException &#123;</span><br><span class="line">return div(value1, value2, DEF_DIV_SCALE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 精确除法</span><br><span class="line"> * @param scale 精度</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double div(double value1, double value2, int scale) throws IllegalAccessException &#123;</span><br><span class="line">if(scale &lt; 0) &#123;</span><br><span class="line">throw new IllegalAccessException(&quot;精确度不能小于0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BigDecimal b1 &#x3D; BigDecimal.valueOf(value1);</span><br><span class="line">BigDecimal b2 &#x3D; BigDecimal.valueOf(value2);</span><br><span class="line">&#x2F;&#x2F; return b1.divide(b2, scale).doubleValue();</span><br><span class="line">return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 四舍五入</span><br><span class="line"> * @param scale 小数点后保留几位</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double round(double v, int scale) throws IllegalAccessException &#123;</span><br><span class="line">return div(v, 1, scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 比较大小</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean equalTo(BigDecimal b1, BigDecimal b2) &#123;</span><br><span class="line">if(b1 &#x3D;&#x3D; null || b2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return 0 &#x3D;&#x3D; b1.compareTo(b2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Java集合常用面试题</title>
        <link href="/2021/09/03/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
        <url>/2021/09/03/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="1-剖析面试最常见问题之-Java-集合框架"><a href="#1-剖析面试最常见问题之-Java-集合框架" class="headerlink" title="1. 剖析面试最常见问题之 Java 集合框架"></a>1. 剖析面试最常见问题之 Java 集合框架</h2><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1. 集合概述"></a>1.1. 集合概述</h2><h3 id="1-1-1-Java-集合概览"><a href="#1-1-1-Java-集合概览" class="headerlink" title="1.1.1. Java 集合概览"></a>1.1.1. Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collecton</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/java-collection-hierarchy.png" alt=""></p><p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p><h3 id="1-1-2-说说-List-Set-Queue-Map-四者的区别？"><a href="#1-1-2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="1.1.2. 说说 List, Set, Queue, Map 四者的区别？"></a>1.1.2. 说说 List, Set, Queue, Map 四者的区别？</h3><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="1-1-3-集合框架底层数据结构总结"><a href="#1-1-3-集合框架底层数据结构总结" class="headerlink" title="1.1.3. 集合框架底层数据结构总结"></a>1.1.3. 集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><h4 id="1-1-3-1-List"><a href="#1-1-3-1-List" class="headerlink" title="1.1.3.1. List"></a>1.1.3.1. List</h4><ul><li><code>Arraylist</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="1-1-3-2-Set"><a href="#1-1-3-2-Set" class="headerlink" title="1.1.3.2. Set"></a>1.1.3.2. Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="1-1-3-3-Queue"><a href="#1-1-3-3-Queue" class="headerlink" title="1.1.3.3 Queue"></a>1.1.3.3 Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h4 id="1-1-3-4-Map"><a href="#1-1-3-4-Map" class="headerlink" title="1.1.3.4. Map"></a>1.1.3.4. Map</h4><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="1-1-4-如何选用集合"><a href="#1-1-4-如何选用集合" class="headerlink" title="1.1.4. 如何选用集合?"></a>1.1.4. 如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><h3 id="1-1-5-为什么要使用集合？"><a href="#1-1-5-为什么要使用集合？" class="headerlink" title="1.1.5. 为什么要使用集合？"></a>1.1.5. 为什么要使用集合？</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，<br>因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p><p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。<br>但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p><h2 id="1-2-Collection-子接口之-List"><a href="#1-2-Collection-子接口之-List" class="headerlink" title="1.2. Collection 子接口之 List"></a>1.2. Collection 子接口之 List</h2><h3 id="1-2-1-Arraylist-和-Vector-的区别"><a href="#1-2-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.2.1. Arraylist 和 Vector 的区别?"></a>1.2.1. Arraylist 和 Vector 的区别?</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li></ul><h3 id="1-2-2-Arraylist-与-LinkedList-区别"><a href="#1-2-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2.2. Arraylist 与 LinkedList 区别?"></a>1.2.2. Arraylist 与 LinkedList 区别?</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h4 id="1-2-2-1-补充内容-双向链表和双向循环链表"><a href="#1-2-2-1-补充内容-双向链表和双向循环链表" class="headerlink" title="1.2.2.1. 补充内容:双向链表和双向循环链表"></a>1.2.2.1. 补充内容:双向链表和双向循环链表</h4><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><blockquote><p>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.im/post/5b5d1a9af265da0f47352f14" target="_blank" rel="noopener">https://juejin.im/post/5b5d1a9af265da0f47352f14</a></p></blockquote><p><img src= "/img/loading.gif" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><img src= "/img/loading.gif" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p><h4 id="1-2-2-2-补充内容-RandomAccess-接口"><a href="#1-2-2-2-补充内容-RandomAccess-接口" class="headerlink" title="1.2.2.2. 补充内容:RandomAccess 接口"></a>1.2.2.2. 补充内容:RandomAccess 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><h3 id="1-2-3-说一说-ArrayList-的扩容机制吧"><a href="#1-2-3-说一说-ArrayList-的扩容机制吧" class="headerlink" title="1.2.3. 说一说 ArrayList 的扩容机制吧"></a>1.2.3. 说一说 ArrayList 的扩容机制吧</h3><p>详见笔主的这篇文章:<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90" target="_blank" rel="noopener">通过源码一步一步分析 ArrayList 扩容机制</a></p><h2 id="1-3-Collection-子接口之-Set"><a href="#1-3-Collection-子接口之-Set" class="headerlink" title="1.3. Collection 子接口之 Set"></a>1.3. Collection 子接口之 Set</h2><h3 id="1-3-1-comparable-和-Comparator-的区别"><a href="#1-3-1-comparable-和-Comparator-的区别" class="headerlink" title="1.3.1. comparable 和 Comparator 的区别"></a>1.3.1. comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p><h4 id="1-3-1-1-Comparator-定制排序"><a href="#1-3-1-1-Comparator-定制排序" class="headerlink" title="1.3.1.1. Comparator 定制排序"></a>1.3.1.1. Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.reverse(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-1, 3, 3, -5, 7, 4, -9, -7]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-7, -9, 4, 7, -5, 3, 3, -1]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-9, -7, -5, -1, 3, 3, 4, 7]</span><br><span class="line">定制排序后：</span><br><span class="line">[7, 4, 3, 3, -1, -5, -7, -9]</span><br></pre></td></tr></table></figure><h4 id="1-3-1-2-重写-compareTo-方法实现按年龄来排序"><a href="#1-3-1-2-重写-compareTo-方法实现按年龄来排序" class="headerlink" title="1.3.1.2. 重写 compareTo 方法实现按年龄来排序"></a>1.3.1.2. 重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> TreeMap&lt;Person, String&gt;();</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>), <span class="string">"zhangsan"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>), <span class="string">"lisi"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">10</span>), <span class="string">"wangwu"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"小红"</span>, <span class="number">5</span>), <span class="string">"xiaohong"</span>);</span><br><span class="line">    <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">    Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">        System.out.println(key.getAge() + <span class="string">"-"</span> + key.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5-小红</span><br><span class="line">10-王五</span><br><span class="line">20-李四</span><br><span class="line">30-张三</span><br></pre></td></tr></table></figure><h3 id="1-3-2-无序性和不可重复性的含义是什么"><a href="#1-3-2-无序性和不可重复性的含义是什么" class="headerlink" title="1.3.2. 无序性和不可重复性的含义是什么"></a>1.3.2. 无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p><p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p><h3 id="1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p><p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p><p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h2 id="1-4-Collection-子接口之-Queue"><a href="#1-4-Collection-子接口之-Queue" class="headerlink" title="1.4 Collection 子接口之 Queue"></a>1.4 Collection 子接口之 Queue</h2><h3 id="1-4-1-Queue-与-Deque-的区别"><a href="#1-4-1-Queue-与-Deque-的区别" class="headerlink" title="1.4.1 Queue 与 Deque 的区别"></a>1.4.1 Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="1-4-2-ArrayDeque-与-LinkedList-的区别"><a href="#1-4-2-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="1.4.2 ArrayDeque 与 LinkedList 的区别"></a>1.4.2 ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="1-4-3-说一说-PriorityQueue"><a href="#1-4-3-说一说-PriorityQueue" class="headerlink" title="1.4.3 说一说 PriorityQueue"></a>1.4.3 说一说 PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h2 id="1-5-Map-接口"><a href="#1-5-Map-接口" class="headerlink" title="1.5. Map 接口"></a>1.5. Map 接口</h2><h3 id="1-5-1-HashMap-和-Hashtable-的区别"><a href="#1-5-1-HashMap-和-Hashtable-的区别" class="headerlink" title="1.5.1. HashMap 和 Hashtable 的区别"></a>1.5.1. HashMap 和 Hashtable 的区别</h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的,因为 <code>HashTable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>HashTable</code> 效率高一点。另外，<code>HashTable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-HashMap-和-HashSet-区别"><a href="#1-5-2-HashMap-和-HashSet-区别" class="headerlink" title="1.5.2. HashMap 和 HashSet 区别"></a>1.5.2. HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th align="center"><code>HashMap</code></th><th align="center"><code>HashSet</code></th></tr></thead><tbody><tr><td align="center">实现了 <code>Map</code> 接口</td><td align="center">实现 <code>Set</code> 接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向 map 中添加元素</td><td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h3 id="1-5-3-HashMap-和-TreeMap-区别"><a href="#1-5-3-HashMap-和-TreeMap-区别" class="headerlink" title="1.5.3. HashMap 和 TreeMap 区别"></a>1.5.3. HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/TreeMap%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt=""></p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年06月15日 17:02:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person person1, Person person2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num = person1.getAge() - person2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">3</span>), <span class="string">"person1"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">18</span>), <span class="string">"person2"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">35</span>), <span class="string">"person3"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="number">16</span>), <span class="string">"person4"</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1</span><br><span class="line">person4</span><br><span class="line">person2</span><br><span class="line">person3</span><br></pre></td></tr></table></figure><p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p><p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;((person1, person2) -&gt; &#123;</span><br><span class="line">  <span class="keyword">int</span> num = person1.getAge() - person2.getAge();</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h3 id="1-5-4-HashSet-如何检查重复"><a href="#1-5-4-HashSet-如何检查重复" class="headerlink" title="1.5.4. HashSet 如何检查重复"></a>1.5.4. HashSet 如何检查重复</h3><p>以下内容摘自我的 Java 启蒙书《Head first java》第二版：</p><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当set中没有包含add的元素时返回真</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns : previous value, or null if none</span></span><br><span class="line"><span class="comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p><p><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></p><ol><li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li><li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li><li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li><li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与 equals 的区别</strong></p><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p><h3 id="1-5-5-HashMap-的底层实现"><a href="#1-5-5-HashMap-的底层实现" class="headerlink" title="1.5.5. HashMap 的底层实现"></a>1.5.5. HashMap 的底层实现</h3><h4 id="1-5-5-1-JDK1-8-之前"><a href="#1-5-5-1-JDK1-8-之前" class="headerlink" title="1.5.5.1. JDK1.8 之前"></a>1.5.5.1. JDK1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之前的内部结构-HashMap"></p><h4 id="1-5-5-2-JDK1-8-之后"><a href="#1-5-5-2-JDK1-8-之后" class="headerlink" title="1.5.5.2. JDK1.8 之后"></a>1.5.5.2. JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/jdk1.8%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之后的内部结构-HashMap"></p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h3 id="1-5-6-HashMap-的长度为什么是-2-的幂次方"><a href="#1-5-6-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="1.5.6. HashMap 的长度为什么是 2 的幂次方"></a>1.5.6. HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h3 id="1-5-7-HashMap-多线程操作导致死循环问题"><a href="#1-5-7-HashMap-多线程操作导致死循环问题" class="headerlink" title="1.5.7. HashMap 多线程操作导致死循环问题"></a>1.5.7. HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p><h3 id="1-5-8-HashMap-有哪几种常见的遍历方式"><a href="#1-5-8-HashMap-有哪几种常见的遍历方式" class="headerlink" title="1.5.8. HashMap 有哪几种常见的遍历方式?"></a>1.5.8. HashMap 有哪几种常见的遍历方式?</h3><p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw" target="_blank" rel="noopener">HashMap 的 7 种遍历方式与性能分析！</a></p><h3 id="1-5-9-ConcurrentHashMap-和-Hashtable-的区别"><a href="#1-5-9-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="1.5.9. ConcurrentHashMap 和 Hashtable 的区别"></a>1.5.9. ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p><strong>HashTable:</strong></p><p><img src= "/img/loading.gif" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable全表锁"></p><p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><p><img src= "/img/loading.gif" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg" alt="JDK1.7的ConcurrentHashMap"></p><p style="text-align:right;font-size:13px;color:gray">https://www.cnblogs.com/chengxiao/p/6842045.html></p><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><p><img src= "/img/loading.gif" data-src="./images/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）"></p><p>JDK1.8 的 <code>ConcurrentHashMap</code> 不在是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h3 id="1-5-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#1-5-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="1.5.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>1.5.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3><h4 id="1-5-10-1-JDK1-7（上面有示意图）"><a href="#1-5-10-1-JDK1-7（上面有示意图）" class="headerlink" title="1.5.10.1. JDK1.7（上面有示意图）"></a>1.5.10.1. JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p><h4 id="1-5-10-2-JDK1-8-（上面有示意图）"><a href="#1-5-10-2-JDK1-8-（上面有示意图）" class="headerlink" title="1.5.10.2. JDK1.8 （上面有示意图）"></a>1.5.10.2. JDK1.8 （上面有示意图）</h4><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p><p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h2 id="1-6-Collections-工具类"><a href="#1-6-Collections-工具类" class="headerlink" title="1.6. Collections 工具类"></a>1.6. Collections 工具类</h2><p>Collections 工具类常用方法:</p><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h3 id="1-6-1-排序操作"><a href="#1-6-1-排序操作" class="headerlink" title="1.6.1. 排序操作"></a>1.6.1. 排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure><h3 id="1-6-2-查找-替换操作"><a href="#1-6-2-查找-替换操作" class="headerlink" title="1.6.2. 查找,替换操作"></a>1.6.2. 查找,替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><h3 id="1-6-3-同步控制"><a href="#1-6-3-同步控制" class="headerlink" title="1.6.3. 同步控制"></a>1.6.3. 同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>LinkedList源码分析</title>
        <link href="/2021/09/03/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
        <url>/2021/09/03/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font face="楷体" id="1">简介</font></h2><p><font color="red">LinkedList</font>是一个实现了<font color="red">List接口</font>和<font color="red">Deque接口</font>的<font color="red">双端链表</font>。<br>LinkedList底层的链表结构使它<font color="red">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;<br>LinkedList<font color="red">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color="red">Collections类</font>中的<font color="red">synchronizedList</font>方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><h2 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a><font face="楷体" id="2">内部结构分析</font></h2><p><strong>如下图所示：</strong></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/LinkedList/LinkedList%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="LinkedList内部结构"><br>看完了图之后，我们再看LinkedList类中的一个<font color="red"><strong>内部私有类Node</strong></font>就很好理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//节点值</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a><font face="楷体" id="3">LinkedList源码分析</font></h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><font face="楷体" id="3.1">构造方法</font></h3><p><strong>空构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用已有的集合创建链表的构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a><font face="楷体" id="3.2">add方法</font></h3><p><strong>add(E e)</strong> 方法：将元素添加到链表尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);<span class="comment">//这里就只调用了这一个方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 链接使e作为最后一个元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">     last = newNode;<span class="comment">//新建节点</span></span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         l.next = newNode;<span class="comment">//指向后继元素也就是指向下一个元素</span></span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>add(int index,E e)</strong>：在指定位置添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index); <span class="comment">//检查索引是否处于[0-size]之间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)<span class="comment">//添加在链表尾部</span></span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//添加在链表中间</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">linkBefore方法</font>需要给定两个参数，一个<font color="red">插入节点的值</font>，一个<font color="red">指定的node</font>，所以我们又调用了<font color="red">Node(index)去找到index对应的node</font></p><p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:检查index范围是否在size之内</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="comment">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4：遍历数据将数据插入</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            <span class="comment">//创建新节点</span></span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//如果插入位置在链表头部</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果插入位置在尾部，重置last节点</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，将插入的链表与先前链表连接起来</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面可以看出addAll方法通常包括下面四个步骤：</p><ol><li>检查index范围是否在size之内</li><li>toArray()方法把集合的数据存到对象数组中</li><li>得到插入位置的前驱和后继节点</li><li>遍历数据，将数据插入到指定位置</li></ol><p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       linkFirst(e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//新建节点，以头节点为后继节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//如果链表为空，last节点也指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="comment">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a><font face="楷体" id="3.3">根据位置取数据的方法</font></h3><p><strong>get(int index)：</strong> 根据指定索引返回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index范围是否在size之内</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>获取头节点（index=0）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong><br>getFirst(),element(),peek(),peekFirst()<br>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p><p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> l.item;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong><br><strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p><h3 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a><font face="楷体" id="3.4">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从头遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从头遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从尾遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从尾遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="检查链表是否包含某对象的方法："><a href="#检查链表是否包含某对象的方法：" class="headerlink" title="检查链表是否包含某对象的方法："></a><font face="楷体" id="3.5">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a><font face="楷体" id="3.6">删除方法</font></h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E pop() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        if (f &#x3D;&#x3D; null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>removeLast(),pollLast():</strong> 删除尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p><strong>remove(Object o):</strong> 删除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果删除对象为null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从头开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="comment">//找到元素</span></span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从头开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="comment">//找到元素</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p><p>unlink(Node<E> x) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//得到后继节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//得到前驱节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除前驱指针</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;<span class="comment">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;<span class="comment">//将前驱节点的后继节点指向后继节点</span></span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除后继指针</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;<span class="comment">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>remove(int index)</strong>：删除指定位置的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index范围</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//将节点删除</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a><font face="楷体" id="4">LinkedList类常用方法测试</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">package list;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] srgs) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建存放int类型的linkedList</span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;************************** linkedList的基本操作 ************************&#x2F;</span><br><span class="line">        linkedList.addFirst(0); &#x2F;&#x2F; 添加元素到列表开头</span><br><span class="line">        linkedList.add(1); &#x2F;&#x2F; 在列表结尾添加元素</span><br><span class="line">        linkedList.add(2, 2); &#x2F;&#x2F; 在指定位置添加元素</span><br><span class="line">        linkedList.addLast(3); &#x2F;&#x2F; 添加元素到列表结尾</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;LinkedList（直接输出的）: &quot; + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;getFirst()获得第一个元素: &quot; + linkedList.getFirst()); &#x2F;&#x2F; 返回此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;getLast()获得第最后一个元素: &quot; + linkedList.getLast()); &#x2F;&#x2F; 返回此列表的最后一个元素</span><br><span class="line">        System.out.println(&quot;removeFirst()删除第一个元素并返回: &quot; + linkedList.removeFirst()); &#x2F;&#x2F; 移除并返回此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;removeLast()删除最后一个元素并返回: &quot; + linkedList.removeLast()); &#x2F;&#x2F; 移除并返回此列表的最后一个元素</span><br><span class="line">        System.out.println(&quot;After remove:&quot; + linkedList);</span><br><span class="line">        System.out.println(&quot;contains()方法判断列表是否包含1这个元素:&quot; + linkedList.contains(1)); &#x2F;&#x2F; 判断此列表包含指定元素，如果是，则返回true</span><br><span class="line">        System.out.println(&quot;该linkedList的大小 : &quot; + linkedList.size()); &#x2F;&#x2F; 返回此列表的元素个数</span><br><span class="line"></span><br><span class="line">        &#x2F;************************** 位置访问操作 ************************&#x2F;</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.set(1, 3); &#x2F;&#x2F; 将此列表中指定位置的元素替换为指定的元素</span><br><span class="line">        System.out.println(&quot;After set(1, 3):&quot; + linkedList);</span><br><span class="line">        System.out.println(&quot;get(1)获得指定位置（这里为1）的元素: &quot; + linkedList.get(1)); &#x2F;&#x2F; 返回此列表中指定位置处的元素</span><br><span class="line"></span><br><span class="line">        &#x2F;************************** Search操作 ************************&#x2F;</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.add(3);</span><br><span class="line">        System.out.println(&quot;indexOf(3): &quot; + linkedList.indexOf(3)); &#x2F;&#x2F; 返回此列表中首次出现的指定元素的索引</span><br><span class="line">        System.out.println(&quot;lastIndexOf(3): &quot; + linkedList.lastIndexOf(3));&#x2F;&#x2F; 返回此列表中最后出现的指定元素的索引</span><br><span class="line"></span><br><span class="line">        &#x2F;************************** Queue操作 ************************&#x2F;</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;peek(): &quot; + linkedList.peek()); &#x2F;&#x2F; 获取但不移除此列表的头</span><br><span class="line">        System.out.println(&quot;element(): &quot; + linkedList.element()); &#x2F;&#x2F; 获取但不移除此列表的头</span><br><span class="line">        linkedList.poll(); &#x2F;&#x2F; 获取并移除此列表的头</span><br><span class="line">        System.out.println(&quot;After poll():&quot; + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(&quot;After remove():&quot; + linkedList); &#x2F;&#x2F; 获取并移除此列表的头</span><br><span class="line">        linkedList.offer(4);</span><br><span class="line">        System.out.println(&quot;After offer(4):&quot; + linkedList); &#x2F;&#x2F; 将指定元素添加到此列表的末尾</span><br><span class="line"></span><br><span class="line">        &#x2F;************************** Deque操作 ************************&#x2F;</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.offerFirst(2); &#x2F;&#x2F; 在此列表的开头插入指定的元素</span><br><span class="line">        System.out.println(&quot;After offerFirst(2):&quot; + linkedList);</span><br><span class="line">        linkedList.offerLast(5); &#x2F;&#x2F; 在此列表末尾插入指定的元素</span><br><span class="line">        System.out.println(&quot;After offerLast(5):&quot; + linkedList);</span><br><span class="line">        System.out.println(&quot;peekFirst(): &quot; + linkedList.peekFirst()); &#x2F;&#x2F; 获取但不移除此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;peekLast(): &quot; + linkedList.peekLast()); &#x2F;&#x2F; 获取但不移除此列表的第一个元素</span><br><span class="line">        linkedList.pollFirst(); &#x2F;&#x2F; 获取并移除此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;After pollFirst():&quot; + linkedList);</span><br><span class="line">        linkedList.pollLast(); &#x2F;&#x2F; 获取并移除此列表的最后一个元素</span><br><span class="line">        System.out.println(&quot;After pollLast():&quot; + linkedList);</span><br><span class="line">        linkedList.push(2); &#x2F;&#x2F; 将元素推入此列表所表示的堆栈（插入到列表的头）</span><br><span class="line">        System.out.println(&quot;After push(2):&quot; + linkedList);</span><br><span class="line">        linkedList.pop(); &#x2F;&#x2F; 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span><br><span class="line">        System.out.println(&quot;After pop():&quot; + linkedList);</span><br><span class="line">        linkedList.add(3);</span><br><span class="line">        linkedList.removeFirstOccurrence(3); &#x2F;&#x2F; 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span><br><span class="line">        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(3); &#x2F;&#x2F; 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）</span><br><span class="line">        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);</span><br><span class="line"></span><br><span class="line">        &#x2F;************************** 遍历操作 ************************&#x2F;</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 迭代器遍历</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator &#x3D; linkedList.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Iterator：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 顺序遍历(随机遍历)</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;for：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 另一种for循环遍历</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;for2：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过pollFirst()或pollLast()来遍历LinkedList</span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        while (temp1.size() !&#x3D; 0) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;pollFirst()或pollLast()：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过removeFirst()或removeLast()来遍历LinkedList</span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        while (temp2.size() !&#x3D; 0) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;removeFirst()或removeLast()：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>HashMap源码分析</title>
        <link href="/2021/08/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
        <url>/2021/08/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>HashMap源码分析</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p class='p small'>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p class='p small'>HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p class='p small'>HashMap默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， HashMap 总是使用 2 的幂作为哈希表的大小。</p><br/><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><br/><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F;默认初始化大小 16 </span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;     &#x2F;&#x2F;负载因子0.75</span><br><span class="line">static final Entry&lt;?,?&gt;[] EMPTY_TABLE &#x3D; &#123;&#125;;         &#x2F;&#x2F;初始化的默认数组</span><br><span class="line">transient int size;     &#x2F;&#x2F;HashMap中元素的数量</span><br><span class="line">int threshold;          &#x2F;&#x2F;判断是否需要调整HashMap的容量</span><br></pre></td></tr></table></figure><br/><h3 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p class='p small'>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全。</p><p class='p small'>Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合。</p><p class='p small'>Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</p><br/><h4 id="针对null的不同"><a href="#针对null的不同" class="headerlink" title="针对null的不同"></a>针对null的不同</h4><p class='p small'>HashMap可以使用null作为key，而Hashtable则不允许null作为key</p><p class='p small'>虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事。</p><p class='p small'>HashMap以null作为key时，总是存储在table数组的第一个节点上。</p><br/><h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><p class='p small'>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。</p><br/><h4 id="初始容量与扩容"><a href="#初始容量与扩容" class="headerlink" title="初始容量与扩容"></a>初始容量与扩容</h4><p class='p small'>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p><p class='p small'>HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1。</p><br/><h4 id="两者计算hash的方法不同"><a href="#两者计算hash的方法不同" class="headerlink" title="两者计算hash的方法不同"></a>两者计算hash的方法不同</h4><p class='p small'>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash &#x3D; key.hashCode();</span><br><span class="line">int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure><p class='p small'>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int hash &#x3D; hash(key.hashCode());</span><br><span class="line">int i &#x3D; indexFor(hash, table.length);</span><br><span class="line"> </span><br><span class="line">static int hash(int h) &#123;</span><br><span class="line">        &#x2F;&#x2F; This function ensures that hashCodes that differ only by</span><br><span class="line">        &#x2F;&#x2F; constant multiples at each bit position have a bounded</span><br><span class="line">        &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).</span><br><span class="line">        h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br></pre></td></tr></table></figure><br/><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p><strong><p class='p small'>JDK1.8 之前 HashMap 底层是数组和链表结合在一起使用也就是链表散列。</p></strong></p><p class='p small'>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突</p><p class='p small'>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞</p><p><strong><p class='p small'>JDK 1.8 HashMap 的 hash 方法源码:</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">      int h;</span><br><span class="line">      &#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode</span><br><span class="line">      &#x2F;&#x2F; ^ ：按位异或</span><br><span class="line">      &#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">      return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int hash(int h) &#123;</span><br><span class="line">    &#x2F;&#x2F; This function ensures that hashCodes that differ only by</span><br><span class="line">    &#x2F;&#x2F; constant multiples at each bit position have a bounded</span><br><span class="line">    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).</span><br><span class="line"></span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次</p><p class='p small'>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/HashMap/hashmap-%E6%8B%89%E9%93%BE%E6%B3%95.png" alt=""></p><br/><h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p class='p small'>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p><p class='p small'>当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin() 方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize()方法对数组扩容。相关源码这里就不贴了，重点关注 treeifyBin()方法即可！</p><p><img src= "/img/loading.gif" data-src="https://oscimg.oschina.net/oscnet/up-bba283228693dae74e78da1ef7a9a04c684.png" alt=""></p><p><strong>类的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>loadFactor 加载因子</p></strong></p><p class='p small'>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong><p class='p small'>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</p></strong>。</p><p class='p small'>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 \* 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能</p><p><strong><p class='p small'>threshold</p></strong></p><p><strong><p class='p small'>threshold = capacity \* loadFactor，当 Size>=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准</p></strong></p><p><strong><p class='p small'>Node 节点类源码:</p></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>树节点类源码:</p></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><br/><h3 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p class='p small'>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认构造函数。</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all   other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 包含另一个“Map”的构造函数</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">putMapEntries(m, false);&#x2F;&#x2F;下面会分析到这个方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定“容量大小”的构造函数</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">if (initialCapacity &lt; 0)</span><br><span class="line">throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>putMapEntries 方法：</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    int s &#x3D; m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断table是否已经初始化</span><br><span class="line">        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size</span><br><span class="line">            &#x2F;&#x2F; 未初始化，s为m的实际元素个数</span><br><span class="line">            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;</span><br><span class="line">            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            &#x2F;&#x2F; 计算得到的t大于阈值，则初始化阈值</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold &#x3D; tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        &#x2F;&#x2F; 将m中的所有元素添加至HashMap中</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key &#x3D; e.getKey();</span><br><span class="line">            V value &#x3D; e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p class='p small'>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><strong><p class='p small'>对 putVal 方法添加元素的分析如下：</p></strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E5%9F%BA%E7%A1%80/HashMap/put%E6%96%B9%E6%B3%95.png" alt=""></p><p class='p small'>说明:上图有两个小问题：</p><ul><li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a href="https://github.com/Snailclimb/JavaGuide/issues/608" target="_blank" rel="noopener">issue#608</a>）。</li><li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a href="https://github.com/Snailclimb/JavaGuide/issues/1087" target="_blank" rel="noopener">issue#1087</a>）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F; table未初始化或者长度为0，进行扩容</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    &#x2F;&#x2F; 桶中已经存在元素</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F; 将第一个元素赋值给e，用e来记录</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; hash值不相等，即key不相等；为红黑树结点</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            &#x2F;&#x2F; 放入树中</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        &#x2F;&#x2F; 为链表结点</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 在链表最末插入结点</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 到达链表的尾部</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 在尾部插入新结点</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br><span class="line">                    &#x2F;&#x2F; 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br><span class="line">                    &#x2F;&#x2F; 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    &#x2F;&#x2F; 跳出循环</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    &#x2F;&#x2F; 相等，跳出循环</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 用于遍历桶中的链表，与前面的e &#x3D; p.next组合，可以遍历链表</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 表示在桶中找到key值、hash值与插入元素相等的结点</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 记录e的value</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            &#x2F;&#x2F; onlyIfAbsent为false或者旧值为null</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                &#x2F;&#x2F;用新值替换旧值</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            &#x2F;&#x2F; 访问后回调</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            &#x2F;&#x2F; 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 结构性修改</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 实际大小大于阈值则扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    &#x2F;&#x2F; 插入后回调</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>我们再来对比一下 JDK1.7 put 方法的代码</p></strong></p><p><strong><p class='p small'>对于 put 方法的分析如下：</p></strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value)</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 先遍历</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  &#x2F;&#x2F; 再插入</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 数组元素相等</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        &#x2F;&#x2F; 桶中不止一个节点</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 在树中get</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            &#x2F;&#x2F; 在链表中get</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h4><p class='p small'>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算新的resize上限</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 把每个bucket都移动到新的buckets中</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        &#x2F;&#x2F; 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    &#x2F;&#x2F; 原索引放到bucket里</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 原索引+oldCap放到bucket里</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h4><p class='p small'>判断hashmap中是否有key指向该value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">                    if ((v &#x3D; e.value) &#x3D;&#x3D; value ||</span><br><span class="line">                        (value !&#x3D; null &amp;&amp; value.equals(v)))</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h4><p class='p small'>判断hashmap中是否存在该key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return getNode(hash(key), key) !&#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><p>遍历将hashmap清空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">            size &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><h3 id="HashMap-常用方法测试"><a href="#HashMap-常用方法测试" class="headerlink" title="HashMap 常用方法测试"></a>HashMap 常用方法测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class HashMapDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">        &#x2F;&#x2F; 键不能重复，值可以重复</span><br><span class="line">        map.put(&quot;san&quot;, &quot;张三&quot;);</span><br><span class="line">        map.put(&quot;si&quot;, &quot;李四&quot;);</span><br><span class="line">        map.put(&quot;wu&quot;, &quot;王五&quot;);</span><br><span class="line">        map.put(&quot;wang&quot;, &quot;老王&quot;);</span><br><span class="line">        map.put(&quot;wang&quot;, &quot;老王2&quot;);&#x2F;&#x2F; 老王被覆盖</span><br><span class="line">        map.put(&quot;lao&quot;, &quot;老王&quot;);</span><br><span class="line">        System.out.println(&quot;-------直接输出hashmap:-------&quot;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 遍历HashMap</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 1.获取Map中的所有键</span><br><span class="line">        System.out.println(&quot;-------foreach获取Map中所有的键:------&quot;);</span><br><span class="line">        Set&lt;String&gt; keys &#x3D; map.keySet();</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();&#x2F;&#x2F;换行</span><br><span class="line">        &#x2F;&#x2F; 2.获取Map中所有值</span><br><span class="line">        System.out.println(&quot;-------foreach获取Map中所有的值:------&quot;);</span><br><span class="line">        Collection&lt;String&gt; values &#x3D; map.values();</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            System.out.print(value+&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();&#x2F;&#x2F;换行</span><br><span class="line">        &#x2F;&#x2F; 3.得到key的值的同时得到key所对应的值</span><br><span class="line">        System.out.println(&quot;-------得到key的值的同时得到key所对应的值:-------&quot;);</span><br><span class="line">        Set&lt;String&gt; keys2 &#x3D; map.keySet();</span><br><span class="line">        for (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + &quot;：&quot; + map.get(key)+&quot;   &quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span><br><span class="line">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 当我调用put(key,value)方法的时候，首先会把key和value封装到</span><br><span class="line">        &#x2F;&#x2F; Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span><br><span class="line">        &#x2F;&#x2F; map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span><br><span class="line">        &#x2F;&#x2F; 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys &#x3D; map.entrySet();</span><br><span class="line">        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * HashMap其他常用方法</span><br><span class="line">         *&#x2F;</span><br><span class="line">        System.out.println(&quot;after map.size()：&quot;+map.size());</span><br><span class="line">        System.out.println(&quot;after map.isEmpty()：&quot;+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(&quot;san&quot;));</span><br><span class="line">        System.out.println(&quot;after map.remove()：&quot;+map);</span><br><span class="line">        System.out.println(&quot;after map.get(si)：&quot;+map.get(&quot;si&quot;));</span><br><span class="line">        System.out.println(&quot;after map.containsKey(si)：&quot;+map.containsKey(&quot;si&quot;));</span><br><span class="line">        System.out.println(&quot;after containsValue(李四)：&quot;+map.containsValue(&quot;李四&quot;));</span><br><span class="line">        System.out.println(map.replace(&quot;si&quot;, &quot;李四2&quot;));</span><br><span class="line">        System.out.println(&quot;after map.replace(si, 李四2):&quot;+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>ArrayList源码+扩容机制分析</title>
        <link href="/2021/08/24/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
        <url>/2021/08/24/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>ArrayList源码+扩容机制分析</p><h2 id="1-ArrayList-简介"><a href="#1-ArrayList-简介" class="headerlink" title="1. ArrayList 简介"></a>1. ArrayList 简介</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul><h3 id="1-1-Arraylist-和-Vector-的区别"><a href="#1-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.1. Arraylist 和 Vector 的区别?"></a>1.1. Arraylist 和 Vector 的区别?</h3><ol><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。</li></ol><h3 id="1-2-Arraylist-与-LinkedList-区别"><a href="#1-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2. Arraylist 与 LinkedList 区别?"></a>1.2. Arraylist 与 LinkedList 区别?</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h2 id="2-ArrayList-核心源码解读"><a href="#2-ArrayList-核心源码解读" class="headerlink" title="2. ArrayList 核心源码解读"></a>2. ArrayList 核心源码解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //将原来不是<span class="title">Object</span>类型的<span class="title">elementData</span>数组的内容，赋值给新的<span class="title">Object</span>类型的<span class="title">elementData</span>数组</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-ArrayList-扩容机制分析"><a href="#3-ArrayList-扩容机制分析" class="headerlink" title="3. ArrayList 扩容机制分析"></a>3. ArrayList 扩容机制分析</h2><h3 id="3-1-先从-ArrayList-的构造函数说起"><a href="#3-1-先从-ArrayList-的构造函数说起" class="headerlink" title="3.1. 先从 ArrayList 的构造函数说起"></a>3.1. 先从 ArrayList 的构造函数说起</h3><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">             <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><blockquote><p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p></blockquote><h3 id="3-2-一步一步分析-ArrayList-扩容机制"><a href="#3-2-一步一步分析-ArrayList-扩容机制" class="headerlink" title="3.2. 一步一步分析 ArrayList 扩容机制"></a>3.2. 一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h4 id="3-2-1-先来看-add-方法"><a href="#3-2-1-先来看-add-方法" class="headerlink" title="3.2.1. 先来看 add 方法"></a>3.2.1. 先来看 <code>add</code> 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="3-2-2-再来看看-ensureCapacityInternal-方法"><a href="#3-2-2-再来看看-ensureCapacityInternal-方法" class="headerlink" title="3.2.2. 再来看看 ensureCapacityInternal() 方法"></a>3.2.2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h4><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><blockquote><p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p></blockquote><h4 id="3-2-3-ensureExplicitCapacity-方法"><a href="#3-2-3-ensureExplicitCapacity-方法" class="headerlink" title="3.2.3. ensureExplicitCapacity() 方法"></a>3.2.3. <code>ensureExplicitCapacity()</code> 方法</h4><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="3-2-4-grow-方法"><a href="#3-2-4-grow-方法" class="headerlink" title="3.2.4. grow() 方法"></a>3.2.4. <code>grow()</code> 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="3-2-5-hugeCapacity-方法。"><a href="#3-2-5-hugeCapacity-方法。" class="headerlink" title="3.2.5. hugeCapacity() 方法。"></a>3.2.5. <code>hugeCapacity()</code> 方法。</h4><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-System-arraycopy-和-Arrays-copyOf-方法"><a href="#3-3-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="3.3. System.arraycopy() 和 Arrays.copyOf()方法"></a>3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h4 id="3-3-1-System-arraycopy-方法"><a href="#3-3-1-System-arraycopy-方法" class="headerlink" title="3.3.1. System.arraycopy() 方法"></a>3.3.1. <code>System.arraycopy()</code> 方法</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写一个简单的方法测试以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure><h4 id="3-3-2-Arrays-copyOf-方法"><a href="#3-3-2-Arrays-copyOf-方法" class="headerlink" title="3.3.2. Arrays.copyOf()方法"></a>3.3.2. <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">   <span class="comment">// 申请一个新的数组</span></span><br><span class="line">       <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">       System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">       <span class="keyword">return</span> copy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">"b.length"</span>+b.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="3-3-3-两者联系和区别"><a href="#3-3-3-两者联系和区别" class="headerlink" title="3.3.3. 两者联系和区别"></a>3.3.3. 两者联系和区别</h4><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h3 id="3-4-ensureCapacity方法"><a href="#3-4-ensureCapacity方法" class="headerlink" title="3.4. ensureCapacity方法"></a>3.4. <code>ensureCapacity</code>方法</h3><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"使用ensureCapacity方法前："</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：2158</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用ensureCapacity方法后："</span>+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法后：1773</span><br></pre></td></tr></table></figure><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Gitlab搭建</title>
        <link href="/2021/08/19/Gitlab%E6%90%AD%E5%BB%BA/"/>
        <url>/2021/08/19/Gitlab%E6%90%AD%E5%BB%BA/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Gitlab环境搭建</p><h3 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h3><p class='p small'>准备一个系统为 CentOS7 以上版本的服务器，要求内存 4G，磁盘 50G。关闭防火墙，并且配置好主机名和 IP，保证服务器可以上网，此教程使用虚拟机。</p><br/><h3 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h3><p class='p small'>Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把 所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。</p><p>链接：<a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E8%BD%AF%E4%BB%B6/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E8%BD%AF%E4%BB%B6/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm</a></p><p class='p small'>注：直接将此包上传到服务器/opt/module 目录下即可</p><br/><h3 id="编写安装脚本"><a href="#编写安装脚本" class="headerlink" title="编写安装脚本"></a>编写安装脚本</h3><p class='p small'>安装 gitlab 步骤比较繁琐，因此我们可以参考官网编写 gitlab 的安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh &#x2F;opt&#x2F;module&#x2F;gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm</span><br><span class="line">sudo yum install -y curl policycoreutils-python openssh-server cronie</span><br><span class="line">sudo lokkit -s http -s ssh</span><br><span class="line">sudo yum install -y postfix</span><br><span class="line">sudo service postfix start</span><br><span class="line">sudo chkconfig postfix on</span><br><span class="line">curl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;gitlab&#x2F;gitlabce&#x2F;script.rpm.sh | sudo bash</span><br><span class="line">sudo EXTERNAL_URL&#x3D;&quot;http:&#x2F;&#x2F;gitlab.example.com&quot; yum -y install gitlabce</span><br></pre></td></tr></table></figure><p class='p small'>给脚本增加执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x gitlab-install.sh</span><br></pre></td></tr></table></figure><p class='p small'>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;gitlab-install.sh</span><br></pre></td></tr></table></figure><br/><h3 id="初始化-GitLab-服务"><a href="#初始化-GitLab-服务" class="headerlink" title="初始化 GitLab 服务"></a>初始化 GitLab 服务</h3><p class='p small'>执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><br/><h3 id="启动-GitLab-服务"><a href="#启动-GitLab-服务" class="headerlink" title="启动 GitLab 服务"></a>启动 GitLab 服务</h3><p class='p small'>启动 GitLab 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><p class='p small'>启动完毕后打开浏览器访问你服务器的ip就可以看到gitlab的初始化页面啦，gitlab默认端口为80</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Linux</tag>

        </tags>

    </entry>


    <entry>
        <title>Ribbon负载均衡服务调用</title>
        <link href="/2021/08/06/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
        <url>/2021/08/06/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Ribbon负载均衡服务调用</p><h3 id="Ribbon介绍"><a href="#Ribbon介绍" class="headerlink" title="Ribbon介绍"></a>Ribbon介绍</h3><p><strong><p class='p small'>1、Ribbon是什么？</p></strong></p><p class='p small'>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。</p><p class='p small'>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><p><strong><p class='p small'>2、Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别？</p></strong></p><p class='p small'>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。</p><p class='p small'>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p><p> <strong><p class='p small'>3、集中式LB</p></strong></p><p class='p small'>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5</p><p><strong><p class='p small'>4、进程内LB</p></strong></p><p class='p small'>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p><p class='p small'>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p><br/><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Ribbon/ribbon%E6%9E%B6%E6%9E%84.png" alt=""></p><p class='p small'>Ribbon在工作时分成两步</p><p class='p small'>第一步先选择 EurekaServer</p><p class='p small'>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址</p><p class='p small'>其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权</p> <p class='p small'>总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例</p> <br/><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><h3 id="新建一个maven的聚合工程"><a href="#新建一个maven的聚合工程" class="headerlink" title="新建一个maven的聚合工程"></a>新建一个maven的聚合工程</h3><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud</tag>

        </tags>

    </entry>


    <entry>
        <title>Nacos集群配置（Linux）</title>
        <link href="/2021/08/05/Nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%EF%BC%88Linux%EF%BC%89/"/>
        <url>/2021/08/05/Nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%EF%BC%88Linux%EF%BC%89/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Nacos集群配置（Linux）</p><p class='p small'>环境前提：centos7，jdk8，nginx，mysql5.7+</p><p>mysql未安装的可以看我mysql安装的教程（nginx同理）</p><p class='p small'>nacos下载地址：https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos-server-1.1.4.tar.gz</p><h3 id="nacos安装"><a href="#nacos安装" class="headerlink" title="nacos安装"></a>nacos安装</h3><p class='p small'>1、搭建架构图</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos-cluster.png" alt=""></p><p class='p small'>2、将下载好的nacos-server-1.1.4.tar.gz使用rz命令放在/opt目录下</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/%E4%B8%8A%E4%BC%A0nacos%E5%8C%85.png" alt=""></p><p class='p small'>3、使用命令解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nacos-server-1.1.4.tar.gz</span><br></pre></td></tr></table></figure><p class='p small'>4、执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r nacos &#x2F;mynacos</span><br></pre></td></tr></table></figure><br/><h3 id="nacos持久化"><a href="#nacos持久化" class="headerlink" title="nacos持久化"></a>nacos持久化</h3><p class='p small'>1、找到nacos-mysql.sql脚本的位置</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E6%8C%81%E4%B9%85%E5%8C%96.png" alt=""></p><p class='p small'>2、将sql脚本在mysql中执行</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/mysql.png" alt=""></p><p class='p small'>3、修改nacos的application.properties配置文件</p><p><strong><p class='p small'>修改前我们先备份</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp application.properties application.bk.properties</span><br></pre></td></tr></table></figure><p class='p small'>打开application.properties配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim application.properties</span><br></pre></td></tr></table></figure><p class='p small'>在配置文件最后添加新的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"> </span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;root</span><br><span class="line">db.password&#x3D;123456</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE.png" alt=""></p><br/><h3 id="nacos的集群配置"><a href="#nacos的集群配置" class="headerlink" title="nacos的集群配置"></a>nacos的集群配置</h3><p class='p small'>1、在conf目录下找到cluster.conf.example，并复制一个出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp cluster.conf.examplecp cluster.conf</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE01.png" alt=""></p><p class='p small'>2、vim打开cluster.conf文件，并新增以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#配置你自己的ip，后面的端口号表示你集群的端口号</span><br><span class="line">192.168.186.128:3333</span><br><span class="line">192.168.186.128:4444</span><br><span class="line">192.168.186.128:5555</span><br></pre></td></tr></table></figure><br/><h3 id="编辑Nacos的启动脚本"><a href="#编辑Nacos的启动脚本" class="headerlink" title="编辑Nacos的启动脚本"></a>编辑Nacos的启动脚本</h3><p class='p small'>1、找到/mynaocs/bin目录下的startup.sh启动脚本</p><p><strong><p class='p small'>并备份一个脚本（以免操作不当，无法恢复脚本！！！！！）</p></strong></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE02.png" alt=""></p><p class='p small'>2、vim打开startup.sh脚本，并按照下列图片进行修改，注意缩进</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE03.png" alt=""></p><p class='p small'>3、修改完成后，启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;startup.sh -p 3333</span><br><span class="line">.&#x2F;startup.sh -p 4444</span><br><span class="line">.&#x2F;startup.sh -p 5555</span><br></pre></td></tr></table></figure><p class='p small'>查看是否集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep nacos   #查看进程</span><br><span class="line">ps -ef |grep nacos|grep -v grep| wc -l   #查看集群数量</span><br></pre></td></tr></table></figure><br/><h3 id="Nginx的配置，由它作为负载均衡器"><a href="#Nginx的配置，由它作为负载均衡器" class="headerlink" title="Nginx的配置，由它作为负载均衡器"></a>Nginx的配置，由它作为负载均衡器</h3><p class='p small'>1、进入到nginx目录下，复制出一个nginx.conf的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp nginx.conf nacos-nginx.conf</span><br></pre></td></tr></table></figure><p class='p small'>2、修改刚刚复制的nacos-nginx.conf配置文件</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE04.png" alt=""></p><p class='p small'>3、配置完成后进入到nginx的sbin目录下根据配置文件启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nacos-nginx.conf</span><br></pre></td></tr></table></figure><p class='p small'>4、访问192.168.186.128:8888/nacos</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/nacos/nacos%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE05.png" alt=""></p><p class='p small'>看到我们nacos的页面出来了，至此我们nacos的集群也就配置完成了！</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud</tag>

        </tags>

    </entry>


    <entry>
        <title>Centos7环境下安装Mysql8详细教程</title>
        <link href="/2021/08/04/Centos7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Mysql8%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
        <url>
            /2021/08/04/Centos7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Mysql8%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/
        </url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Centos7环境下安装Mysql8详细教程(超详细，亲测百分百成功)</p><h3 id="1、上传或者下载mysql安装包"><a href="#1、上传或者下载mysql安装包" class="headerlink" title="1、上传或者下载mysql安装包"></a>1、上传或者下载mysql安装包</h3><p class='p small'>推荐使用清华的镜像，下载速度非常的快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;mysql&#x2F;downloads&#x2F;MySQL-8.0&#x2F;mysql-8.0.21-el7-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E4%B8%8B%E8%BD%BD.png" alt=""></p><p class='p small'>当然，如果没有我也提供了下载包</p><p class='p small'>链接：https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E8%BD%AF%E4%BB%B6/mysql-8.0.21-el7-x86_64.tar.gz} {% p small</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E4%B8%8A%E4%BC%A0.png" alt=""></p><br/><h3 id="2、检查是否安装过mysql"><a href="#2、检查是否安装过mysql" class="headerlink" title="2、检查是否安装过mysql"></a>2、检查是否安装过mysql</h3><span class='p small red'>ps:因为以前用yum安装过，所以先用yum卸载。如果不是此方式或者没安装过则跳过</span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove mysql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%8D%B8%E8%BD%BDmysql.png" alt=""></p><p class='p small'>查看是否有mysql依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8mysql%E4%BE%9D%E8%B5%96.png" alt=""></p><p class='p small'>如果有则卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通删除模式</span><br><span class="line">rpm -e xxx(mysql_libs)</span><br><span class="line">&#x2F;&#x2F;强力删除模式,如果上述命令删除时，提示有依赖其他文件，则可以用该命令对其进行强力删除</span><br><span class="line">rpm -e --nodeps xxx(mysql_libs)</span><br></pre></td></tr></table></figure><br/><h3 id="3、检查是否有mariadb"><a href="#3、检查是否有mariadb" class="headerlink" title="3、检查是否有mariadb"></a>3、检查是否有mariadb</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89mariadb.png" alt=""></p><p class='p small'>如果有则卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-libs</span><br><span class="line">rpm -e --nodeps mariadb-devel-5.5.65-1.el7.x86_64</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%8D%B8%E8%BD%BDmariadb.png" alt=""></p><br/><h3 id="4、安装mysql依赖包"><a href="#4、安装mysql依赖包" class="headerlink" title="4、安装mysql依赖包"></a>4、安装mysql依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libaio</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%AE%89%E8%A3%85mysql%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85.png" alt=""></p><br/><h3 id="5、解压"><a href="#5、解压" class="headerlink" title="5、解压"></a>5、解压</h3><p>进入/opt目录下将mysql文件解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;opt</span><br><span class="line">tar -zxvf mysql-8.0.21-el7-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E8%A7%A3%E5%8E%8BMySQL.png" alt=""></p><p>我们查看一下是否解压好了</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E8%A7%A3%E5%8E%8B%E5%AE%8C%E6%88%90.png" alt=""></p><br/><h3 id="6、更名并移动"><a href="#6、更名并移动" class="headerlink" title="6、更名并移动"></a>6、更名并移动</h3><p>为了方便操作以及配置文件的更改我们将文件名重命名为mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql-8.0.21-el7-x86_64 mysql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9B%B4%E6%94%B9mysql%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0.png" alt=""></p><p>按照习惯，我们将文件移动到/usr/local目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;opt&#x2F;mysql&#x2F; &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure><p>我们切换到usr/local/目录下查看mysql是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8mysql.png" alt=""></p><p>创建数据库文件存放的文件夹。这个文件夹将来存放每个数据库的库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd mysql</span><br><span class="line">mkdir mysqldb</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%88%9B%E5%BB%BAmysql%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt=""></p><br/><h3 id="7、mysql安装目录赋予权限"><a href="#7、mysql安装目录赋予权限" class="headerlink" title="7、mysql安装目录赋予权限"></a>7、mysql安装目录赋予权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E8%B5%8B%E4%BA%88mysql%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90.png" alt=""></p><br/><h3 id="8、创建mysql组和用户"><a href="#8、创建mysql组和用户" class="headerlink" title="8、创建mysql组和用户"></a>8、创建mysql组和用户</h3><p>创建组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br></pre></td></tr></table></figure><p>创建用户(-s /bin/false参数指定mysql用户仅拥有所有权，而没有登录权限)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -r -g mysql -s &#x2F;bin&#x2F;false mysql</span><br></pre></td></tr></table></figure><p>将用户添加到组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql .&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%B0%86mysql%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%BB%84%E4%B8%AD.png" alt=""></p><br/><h3 id="9、修改mysql配置文件"><a href="#9、修改mysql配置文件" class="headerlink" title="9、修改mysql配置文件"></a>9、修改mysql配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;my.cnf</span><br></pre></td></tr></table></figure><p>将里面的命令都删除掉，然后添加以下命令，保存并退出(如果有一定经验，可以在里面添加一些其他的配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port&#x3D;3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysqldb</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections&#x3D;10000</span><br><span class="line"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span><br><span class="line">max_connect_errors&#x3D;10</span><br><span class="line"># 服务端使用的字符集默认为UTF8</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line"># 默认使用“mysql_native_password”插件认证</span><br><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[client]</span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line">port&#x3D;3306</span><br><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt=""></p><br/><h3 id="10、安装mysql"><a href="#10、安装mysql" class="headerlink" title="10、安装mysql"></a>10、安装mysql</h3><p>进入mysql 安装目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure><p>安装mysql，并记住初始化随机密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;mysqld --initialize --console</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%86%E7%A0%81.png" alt=""></p><br/><h3 id="11、启动mysql服务"><a href="#11、启动mysql服务" class="headerlink" title="11、启动mysql服务"></a>11、启动mysql服务</h3><p>进入mysql.server服务目录下并启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files</span><br><span class="line">.&#x2F;mysql.server start</span><br></pre></td></tr></table></figure><p>如果第一次启动，当初始化执行会有报错</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%90%AF%E5%8A%A8mysql%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8A%A5%E9%94%99.png" alt=""></p><p>此时不要担心，重新给mysql安装目录赋予一下权限后，再次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">.&#x2F;mysql.server start</span><br></pre></td></tr></table></figure><br/><h3 id="12、将mysql添加到系统进程中"><a href="#12、将mysql添加到系统进程中" class="headerlink" title="12、将mysql添加到系统进程中"></a>12、将mysql添加到系统进程中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br></pre></td></tr></table></figure><p>此时我们就可以使用服务进程操作mysql了</p><br/><h3 id="13、设置mysql自启动"><a href="#13、设置mysql自启动" class="headerlink" title="13、设置mysql自启动"></a>13、设置mysql自启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/mysql%E8%87%AA%E5%90%AF%E5%8A%A8.png" alt=""></p><p>此时mysql自启动就已经设置好了</p><br/><h3 id="14、修改root用户登录密码"><a href="#14、修改root用户登录密码" class="headerlink" title="14、修改root用户登录密码"></a>14、修改root用户登录密码</h3><p>登录mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;</span><br><span class="line">.&#x2F;mysql -u root -p</span><br></pre></td></tr></table></figure><p>执行后，输入我们初始化时记录下的随机密码，就会进入mysql</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95mysql.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;1234&#39;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E8%AE%BE%E7%BD%AEmysql%E7%9A%84%E6%96%B0%E5%AF%86%E7%A0%81.png" alt=""></p><br/><h3 id="15、设置允许远程登录"><a href="#15、设置允许远程登录" class="headerlink" title="15、设置允许远程登录"></a>15、设置允许远程登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br><span class="line">update user set user.Host&#x3D;&#39;%&#39;where user.User&#x3D;&#39;root&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><br/><h3 id="16、重启服务且测试"><a href="#16、重启服务且测试" class="headerlink" title="16、重启服务且测试"></a>16、重启服务且测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysql</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h4 id="1、查看mysql是否启动"><a href="#1、查看mysql是否启动" class="headerlink" title="1、查看mysql是否启动"></a>1、查看mysql是否启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9F%A5%E7%9C%8Bmysql%E6%98%AF%E5%90%A6%E8%87%AA%E5%90%AF%E5%8A%A8.png" alt=""></p><h4 id="2、查看防火墙开放端口"><a href="#2、查看防火墙开放端口" class="headerlink" title="2、查看防火墙开放端口"></a>2、查看防火墙开放端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3.png" alt=""></p><h4 id="3、在防火墙中将3306端口开放"><a href="#3、在防火墙中将3306端口开放" class="headerlink" title="3、在防火墙中将3306端口开放"></a>3、在防火墙中将3306端口开放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">&#x2F;&#x2F;--permanent为永久生效，没有此参数 服务器重启后配置失效</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E5%BC%80%E6%94%BE3306%E7%AB%AF%E5%8F%A3.png" alt=""></p><h4 id="4、在Navicat上测试连接"><a href="#4、在Navicat上测试连接" class="headerlink" title="4、在Navicat上测试连接"></a>4、在Navicat上测试连接</h4><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Mysql/%E6%B5%8B%E8%AF%95%E8%BF%9E%E6%8E%A5.png" alt=""></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Linux</tag>

        </tags>

    </entry>


    <entry>
        <title>OpenFeign的使用</title>
        <link href="/2021/07/31/OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
        <url>/2021/07/31/OpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>OpenFeign使用步骤</p><h3 id="OpenFeign简介"><a href="#OpenFeign简介" class="headerlink" title="OpenFeign简介"></a>OpenFeign简介</h3><span class='p small red'>在我们使用OpenFeign之前，先得了解OpenFeign是什么是什么？</span><p class='p small'>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。 它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡</p><span class='p small red'>Feign能干什么</span><p>Feign旨在使编写Java Http客户端变得更容易。</p><p class='p small'>在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解</p><span class='p small red'>Feign和OpenFeign两者区别</span><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/OpenFeign/OpenFeign%E4%B8%8EFeign%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt=""></p><br/><h3 id="OpenFeign实操开始"><a href="#OpenFeign实操开始" class="headerlink" title="OpenFeign实操开始"></a>OpenFeign实操开始</h3><p class='p small'>1、新建OpenFeign的maven父工程</p><p class='p small'>删除多余的包，只留下pom文件</p><span class='p small red'>ps：不想自己动手的也可以下载博主已经搭建好了的服务：https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/OpenFeign/OpenFeign.zip</span><p class='p small'>导入父工程的pom依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 统一管理jar包版本 --&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;1.2.17&lt;&#x2F;log4j.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;1.16.18&lt;&#x2F;lombok.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version  --&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!--spring boot 2.2.2--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!--spring cloud Hoxton.SR1--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;Hoxton.SR1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p class='p small'>2、新建cloud-eureka-server7001的maven工程（用于eureka服务的注册）</p><p class='p small'>pom：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-server--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--boot web actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--一般通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、建主启动类和application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false     #false表示自己端就是注册中心，职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>4、新建服务提供者cloud-provider-payment8001</p><p class='p small'>pom：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--eureka-client--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>5、新建主启动类和application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      #单机版</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br><span class="line"></span><br><span class="line">  instance:</span><br><span class="line">      instance-id: payment8001</span><br><span class="line">      #访问路径可以显示IP地址</span><br><span class="line">      prefer-ip-address: true</span><br><span class="line">      #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span><br><span class="line">      #lease-renewal-interval-in-seconds: 1</span><br><span class="line">      #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span><br><span class="line">      #lease-expiration-duration-in-seconds: 2</span><br></pre></td></tr></table></figure><p class='p small'>6、新建PaymentController</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xj.openFeign.controller;</span><br><span class="line"></span><br><span class="line">import com.atguigu.springcloud.pojo.CommonResult;</span><br><span class="line">import com.atguigu.springcloud.pojo.Payment;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.cloud.client.ServiceInstance;</span><br><span class="line">import org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class PaymentController</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private String serverPort;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;&quot;)</span><br><span class="line">    public CommonResult&lt;Payment&gt; getPaymentById()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CommonResult(200,&quot;serverPort:  &quot;+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>7、按照cloud-provider-payment8001新建一个cloud-provider-payment8002</p><p class='p small'>8、新建服务消费者cloud-consumer-feign-order80</p><p class='p small'>pom：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--openfeign--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--eureka client--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--web--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>9、建主启动类和application.yml</p><p><strong><span class='p small red'>主启动类上加上@EnableFeignClients注解开启OpenFeign</span></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>10、新建PaymentFeignService（用于调用8001，8002服务）</p><p><strong><span class='p small red'>@FeignClient(value = CLOUD-PAYMENT-SERVICE)指调用哪一个微服务</span></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.xj.openFeign.service;</span><br><span class="line"></span><br><span class="line">import com.atguigu.springcloud.pojo.CommonResult;</span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@FeignClient(value &#x3D; &quot;CLOUD-PAYMENT-SERVICE&quot;)</span><br><span class="line">public interface PaymentFeignService</span><br><span class="line">&#123;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;&quot;)</span><br><span class="line">    public CommonResult getPaymentById();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>11、在80服务中新建OrderFeignController控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.xj.openFeign.controller;</span><br><span class="line"></span><br><span class="line">import com.atguigu.springcloud.pojo.CommonResult;</span><br><span class="line">import com.xj.openFeign.service.PaymentFeignService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderFeignController</span><br><span class="line">&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;consumer&#x2F;payment&quot;)</span><br><span class="line">    public CommonResult getPaymentById()</span><br><span class="line">    &#123;</span><br><span class="line">        return paymentFeignService.getPaymentById();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>12、先启动eureka服务注册中心7001，在启动8001，8002服务提供者，最后启动80服务消费者</p><p class='p small'>使用postman访问127.0.0.1:80/consumer/payment</p><p class='p small'>连续访问我们可以看到返回的端口号一直以轮询的形式展现8001，8002</p><p><strong><span class='p small red'>这是因为Feign自带负载均衡配置项</span></strong></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/OpenFeign/Postman%E8%AE%BF%E9%97%AEOpenFeign%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85.png" alt=""></p><br/><h3 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h3><p class='p small'>1、在8001，8002的控制器中新增以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;feign&#x2F;timeout&quot;)</span><br><span class="line">    public String paymentFeignTimeOut()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;*****paymentFeignTimeOut from port: &quot;+serverPort);</span><br><span class="line">        &#x2F;&#x2F;暂停几秒钟线程</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        return serverPort;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p class='p small'>2、服务消费方80添加超时方法PaymentFeignService</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;feign&#x2F;timeout&quot;)</span><br><span class="line">String paymentFeignTimeOut();</span><br></pre></td></tr></table></figure><p class='p small'>3、服务消费方80添加超时方法OrderFeignController</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;consumer&#x2F;payment&#x2F;feign&#x2F;timeout&quot;)</span><br><span class="line">public String paymentFeignTimeOut()</span><br><span class="line">&#123;</span><br><span class="line">return paymentFeignService.paymentFeignTimeOut();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>4、访问http://localhost/consumer/payment/feign/timeout</p><p><strong><p class='p small'>报错是因为OpenFeign默认等待1秒钟，超过后报错</p></strong></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/OpenFeign/OpenFeign%E8%B6%85%E6%97%B6.png" alt=""></p><p class='p small'>5、修改80服务消费者的yml配置文件，将连接所建立的时间设置为5秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span><br><span class="line">ribbon:</span><br><span class="line">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span><br><span class="line">  ReadTimeout: 5000</span><br><span class="line">#指的是建立连接后从服务器读取到可用资源所用的时间</span><br><span class="line">  ConnectTimeout: 5000</span><br></pre></td></tr></table></figure><p class='p small'>6、再次访问http://localhost/consumer/payment/feign/timeout</p><p class='p small'>可以看到等待3秒后能正常返回端口号</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/OpenFeign/OpenFeign.png" alt=""></p><br/><h3 id="OpenFeign日志打印功能"><a href="#OpenFeign日志打印功能" class="headerlink" title="OpenFeign日志打印功能"></a>OpenFeign日志打印功能</h3><p class='p small'>1、日志打印功能是什么？</p><p class='p small'>Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。说白了就是对Feign接口的调用情况进行监控和输出</p><p class='p small'>2、OpenFeign的日志级别？</p><p><strong><p class='p small'>NONE：默认的，不显示任何日志；</p></strong></p><p><strong><p class='p small'>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</p></strong></p><p><strong><p class='p small'>HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；</p></strong></p><p><strong><p class='p small'>FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。</p></strong></p><p>3、在80服务中新建FeignConfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.xj.openFeign.config;</span><br><span class="line"></span><br><span class="line">import feign.Logger;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FeignConfig</span><br><span class="line">&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    Logger.Level feignLoggerLevel()</span><br><span class="line">    &#123;</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在80服务的配置文件中新增日志配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    # feign日志以什么级别监控哪个接口</span><br><span class="line">    com.atguigu.springcloud.service.PaymentFeignService: debug</span><br></pre></td></tr></table></figure><p>5、重启微服务80，查看日志是否生效</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/OpenFeign/OpenFeign%E6%97%A5%E5%BF%97.png" alt=""></p><p>至此OpenFeign的入门就到此结束了</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud</tag>

        </tags>

    </entry>


    <entry>
        <title>AOP记录日志</title>
        <link href="/2021/07/28/AOP%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/"/>
        <url>/2021/07/28/AOP%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>AOP记录操作日志</p><p class='p small'>使用aop记录日志，使用的是返回后通知。具体的实现如下：</p><p class='p small'>1、新建数据库loginfo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> Navicat Premium Data Transfer</span><br><span class="line"></span><br><span class="line"> Source Server         : 本地</span><br><span class="line"> Source Server Type    : MySQL</span><br><span class="line"> Source Server Version : 80018</span><br><span class="line"> Source Host           : 127.0.0.1:3306</span><br><span class="line"> Source Schema         : 218</span><br><span class="line"></span><br><span class="line"> Target Server Type    : MySQL</span><br><span class="line"> Target Server Version : 80018</span><br><span class="line"> File Encoding         : 65001</span><br><span class="line"></span><br><span class="line"> Date: 28&#x2F;07&#x2F;2021 16:28:36</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS &#x3D; 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for log</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS &#96;log&#96;;</span><br><span class="line">CREATE TABLE &#96;log&#96;  (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;userId&#96; int(11) NULL DEFAULT NULL,</span><br><span class="line">  &#96;userName&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;module&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;method&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;beforeParams&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;operateParams&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;startTime&#96; datetime(0) NULL DEFAULT NULL,</span><br><span class="line">  &#96;endTime&#96; datetime(0) NULL DEFAULT NULL,</span><br><span class="line">  &#96;time&#96; varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;userIp&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;resultStatus&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;resultMsg&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for user</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS &#96;user&#96;;</span><br><span class="line">CREATE TABLE &#96;user&#96;  (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 3 CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS &#x3D; 1;</span><br></pre></td></tr></table></figure><p class='p small'>2、新建logInfo的maven项目并导入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;3.4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.75&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.assertj&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;assertj-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;</span><br><span class="line">org.springframework.boot</span><br><span class="line">&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;</span><br><span class="line">spring-boot-dependencies</span><br><span class="line">&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.7.RELEASE</span><br><span class="line">&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、新建application.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;loginfo?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">    hikari:</span><br><span class="line">      #最小空闲链接数</span><br><span class="line">      minimumIdle: 5</span><br><span class="line">      #最大链接数</span><br><span class="line">      maximumPoolSize: 50</span><br><span class="line">      #最大生命周期</span><br><span class="line">      maxLifetime: 180000</span><br><span class="line">      #最长闲置时间</span><br><span class="line">      idleTimeout: 60000</span><br><span class="line">      #等待连接池的最大毫秒数</span><br><span class="line">      connectionTimeout: 20000</span><br></pre></td></tr></table></figure><p class='p small'>4、新建LoginfoApplication主启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LoginfoApplication &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(LoginfoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>5、新建测试数据的User实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@TableName(value &#x3D; &quot;user&quot;)</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">  @TableId(value &#x3D; &quot;id&quot;, type &#x3D; IdType.NONE)</span><br><span class="line">  private Integer id;</span><br><span class="line"></span><br><span class="line">  @TableField(value &#x3D; &quot;name&quot;, exist &#x3D; true)</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>6、新建Log实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">import lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@TableName(value &#x3D; &quot;log&quot;)</span><br><span class="line">public class Log implements Serializable &#123;</span><br><span class="line">  @TableId(value &#x3D; &quot;id&quot;, type &#x3D; IdType.AUTO)</span><br><span class="line">  private long id;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 用户id *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;userId&quot;, exist &#x3D; true)</span><br><span class="line">  private int userId;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 用户名称 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;userName&quot;, exist &#x3D; true)</span><br><span class="line">  private String userName;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 操作模块 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;module&quot;, exist &#x3D; true)</span><br><span class="line">  private String module;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 操作类型 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;method&quot;, exist &#x3D; true)</span><br><span class="line">  private String method;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 操作前参数 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;beforeParams&quot;, exist &#x3D; true)</span><br><span class="line">  private String beforeParams;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 操作时请求参数 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;operateParams&quot;, exist &#x3D; true)</span><br><span class="line">  private String operateParams;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 开始时间 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;startTime&quot;, exist &#x3D; true)</span><br><span class="line">  private Date startTime;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 结束时间 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;endTime&quot;, exist &#x3D; true)</span><br><span class="line">  private Date endTime;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 共耗时(ms) *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;time&quot;, exist &#x3D; true)</span><br><span class="line">  private String time;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 用户IP *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;userIp&quot;, exist &#x3D; true)</span><br><span class="line">  private String userIp;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 操作状态描述 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;resultStatus&quot;, exist &#x3D; true)</span><br><span class="line">  private int resultStatus;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 操作结果描述 *&#x2F;</span><br><span class="line">  @TableField(value &#x3D; &quot;resultMsg&quot;, exist &#x3D; true)</span><br><span class="line">  private String resultMsg;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>7、新建UserMapper和LogMapper</p><p class='p small'>UserMapper：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.example.demo.entity.User;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface Usermapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>LogMapper：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.example.demo.entity.Log;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface LogMapper extends BaseMapper&lt;Log&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>8、新建UserService和UserServiceImpl</p><p class='p small'>Userservice：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.example.demo.entity.User;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">  public User selectById(int id);</span><br><span class="line"></span><br><span class="line">  public void updateById(User d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>UserServiceImpl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.example.demo.entity.User;</span><br><span class="line">import com.example.demo.mapper.Usermapper;</span><br><span class="line">import com.example.demo.service.UserService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service(&quot;DserviceImpl&quot;)</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">  @Autowired</span><br><span class="line">  Usermapper dmapper;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public User selectById(int id) &#123;</span><br><span class="line">    return dmapper.selectById(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void updateById(User d) &#123;</span><br><span class="line">    dmapper.updateById(d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>9、新建自定义注解SystemControllerLog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SystemControllerLog &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 查询模块 *&#x2F;</span><br><span class="line">  String module() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 查询模块名称 *&#x2F;</span><br><span class="line">  String methods() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 查询的bean名称 *&#x2F;</span><br><span class="line">  String serviceClass() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 查询单个详情的bean的方法 *&#x2F;</span><br><span class="line">  String queryMethod() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 查询详情的参数类型 *&#x2F;</span><br><span class="line">  String parameterType() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 从页面参数中解析出要查询的id， 如域名修改中要从参数中获取customerDomainId的值进行查询 *&#x2F;</span><br><span class="line">  String parameterKey() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 是否为批量类型操作 *&#x2F;</span><br><span class="line">  boolean paramIsArray() default false;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>10、新建工具包R，HttpRequestUtil，SpringContextUtil</p><p class='p small'>R：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.http.HttpStatus;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class R extends HashMap&lt;String, Object&gt; &#123;</span><br><span class="line">  private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">  public R() &#123;</span><br><span class="line">    put(&quot;code&quot;, 0);</span><br><span class="line">    put(&quot;msg&quot;, &quot;success&quot;);</span><br><span class="line">    put(&quot;data&quot;, &quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R error() &#123;</span><br><span class="line">    return R.error(HttpStatus.SC_INTERNAL_SERVER_ERROR, &quot;未知异常，请联系管理员&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R error(String msg) &#123;</span><br><span class="line">    return R.error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R error(int code, String msg) &#123;</span><br><span class="line">    R r &#x3D; new R();</span><br><span class="line">    r.put(&quot;code&quot;, code);</span><br><span class="line">    r.put(&quot;msg&quot;, msg);</span><br><span class="line">    r.put(&quot;data&quot;, &quot;&quot;);</span><br><span class="line">    return r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R error(int code, String msg, Map&lt;Integer, Object&gt; map) &#123;</span><br><span class="line">    R r &#x3D; new R();</span><br><span class="line">    r.put(&quot;code&quot;, code);</span><br><span class="line">    r.put(&quot;msg&quot;, msg);</span><br><span class="line">    r.put(&quot;data&quot;, map);</span><br><span class="line">    return r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R ok(String msg) &#123;</span><br><span class="line">    R r &#x3D; new R();</span><br><span class="line">    r.put(&quot;msg&quot;, msg);</span><br><span class="line">    r.put(&quot;data&quot;, &quot;&quot;);</span><br><span class="line">    return r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R ok(String key, Object value) &#123;</span><br><span class="line">    R r &#x3D; new R();</span><br><span class="line">    Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    r.put(&quot;data&quot;, map);</span><br><span class="line">    return r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R ok() &#123;</span><br><span class="line">    return new R();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static R ok(int code) &#123;</span><br><span class="line">    R r &#x3D; new R();</span><br><span class="line">    r.put(&quot;code&quot;, code);</span><br><span class="line">    return r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public R put(String key, Object value) &#123;</span><br><span class="line">    super.put(key, value);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>HttpRequestUtil：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.http.HttpEntity;</span><br><span class="line">import org.apache.http.client.ClientProtocolException;</span><br><span class="line">import org.apache.http.client.config.RequestConfig;</span><br><span class="line">import org.apache.http.client.methods.*;</span><br><span class="line">import org.apache.http.entity.StringEntity;</span><br><span class="line">import org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line">import org.apache.http.impl.client.HttpClients;</span><br><span class="line">import org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class HttpRequestUtil &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * getIpAddr:(获取ip). &lt;br&#x2F;&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     * @author fenglanglang</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line">        String ipAddress &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ipAddress &#x3D; request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">            if (ipAddress &#x3D;&#x3D; null || ipAddress.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ipAddress &#x3D;&#x3D; null || ipAddress.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ipAddress &#x3D;&#x3D; null || ipAddress.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress &#x3D; request.getRemoteAddr();</span><br><span class="line">                if (ipAddress.equals(&quot;0:0:0:0:0:0:0:1&quot;)) &#123;</span><br><span class="line">                    ipAddress &#x3D; &quot;127.0.0.1&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ipAddress.equals(&quot;127.0.0.1&quot;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 根据网卡取本机配置的IP</span><br><span class="line">                    InetAddress inet &#x3D; InetAddress.getLocalHost();</span><br><span class="line">                    ipAddress &#x3D; inet.getHostAddress();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#39;,&#39;分割</span><br><span class="line">            if (ipAddress !&#x3D; null &amp;&amp; ipAddress.length() &gt; 15) &#123;</span><br><span class="line">                if (ipAddress.indexOf(&quot;,&quot;) &gt; 0) &#123;</span><br><span class="line">                    ipAddress &#x3D; ipAddress.substring(0, ipAddress.indexOf(&quot;,&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ipAddress &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>SpringContextUtil：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;** 获取spring容器，以访问容器中定义的其他bean *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class SpringContextUtil implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">  private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 实现ApplicationContextAware接口的回调方法，设置上下文环境 *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public void setApplicationContext(ApplicationContext applicationContext) &#123;</span><br><span class="line">    SpringContextUtil.applicationContext &#x3D; applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">    return SpringContextUtil.applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 获取对象</span><br><span class="line">   *</span><br><span class="line">   * @return Object 一个以所给名字注册的bean的实例 (service注解方式，自动生成以首字母小写的类名为bean name)</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static Object getBean(String name) throws BeansException &#123;</span><br><span class="line">    return SpringContextUtil.applicationContext.getBean(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>11、新建LogController</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo.entity.User;</span><br><span class="line">import com.example.demo.log.SystemControllerLog;</span><br><span class="line">import com.example.demo.mapper.Usermapper;</span><br><span class="line">import com.example.demo.service.impl.UserServiceImpl;</span><br><span class="line">import com.example.demo.util.R;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class LogController &#123;</span><br><span class="line">  @Autowired private UserServiceImpl dservice;</span><br><span class="line">  @Autowired private Usermapper dmapper;</span><br><span class="line"></span><br><span class="line">  @ResponseBody</span><br><span class="line">  @RequestMapping(</span><br><span class="line">      value &#x3D; &quot;&#x2F;insert&quot;,</span><br><span class="line">      method &#x3D; &#123;RequestMethod.POST&#125;)</span><br><span class="line">  @SystemControllerLog(</span><br><span class="line">      module &#x3D; &quot;日志模块&quot;,</span><br><span class="line">      methods &#x3D; &quot;插入数据&quot;,</span><br><span class="line">      serviceClass &#x3D; &quot;&quot;,</span><br><span class="line">      queryMethod &#x3D; &quot;&quot;,</span><br><span class="line">      parameterType &#x3D; &quot;&quot;,</span><br><span class="line">      parameterKey &#x3D; &quot;&quot;)</span><br><span class="line">  public R insert(@RequestBody User d) &#123;</span><br><span class="line">    dmapper.insert(d);</span><br><span class="line">    return R.ok(200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @ResponseBody</span><br><span class="line">  @RequestMapping(</span><br><span class="line">      value &#x3D; &quot;&#x2F;update&quot;,</span><br><span class="line">      method &#x3D; &#123;RequestMethod.POST&#125;)</span><br><span class="line">  @SystemControllerLog(</span><br><span class="line">      module &#x3D; &quot;日志模块&quot;,</span><br><span class="line">      methods &#x3D; &quot;修改数据&quot;,</span><br><span class="line">      serviceClass &#x3D; &quot;DserviceImpl&quot;,</span><br><span class="line">      queryMethod &#x3D; &quot;selectById&quot;,</span><br><span class="line">      parameterType &#x3D; &quot;int&quot;,</span><br><span class="line">      parameterKey &#x3D; &quot;id&quot;)</span><br><span class="line">  public R update(@RequestBody User d) &#123;</span><br><span class="line">    dservice.updateById(d);</span><br><span class="line">    return R.ok(200);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>12、新建最重要的部分ControllerLogAopAspect类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import com.example.demo.entity.Log;</span><br><span class="line">import com.example.demo.mapper.LogMapper;</span><br><span class="line">import com.example.demo.util.HttpRequestUtil;</span><br><span class="line">import com.example.demo.util.R;</span><br><span class="line">import com.example.demo.util.SpringContextUtil;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.Signature;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 〈一句话功能简述:操作日志切面记录操作〉&lt;br&gt;</span><br><span class="line"> * 〈功能详细描述〉</span><br><span class="line"> *</span><br><span class="line"> * @see [相关类&#x2F;方法]（可选）</span><br><span class="line"> * @since [产品&#x2F;模块版本] （可选）</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class ControllerLogAopAspect &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ControllerLogAopAspect.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注入service,用来将日志信息保存在数据库</span><br><span class="line">    @Autowired</span><br><span class="line">    private LogMapper logservice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unused&quot;&#125;)</span><br><span class="line">    @Order(1)</span><br><span class="line">    &#x2F;&#x2F; 配置接入点,如果不知道怎么配置,可以百度一下规则　</span><br><span class="line">    @Around(&quot;execution(* com.example.demo.controller..*(..))&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; 常见日志实体对象</span><br><span class="line">        Log log &#x3D; new Log();</span><br><span class="line">        &#x2F;&#x2F; 获取登录用户账户</span><br><span class="line">        HttpServletRequest httpRequest &#x3D; ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 方法通知前获取时间,为什么要记录这个时间呢？当然是用来计算模块执行时间的</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        log.setStartTime(new Date());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 拦截的实体类，就是当前正在执行的controller</span><br><span class="line">        Object target &#x3D; proceedingJoinPoint.getTarget();</span><br><span class="line">        &#x2F;&#x2F; 拦截的方法名称。当前正在执行的方法</span><br><span class="line">        String methodName &#x3D; proceedingJoinPoint.getSignature().getName();</span><br><span class="line">        &#x2F;&#x2F; 拦截的方法参数</span><br><span class="line">        Object[] args &#x3D; proceedingJoinPoint.getArgs();</span><br><span class="line">        JSONArray operateParamArray &#x3D; new JSONArray();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            Object paramsObj &#x3D; JSON.toJSONString(args[i]);</span><br><span class="line">            &#x2F;&#x2F; 通过该方法可查询对应的object属于什么类型：String type &#x3D; paramsObj.getClass().getName();</span><br><span class="line">            if (paramsObj instanceof String || paramsObj instanceof JSONObject) &#123;</span><br><span class="line">                String str &#x3D; (String) paramsObj;</span><br><span class="line">                &#x2F;&#x2F; 将其转为jsonobject</span><br><span class="line">                JSONObject dataJson &#x3D; JSONObject.parseObject(str);</span><br><span class="line">                if (dataJson &#x3D;&#x3D; null || dataJson.isEmpty() || &quot;null&quot;.equals(dataJson)) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    operateParamArray.add(dataJson);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (paramsObj instanceof Map) &#123;</span><br><span class="line">                &#x2F;&#x2F; get请求，以map类型传参</span><br><span class="line">                Map&lt;String, Object&gt; map &#x3D; (Map&lt;String, Object&gt;) paramsObj;</span><br><span class="line">                JSONObject json &#x3D; new JSONObject(map);</span><br><span class="line">                operateParamArray.add(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 拦截的参数类型</span><br><span class="line">        Signature sig &#x3D; proceedingJoinPoint.getSignature();</span><br><span class="line">        MethodSignature msig &#x3D; null;</span><br><span class="line">        if (!(sig instanceof MethodSignature)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;该注解只能用于方法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        msig &#x3D; (MethodSignature) sig;</span><br><span class="line"></span><br><span class="line">        Class[] parameterTypes &#x3D; msig.getMethod().getParameterTypes();</span><br><span class="line">        Object object &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 获得被拦截的方法</span><br><span class="line">        Method method &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            method &#x3D; target.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">        &#125; catch (NoSuchMethodException e1) &#123;</span><br><span class="line">            ControllerLogAopAspect.LOGGER.error(&quot;ControllerLogAopAspect around error&quot;, e1);</span><br><span class="line">        &#125; catch (SecurityException e1) &#123;</span><br><span class="line">            ControllerLogAopAspect.LOGGER.error(&quot;ControllerLogAopAspect around error&quot;, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (null !&#x3D; method) &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断是否包含自定义的注解，说明一下这里的SystemLog就是我自己自定义的注解</span><br><span class="line">            if (method.isAnnotationPresent(SystemControllerLog.class)) &#123;</span><br><span class="line">                HttpSession httpSession &#x3D; httpRequest.getSession(true);</span><br><span class="line">                log.setUserId(211);  &#x2F;&#x2F; 该数据为测试数据</span><br><span class="line">                log.setUserName(&quot;程序猿&quot;);  &#x2F;&#x2F; 该数据为测试数据</span><br><span class="line"></span><br><span class="line">                SystemControllerLog systemlog &#x3D; method.getAnnotation(SystemControllerLog.class);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 请求查询操作前数据的spring bean</span><br><span class="line">                String serviceClass &#x3D; systemlog.serviceClass();</span><br><span class="line">                &#x2F;&#x2F; 请求查询数据的方法</span><br><span class="line">                String queryMethod &#x3D; systemlog.queryMethod();</span><br><span class="line">                &#x2F;&#x2F; 设置调用模块和方法</span><br><span class="line">                log.setModule(systemlog.module());</span><br><span class="line">                log.setMethod(systemlog.methods());</span><br><span class="line">                log.setUserIp(HttpRequestUtil.getIpAddr(httpRequest));</span><br><span class="line">                &#x2F;&#x2F; 设置请求参数</span><br><span class="line">                log.setOperateParams(operateParamArray.toJSONString());</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 判断是否需要进行操作前的对象参数查询</span><br><span class="line">                if (StringUtils.isNotBlank(systemlog.parameterKey())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotBlank(systemlog.parameterType())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotBlank(systemlog.queryMethod())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotBlank(systemlog.serviceClass())) &#123;</span><br><span class="line">                    boolean isArrayResult &#x3D; systemlog.paramIsArray();</span><br><span class="line">                    &#x2F;&#x2F; 参数类型</span><br><span class="line">                    String paramType &#x3D; systemlog.parameterType();</span><br><span class="line">                    String key &#x3D; systemlog.parameterKey();</span><br><span class="line"></span><br><span class="line">                    if (isArrayResult) &#123; &#x2F;&#x2F; 批量操作</span><br><span class="line">                        &#x2F;&#x2F; 从请求的参数中解析出查询key对应的value值</span><br><span class="line">                        String value &#x3D; &quot;&quot;;</span><br><span class="line">                        JSONArray beforeParamArray &#x3D; new JSONArray();</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; operateParamArray.size(); i++) &#123;</span><br><span class="line">                            JSONObject params &#x3D; operateParamArray.getJSONObject(i);</span><br><span class="line">                            JSONArray paramArray &#x3D; (JSONArray) params.get(key);</span><br><span class="line">                            if (paramArray !&#x3D; null) &#123;</span><br><span class="line">                                for (int j &#x3D; 0; j &lt; paramArray.size(); j++) &#123;</span><br><span class="line">                                    String paramId &#x3D; paramArray.getString(j);</span><br><span class="line">                                    &#x2F;&#x2F; 在此处判断spring bean查询的方法参数类型</span><br><span class="line">                                    Object data &#x3D; getOperateBeforeData(paramType, serviceClass, queryMethod, paramId);</span><br><span class="line">                                    JSONObject json &#x3D; (JSONObject) JSON.toJSON(data);</span><br><span class="line">                                    beforeParamArray.add(json);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        log.setBeforeParams(beforeParamArray.toJSONString());</span><br><span class="line">                    &#125; else &#123; &#x2F;&#x2F; 单量操作</span><br><span class="line">                        &#x2F;&#x2F; 从请求的参数中解析出查询key对应的value值</span><br><span class="line">                        String value &#x3D; &quot;&quot;;</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; operateParamArray.size(); i++) &#123;</span><br><span class="line">                            JSONObject params &#x3D; operateParamArray.getJSONObject(i);</span><br><span class="line">                            value &#x3D; params.getString(key);</span><br><span class="line">                            if (StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 在此处获取操作前的spring bean的查询方法</span><br><span class="line">                        Object data &#x3D; getOperateBeforeData(paramType, serviceClass, queryMethod, value);</span><br><span class="line">                        JSONObject beforeParam &#x3D; (JSONObject) JSON.toJSON(data);</span><br><span class="line">                        log.setBeforeParams(beforeParam.toJSONString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                long entTime &#x3D; System.currentTimeMillis();</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 执行页面请求模块方法，并返回</span><br><span class="line">                    object &#x3D; proceedingJoinPoint.proceed();</span><br><span class="line">                    &#x2F;&#x2F; 获取系统时间</span><br><span class="line">                    log.setEndTime(new Date());</span><br><span class="line">                    &#x2F;&#x2F; 将object 转化为controller封装返回的实体类：RequestResult</span><br><span class="line">                    R requestResult &#x3D; (R) object;</span><br><span class="line">                    Object code &#x3D; requestResult.get(&quot;code&quot;);</span><br><span class="line">                    if (Integer.parseInt(code.toString()) &#x3D;&#x3D; 200) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 操作流程成功</span><br><span class="line">                        log.setResultStatus(200);</span><br><span class="line">                        log.setResultMsg(&quot;执行成功&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        log.setResultStatus(500);</span><br><span class="line">                        log.setResultMsg(&quot;失败&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.setTime(String.valueOf(entTime - startTime));</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 保存进数据库</span><br><span class="line">                    logservice.insert(log);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    log.setEndTime(new Date());</span><br><span class="line">                    log.setResultStatus(500);</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                    log.setResultMsg(e.getMessage());</span><br><span class="line">                    log.setTime(String.valueOf(entTime - startTime));</span><br><span class="line"></span><br><span class="line">                    logservice.insert(log);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 没有包含注解</span><br><span class="line">                object &#x3D; proceedingJoinPoint.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 不需要拦截直接执行</span><br><span class="line">            object &#x3D; proceedingJoinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能描述: &lt;br&gt;</span><br><span class="line">     * 〈功能详细描述〉</span><br><span class="line">     *</span><br><span class="line">     * @param paramType:参数类型</span><br><span class="line">     * @param serviceClass：bean名称</span><br><span class="line">     * @param queryMethod：查询method</span><br><span class="line">     * @param value：查询id的value</span><br><span class="line">     * @return</span><br><span class="line">     * @see [相关类&#x2F;方法](可选)</span><br><span class="line">     * @since [产品&#x2F;模块版本](可选)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object getOperateBeforeData(</span><br><span class="line">            String paramType, String serviceClass, String queryMethod, String value) &#123;</span><br><span class="line">        Object obj &#x3D; new Object();</span><br><span class="line">        &#x2F;&#x2F; 在此处解析请求的参数类型，根据id查询数据，id类型有四种：int，Integer,long,Long</span><br><span class="line">        if (paramType.equals(&quot;int&quot;)) &#123;</span><br><span class="line">            int id &#x3D; Integer.parseInt(value);</span><br><span class="line">            Method mh &#x3D;</span><br><span class="line">                    ReflectionUtils.findMethod(</span><br><span class="line">                            SpringContextUtil.getBean(serviceClass).getClass(), queryMethod, int.class);</span><br><span class="line">            &#x2F;&#x2F; 用spring bean获取操作前的参数,此处需要注意：传入的id类型与bean里面的参数类型需要保持一致</span><br><span class="line">            obj &#x3D; ReflectionUtils.invokeMethod(mh, SpringContextUtil.getBean(serviceClass), id);</span><br><span class="line">        &#125; else if (paramType.equals(&quot;Integer&quot;)) &#123;</span><br><span class="line">            Integer id &#x3D; Integer.valueOf(value);</span><br><span class="line">            Method mh &#x3D;</span><br><span class="line">                    ReflectionUtils.findMethod(</span><br><span class="line">                            SpringContextUtil.getBean(serviceClass).getClass(), queryMethod, Integer.class);</span><br><span class="line">            &#x2F;&#x2F; 用spring bean获取操作前的参数,此处需要注意：传入的id类型与bean里面的参数类型需要保持一致</span><br><span class="line">            obj &#x3D; ReflectionUtils.invokeMethod(mh, SpringContextUtil.getBean(serviceClass), id);</span><br><span class="line"></span><br><span class="line">        &#125; else if (paramType.equals(&quot;long&quot;)) &#123;</span><br><span class="line">            long id &#x3D; Long.parseLong(value);</span><br><span class="line">            Method mh &#x3D;</span><br><span class="line">                    ReflectionUtils.findMethod(</span><br><span class="line">                            SpringContextUtil.getBean(serviceClass).getClass(), queryMethod, long.class);</span><br><span class="line">            &#x2F;&#x2F; 用spring bean获取操作前的参数,此处需要注意：传入的id类型与bean里面的参数类型需要保持一致</span><br><span class="line">            obj &#x3D; ReflectionUtils.invokeMethod(mh, SpringContextUtil.getBean(serviceClass), id);</span><br><span class="line"></span><br><span class="line">        &#125; else if (paramType.equals(&quot;Long&quot;)) &#123;</span><br><span class="line">            Long id &#x3D; Long.valueOf(value);</span><br><span class="line">            Method mh &#x3D;</span><br><span class="line">                    ReflectionUtils.findMethod(</span><br><span class="line">                            SpringContextUtil.getBean(serviceClass).getClass(), queryMethod, Long.class);</span><br><span class="line">            &#x2F;&#x2F; 用spring bean获取操作前的参数,此处需要注意：传入的id类型与bean里面的参数类型需要保持一致</span><br><span class="line">            obj &#x3D; ReflectionUtils.invokeMethod(mh, SpringContextUtil.getBean(serviceClass), id);</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>13、启动项目使用Postman调取LogController中写好的接口</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/AOP%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/%E6%97%A5%E5%BF%97%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png" alt=""></p><p class='p small'>我们可以看到返回了success 200 ，去看mysql数据库中是否成功的插入了数据和日志操作</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/AOP%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/%E6%97%A5%E5%BF%97%E6%8F%92%E5%85%A5Mysql.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/AOP%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/%E6%97%A5%E5%BF%97%E6%8F%92%E5%85%A5mysql02.png" alt=""></p><p class='p small'>接下来调用update接口</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/AOP%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/%E6%97%A5%E5%BF%97%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C02.png" alt=""></p><p class='p small'>再继续查看数据库是否更新了数据</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/AOP%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/%E6%97%A5%E5%BF%97%E6%8F%92%E5%85%A5mysql03.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/AOP%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/%E6%97%A5%E5%BF%97%E6%8F%92%E5%85%A5mysql04.png" alt=""></p><p class='p small'>我们可以看到记录了操作前的数据和传递过来的参数，至此，使用切面记录日志操作就到此结束了！</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Spring</tag>

        </tags>

    </entry>


    <entry>
        <title>Nacos持久化配置</title>
        <link href="/2021/07/28/Nacos%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
        <url>/2021/07/28/Nacos%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Nacos持久化配置</p><p class='p small'>Nacos默认自带的是嵌入式数据库derby</p><p class='p small'>我们得从derby到mysql切换配置</p><p class='p small'>1、在nacos-server-1.1.4\nacos\conf目录下找到sql脚本并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">CREATE DATABASE nacos_config;</span><br><span class="line">USE nacos_config;</span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; config_info   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;config_info&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;data_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;data_id&#39;,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(255) DEFAULT NULL,</span><br><span class="line">  &#96;content&#96; LONGTEXT NOT NULL COMMENT &#39;content&#39;,</span><br><span class="line">  &#96;md5&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;md5&#39;,</span><br><span class="line">  &#96;gmt_create&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,</span><br><span class="line">  &#96;src_user&#96; TEXT COMMENT &#39;source user&#39;,</span><br><span class="line">  &#96;src_ip&#96; VARCHAR(20) DEFAULT NULL COMMENT &#39;source ip&#39;,</span><br><span class="line">  &#96;app_name&#96; VARCHAR(128) DEFAULT NULL,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,</span><br><span class="line">  &#96;c_desc&#96; VARCHAR(256) DEFAULT NULL,</span><br><span class="line">  &#96;c_use&#96; VARCHAR(64) DEFAULT NULL,</span><br><span class="line">  &#96;effect&#96; VARCHAR(64) DEFAULT NULL,</span><br><span class="line">  &#96;type&#96; VARCHAR(64) DEFAULT NULL,</span><br><span class="line">  &#96;c_schema&#96; TEXT,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_configinfo_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info&#39;;</span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; config_info_aggr   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;config_info_aggr&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;data_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;data_id&#39;,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;group_id&#39;,</span><br><span class="line">  &#96;datum_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;datum_id&#39;,</span><br><span class="line">  &#96;content&#96; LONGTEXT NOT NULL COMMENT &#39;内容&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL COMMENT &#39;修改时间&#39;,</span><br><span class="line">  &#96;app_name&#96; VARCHAR(128) DEFAULT NULL,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_configinfoaggr_datagrouptenantdatum&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;datum_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;增加租户字段&#39;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; config_info_beta   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;config_info_beta&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;data_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;data_id&#39;,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(128) NOT NULL COMMENT &#39;group_id&#39;,</span><br><span class="line">  &#96;app_name&#96; VARCHAR(128) DEFAULT NULL COMMENT &#39;app_name&#39;,</span><br><span class="line">  &#96;content&#96; LONGTEXT NOT NULL COMMENT &#39;content&#39;,</span><br><span class="line">  &#96;beta_ips&#96; VARCHAR(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,</span><br><span class="line">  &#96;md5&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;md5&#39;,</span><br><span class="line">  &#96;gmt_create&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,</span><br><span class="line">  &#96;src_user&#96; TEXT COMMENT &#39;source user&#39;,</span><br><span class="line">  &#96;src_ip&#96; VARCHAR(20) DEFAULT NULL COMMENT &#39;source ip&#39;,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_configinfobeta_datagrouptenant&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_beta&#39;;</span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; config_info_tag   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;config_info_tag&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;data_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;data_id&#39;,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(128) NOT NULL COMMENT &#39;group_id&#39;,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,</span><br><span class="line">  &#96;tag_id&#96; VARCHAR(128) NOT NULL COMMENT &#39;tag_id&#39;,</span><br><span class="line">  &#96;app_name&#96; VARCHAR(128) DEFAULT NULL COMMENT &#39;app_name&#39;,</span><br><span class="line">  &#96;content&#96; LONGTEXT NOT NULL COMMENT &#39;content&#39;,</span><br><span class="line">  &#96;md5&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;md5&#39;,</span><br><span class="line">  &#96;gmt_create&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,</span><br><span class="line">  &#96;src_user&#96; TEXT COMMENT &#39;source user&#39;,</span><br><span class="line">  &#96;src_ip&#96; VARCHAR(20) DEFAULT NULL COMMENT &#39;source ip&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_configinfotag_datagrouptenanttag&#96; (&#96;data_id&#96;,&#96;group_id&#96;,&#96;tenant_id&#96;,&#96;tag_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_info_tag&#39;;</span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; config_tags_relation   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;config_tags_relation&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;tag_name&#96; VARCHAR(128) NOT NULL COMMENT &#39;tag_name&#39;,</span><br><span class="line">  &#96;tag_type&#96; VARCHAR(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,</span><br><span class="line">  &#96;data_id&#96; VARCHAR(255) NOT NULL COMMENT &#39;data_id&#39;,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(128) NOT NULL COMMENT &#39;group_id&#39;,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,</span><br><span class="line">  &#96;nid&#96; BIGINT(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  PRIMARY KEY (&#96;nid&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_configtagrelation_configidtag&#96; (&#96;id&#96;,&#96;tag_name&#96;,&#96;tag_type&#96;),</span><br><span class="line">  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;config_tag_relation&#39;;</span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; group_capacity   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;group_capacity&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,</span><br><span class="line">  &#96;quota&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,</span><br><span class="line">  &#96;usage&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,</span><br><span class="line">  &#96;max_size&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,</span><br><span class="line">  &#96;max_aggr_count&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,</span><br><span class="line">  &#96;max_aggr_size&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,</span><br><span class="line">  &#96;max_history_count&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,</span><br><span class="line">  &#96;gmt_create&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_group_id&#96; (&#96;group_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;集群、各Group容量信息表&#39;;</span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; his_config_info   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;his_config_info&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(64) UNSIGNED NOT NULL,</span><br><span class="line">  &#96;nid&#96; BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;data_id&#96; VARCHAR(255) NOT NULL,</span><br><span class="line">  &#96;group_id&#96; VARCHAR(128) NOT NULL,</span><br><span class="line">  &#96;app_name&#96; VARCHAR(128) DEFAULT NULL COMMENT &#39;app_name&#39;,</span><br><span class="line">  &#96;content&#96; LONGTEXT NOT NULL,</span><br><span class="line">  &#96;md5&#96; VARCHAR(32) DEFAULT NULL,</span><br><span class="line">  &#96;gmt_create&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39;,</span><br><span class="line">  &#96;src_user&#96; TEXT,</span><br><span class="line">  &#96;src_ip&#96; VARCHAR(20) DEFAULT NULL,</span><br><span class="line">  &#96;op_type&#96; CHAR(10) DEFAULT NULL,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;nid&#96;),</span><br><span class="line">  KEY &#96;idx_gmt_create&#96; (&#96;gmt_create&#96;),</span><br><span class="line">  KEY &#96;idx_gmt_modified&#96; (&#96;gmt_modified&#96;),</span><br><span class="line">  KEY &#96;idx_did&#96; (&#96;data_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;多租户改造&#39;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">&#x2F;*   数据库全名 &#x3D; nacos_config   *&#x2F;</span><br><span class="line">&#x2F;*   表名称 &#x3D; tenant_capacity   *&#x2F;</span><br><span class="line">&#x2F;******************************************&#x2F;</span><br><span class="line">CREATE TABLE &#96;tenant_capacity&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,</span><br><span class="line">  &#96;quota&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,</span><br><span class="line">  &#96;usage&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,</span><br><span class="line">  &#96;max_size&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,</span><br><span class="line">  &#96;max_aggr_count&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,</span><br><span class="line">  &#96;max_aggr_size&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,</span><br><span class="line">  &#96;max_history_count&#96; INT(10) UNSIGNED NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,</span><br><span class="line">  &#96;gmt_create&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; DATETIME NOT NULL DEFAULT &#39;2010-05-05 00:00:00&#39; COMMENT &#39;修改时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_tenant_id&#96; (&#96;tenant_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;租户容量信息表&#39;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">CREATE TABLE &#96;tenant_info&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;kp&#96; VARCHAR(128) NOT NULL COMMENT &#39;kp&#39;,</span><br><span class="line">  &#96;tenant_id&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,</span><br><span class="line">  &#96;tenant_name&#96; VARCHAR(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_name&#39;,</span><br><span class="line">  &#96;tenant_desc&#96; VARCHAR(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,</span><br><span class="line">  &#96;create_source&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;create_source&#39;,</span><br><span class="line">  &#96;gmt_create&#96; BIGINT(20) NOT NULL COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_modified&#96; BIGINT(20) NOT NULL COMMENT &#39;修改时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uk_tenant_info_kptenantid&#96; (&#96;kp&#96;,&#96;tenant_id&#96;),</span><br><span class="line">  KEY &#96;idx_tenant_id&#96; (&#96;tenant_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin COMMENT&#x3D;&#39;tenant_info&#39;;</span><br><span class="line"> </span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    username VARCHAR(50) NOT NULL PRIMARY KEY,</span><br><span class="line">    PASSWORD VARCHAR(500) NOT NULL,</span><br><span class="line">    enabled BOOLEAN NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">CREATE TABLE roles (</span><br><span class="line">    username VARCHAR(50) NOT NULL,</span><br><span class="line">    role VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO users (username, PASSWORD, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);</span><br><span class="line"> </span><br><span class="line">INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);</span><br></pre></td></tr></table></figure><p class='p small'>2、在nacos-server-1.1.4\nacos\conf目录下找到application.properties</p><p class='p small'>修改application.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"> </span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_config?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;root</span><br><span class="line">db.password&#x3D;你自己的mysql密码</span><br></pre></td></tr></table></figure><p class='p small'>至此，nacos持久化的操作就配置完成了</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud</tag>

        </tags>

    </entry>


    <entry>
        <title>使用Java代码对nacos配置文件进行操作</title>
        <link href="/2021/07/27/%E4%BD%BF%E7%94%A8Java%E4%BB%A3%E7%A0%81%E5%AF%B9nacos%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
        <url>
            /2021/07/27/%E4%BD%BF%E7%94%A8Java%E4%BB%A3%E7%A0%81%E5%AF%B9nacos%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C/
        </url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>使用Java代码对nacos配置文件进行操作</p><p class='p small'>1、下载依赖包，将该依赖包解压后放到maven仓库下repository/com文件夹下</p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/nacos/xj.zip" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/nacos/xj.zip</a></p><p class='p small'>2、将坐标导入到pom文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.xj&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;common&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、实操（登录nacos，读取配置，修改配置，删除配置）</p><p><strong><span class='p small red'>该实操的前提是nacos服务已启动</span></strong></p><p class='p small'>使用Java代码登录nacos（参数1：nacos地址加端口号，例如127.0.0.1:8848，参数2：nacos登录的用户名，参数3：nacos登录密码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NacosUtil.Login(&quot;IP地址+端口号&quot;,nacos用户名,nacos密码);</span><br></pre></td></tr></table></figure><p class='p small'>登录nacos后即可读取配置（参数1：配置列表中的Data Id，参数2：配置文件所在的组Group）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map yamlConfig &#x3D; NacosUtil.getYamlConfig(dataId,Group);</span><br></pre></td></tr></table></figure><p class='p small'>在控制台输出map就可以看到我们在nacos上的配置了</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/nacos/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9Cnacos/%E4%BD%BF%E7%94%A8Java%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9Cnacos.png" alt=""></p><p class='p small'>修改配置（参数1：就是我们刚刚在控制台输出的配置，参数2：你需要修改的key，参数3：key所替换的value值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NacosUtil.setYamlConfig(yamlConfig,key,value);</span><br></pre></td></tr></table></figure><p class='p small'>修改完成后我们需要将修改好的配置上传到nacos</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DumperOptions dumperOptions &#x3D; new DumperOptions();</span><br><span class="line">dumperOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);</span><br><span class="line">Yaml yaml &#x3D; new Yaml(dumperOptions);</span><br><span class="line">String dump &#x3D; yaml.dump(yamlConfig);</span><br><span class="line">NacosUtil.publish(dump,dataId,Group);  &#x2F;&#x2F; dataId为nacos配置列表中的dateId，Group为配置文件所在的组</span><br></pre></td></tr></table></figure><p class='p small'>至此，使用Java代码对nacos配置的修改就完成了</p><p><strong><span class='p small red'>删除nacos配置文件（慎重！）</span></strong></p><p class='p small'>前提需使用代码登陆了nacos平台并获取到了配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DumperOptions dumperOptions &#x3D; new DumperOptions();</span><br><span class="line">dumperOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);</span><br><span class="line">Yaml yaml &#x3D; new Yaml(dumperOptions);</span><br><span class="line">String dump &#x3D; yaml.dump(yamlConfig);</span><br><span class="line">NacosUtil.delete(dump,dataId,Group);</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud</tag>

        </tags>

    </entry>


    <entry>
        <title>JWT单点登录</title>
        <link href="/2021/07/27/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
        <url>/2021/07/27/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h3 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT"></a>什么是 JWT</h3><p><strong>JWT 官网：<a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener">https://jwt.io/#debugger-io</a></strong></p><p><strong>JWT：JSON Web Tokens 是一种开放的、行业标准的 <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">RFC 7519</a> 方法，用于在两方之间安全地表示声明</strong></p><p>JSON Web Token (JWT) 是一个开放标准 (RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><br/><h4 id="什么时候应该用-JSON-Web-Token"><a href="#什么时候应该用-JSON-Web-Token" class="headerlink" title="什么时候应该用 JSON Web Token"></a>什么时候应该用 JSON Web Token</h4><p>下列场景中使用 JSON Web Token 是很有用的：</p><p>Authorization (授权) : 这是使用 JWT 的最常见场景。一旦用户登录，后续每个请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的 JWT 的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p><p>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens 无疑是一种很好的方式。因为 JWT 可以被签名，例如，用公钥 / 私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</p><br/><h4 id="JWT-认证流程"><a href="#JWT-认证流程" class="headerlink" title="JWT 认证流程"></a>JWT 认证流程</h4><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="img"></p><p>首先，前端通过 Web 表单将自己的用户名和密码发送到后端的接口。这一过程 - - 般是一 个 HTTP POST 请求。建议的方式是通过 SSL 加密的传输 (https 协议) ，从而避免敏感信息被嗅探。</p><p>后端核对用户名和密码成功后，将用户的 id 等其他信息作为 JWT Payload (负载)，将其与头部分别进行 Base64 编码拼接后签名，形成一个 JWT (Token)。形成的 JWT 就是一个形同 11. zzz. xxx 的字符串。token head . payload . singurater</p><p>后端将 JWT 字符串作为登录成功的返回结果返回给前端。 前端可以将返回的结果保存在 localStorage 或 sessionStorage 上， 退出登录时前端删除保存的 JWT 即可。</p><p>前端在每次请求时将 JWT 放入 HTTP Header 中的 Authorization 位。 (解决 XSS 和 XSRF 问题)</p><p>后端检查是否存在，如存在验证 JWT 的有效性。例如，检查签名是否正确；检查 Token 是否过期；检查 Token 的接收方是否是自己 (可选)</p><p>验证通过后后端使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果。</p><br/><h4 id="JWT-优势在哪？"><a href="#JWT-优势在哪？" class="headerlink" title="JWT 优势在哪？"></a>JWT 优势在哪？</h4><p>1、简洁 (Compact): 可以通过 URL，POST 参 数或者在 HTTP header 发送，因为数据量小，传输速度也很快，自包含 (Self-contained): 负载中包含了所有用户所需要的信息，避免了多次查询数据库</p><p>2、因为 Token 是 以 JSON 加密的形式保存在客户端的，所以 JWT 是跨语言的，原则上任何 web 形式都支持。</p><p>3、不需要在服务端保存会话信息，特别适用于分布式微服务。</p><br/><h3 id="JWT-数据结构"><a href="#JWT-数据结构" class="headerlink" title="JWT 数据结构"></a>JWT 数据结构</h3><p>形如 xxxx.yyy.zzz 由三部分组成，每部分用英文句号连接</p><p><strong>JWT 的三个部分： header 头部 payload 负载 signature 签名</strong></p><p><strong>也就是 Header.Payload.Signature</strong></p><p>例如：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6IumZhuS9s-aZqCIsImV4cCI6MTYyNzM2NTQzNiwidXNlcklkIjoyMH0.34HAEE_8BhCMdnnx7MpqNMz6DuSW3yaGp49AmY3ZW10</p><br/><h5 id="1、Header-头部"><a href="#1、Header-头部" class="headerlink" title="1、Header 头部"></a>1、Header 头部</h5><p>是一个 JSON 对象，描述 JWT 的元数据，形如： {alg: HS256</p><p>alg 属性表示签名的算法（algorithm），默认是 HMAC SHA256</p><p>typ 属性表示这个令牌的类型（type），JWT 令牌统一写为 JWT</p><br/><h5 id="2、payload-负载"><a href="#2、payload-负载" class="headerlink" title="2、payload 负载"></a>2、payload 负载</h5><p>是一个 JSON 对象，用来存放实际需要传递的数据，形如： {sub: 1234567890</p><p>一般是在这个部分定义私有字段： 例如 {userId:1，”userName”:jack</p><p>其中 payload 官方规定了 7 个字段：</p><p><strong>iss (issuer)：签发人</strong></p><p><strong>exp (expiration time)：过期时间</strong></p><p><strong>sub (subject)：主题</strong></p><p><strong>aud (audience)：受众</strong></p><p><strong>nbf (Not Before)：生效时间</strong></p><p><strong>iat (Issued At)：签发时间</strong></p><p><strong>jti (JWT ID)：编号</strong></p><p><strong>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把机密信息放在这个部分。</strong></p><br/><h5 id="3、signature-签名"><a href="#3、signature-签名" class="headerlink" title="3、signature 签名"></a>3、signature 签名</h5><p>signature 是对前两部分的签名，防止数据篡改</p><p>1、需要指定一个密钥（secret）</p><p>2、这个密钥只有服务器才知道，不能泄露给客户端</p><p>3、使用 Header 里面指定的签名算法，按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&#96;HMACSHA256(</span><br><span class="line">   base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">   base64UrlEncode(payload),</span><br><span class="line">   secret</span><br><span class="line"> )&#96;</span><br></pre></td></tr></table></figure><p>也就是 signature 等于上面公式算出来的</p><p>把 Header、Payload、Signature 三个部分拼成一个字符串: xxxx.yyy.zzz</p><p>其中 base64UrlEncode 是串型化算法，处理特殊字符，= 被省略、+ 替换成 -，/ 替换成_</p><br/><h4 id="JWT-使用方式"><a href="#JWT-使用方式" class="headerlink" title="JWT 使用方式"></a>JWT 使用方式</h4><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage 以后客户端每次与服务器通信，都要带上这个 JWT</p><p>方式 1、可以放在 Cookie 里面自动发送，但是这样不能跨域</p><p>方式 2、更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>方式 3、JWT 放在 POST 请求的数据体 body 里面</p><br/><h4 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h4><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><br/><h3 id="JWT-案例"><a href="#JWT-案例" class="headerlink" title="JWT 案例"></a>JWT 案例</h3><p>1、引入 JWT 的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&lt;!--JWT--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.4.0&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><br/><p>2、编写生成 JWT 的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&#x2F;**</span><br><span class="line">    * 生成JWT密钥</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Test</span><br><span class="line">   void getToken() &#123;</span><br><span class="line">       HashMap&lt;String, Object&gt; hashMap &#x3D; new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">       Calendar instance &#x3D; Calendar.getInstance();</span><br><span class="line">       instance.add(Calendar.MINUTE,5);                &#x2F;&#x2F; 以分钟为单位</span><br><span class="line"></span><br><span class="line">       String token &#x3D; JWT.create()</span><br><span class="line">               .withHeader(hashMap)                            &#x2F;&#x2F; header</span><br><span class="line">               .withClaim(&quot;userId&quot;, 20)               &#x2F;&#x2F; payload</span><br><span class="line">               .withClaim(&quot;userName&quot;, &quot;陆佳晨&quot;)       &#x2F;&#x2F; payload</span><br><span class="line">               .withExpiresAt(instance.getTime())              &#x2F;&#x2F; 指定令牌的过期时间</span><br><span class="line">               .sign(Algorithm.HMAC256(&quot;SIGNATURE&quot;));&#x2F;&#x2F; 签名</span><br><span class="line"></span><br><span class="line">       System.out.println(token);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br/><p>3、解析 JWT 密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">@Test</span><br><span class="line">    void verify()&#123;</span><br><span class="line">        &#x2F;&#x2F; 创建验证对象</span><br><span class="line">        JWTVerifier jwtVerifier &#x3D; JWT.require(Algorithm.HMAC256(&quot;SIGNATURE&quot;)).build();</span><br><span class="line">        &#x2F;&#x2F; 进行解析操作</span><br><span class="line">        DecodedJWT verify &#x3D; jwtVerifier.verify(&quot;填写你刚刚生成的JWT密钥&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取到登陆信息</span><br><span class="line">        System.out.println(verify.getClaim(&quot;userId&quot;).asInt());</span><br><span class="line">        System.out.println(verify.getClaim(&quot;userName&quot;).asString());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取令牌的过期时间</span><br><span class="line">        System.out.println(verify.getExpiresAt());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br/><h4 id="JWT-工具包"><a href="#JWT-工具包" class="headerlink" title="JWT 工具包"></a>JWT 工具包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">package com.xj.jwt.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.auth0.jwt.JWT;</span><br><span class="line">import com.auth0.jwt.JWTCreator;</span><br><span class="line">import com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line">import com.auth0.jwt.interfaces.Claim;</span><br><span class="line">import com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JwtUtil &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 切记不要将令牌泄露</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final String SING &#x3D; &quot;SIGNATURE&quot;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取token</span><br><span class="line">     *</span><br><span class="line">     * @param map</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getToken(Map&lt;String, String&gt; map, Integer expire) &#123;</span><br><span class="line">        Calendar instance &#x3D; Calendar.getInstance();</span><br><span class="line">        &#x2F;&#x2F; 以小时为单位</span><br><span class="line">        instance.add(Calendar.HOUR,expire);</span><br><span class="line"></span><br><span class="line">        JWTCreator.Builder builder &#x3D; JWT.create();</span><br><span class="line"></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            builder.withClaim(k, v);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return builder.withExpiresAt(instance.getTime())</span><br><span class="line">                .sign(Algorithm.HMAC256(SING));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解析token</span><br><span class="line">     * @param token</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Map&lt;String,String&gt; verify(String token)&#123;</span><br><span class="line"></span><br><span class="line">        DecodedJWT verify &#x3D; JWT.require(Algorithm.HMAC256(SING))</span><br><span class="line">                .build().verify(token);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; resultMap&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Claim&gt; claims &#x3D; verify.getClaims();</span><br><span class="line">        </span><br><span class="line">        claims.forEach((k,v)-&gt;&#123;</span><br><span class="line">            resultMap.put(k,v.asString());</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        return resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 验证token是否合法</span><br><span class="line">     * @param token</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static DecodedJWT lawful(String token)&#123;</span><br><span class="line">        return JWT.require(Algorithm.HMAC256(SING)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h4 id="JWT-常见报错"><a href="#JWT-常见报错" class="headerlink" title="JWT 常见报错"></a>JWT 常见报错</h4><p>JWT 密钥不一致:</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E5%AF%86%E9%92%A5%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="img"></p><p>JWT 密钥已过期：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E5%AF%86%E9%92%A5%E8%BF%87%E6%9C%9F.png" alt="img"></p><p>JWT 加密和解析度算法不一致：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/JWT/JWT%E7%AE%97%E6%B3%95%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="img"></p><br/><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Eureka集群的搭建</title>
        <link href="/2021/07/23/Eureka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
        <url>/2021/07/23/Eureka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Eureka服务注册与发现</p><p><strong><p class='p small'>首先在开始搭建Eureka服务之前，我们要了解Eureka的基础知识！</p></strong></p><h3 id="Eureka基础知识"><a href="#Eureka基础知识" class="headerlink" title="Eureka基础知识"></a>Eureka基础知识</h3><h4 id="什么是服务治理？"><a href="#什么是服务治理？" class="headerlink" title="什么是服务治理？"></a>什么是服务治理？</h4><p class='p small'>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理</p><p class='p small'>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><br/><h4 id="什么是服务注册与发现？"><a href="#什么是服务注册与发现？" class="headerlink" title="什么是服务注册与发现？"></a>什么是服务注册与发现？</h4><p class='p small'>Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p><p class='p small'>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</p><p><strong><p class='p small'>下图是Eureka系统架构</p></strong></p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E7%9A%84%E6%9E%B6%E6%9E%84.png" alt=""></p><br/><h4 id="Eureka的两大核心组件"><a href="#Eureka的两大核心组件" class="headerlink" title="Eureka的两大核心组件"></a>Eureka的两大核心组件</h4><p><strong><p class='p small'>Eureka Server提供服务注册服务</p></strong></p><p class='p small'>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p><strong><p class='p small'>EurekaClient通过注册中心进行访问</p></strong></p><p class='p small'>EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><br/><h3 id="单机Eureka构建步骤"><a href="#单机Eureka构建步骤" class="headerlink" title="单机Eureka构建步骤"></a>单机Eureka构建步骤</h3><h4 id="搭建eurekaServer端服务注册中心"><a href="#搭建eurekaServer端服务注册中心" class="headerlink" title="搭建eurekaServer端服务注册中心"></a>搭建eurekaServer端服务注册中心</h4><p class='p small'>1、新建一个名称为cloud-eureka-server7001的maven工程</p><p class='p small'>2、在pom文件中添加坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-server--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--boot web actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--一般通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在resources下新建application.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001  #端口号</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #false表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">    #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>4、新建EurekaMain7001主启动类</p><p><strong><p class='p small'>注意：@EnableEurekaServer 注解的作用在与将项目作为SpringCloud中的注册中心</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer  </span><br><span class="line">public class EurekaMain7001</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>5、启动项目访问端口http://localhost:7001/</p><p class='p small'>No instances available没有服务被发现，因为没有注册服务进来当然不可能有服务被发现</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/%E8%AE%BF%E9%97%AEEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt=""></p><br/><h4 id="搭建EurekaClient端的服务提供者provider"><a href="#搭建EurekaClient端的服务提供者provider" class="headerlink" title="搭建EurekaClient端的服务提供者provider"></a>搭建EurekaClient端的服务提供者provider</h4><p class='p small'>1、创建一个名称为cloud-provider-payment8001的maven工程</p><p class='p small'>目的是将cloud-provider-payment8001注册进EurekaServer成为服务提供者provider</p><p class='p small'>2、引入cloud-provider-payment8001工程的pom坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--mysql-connector-java--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--jdbc--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在resources目录下新建application.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service   #注册到Eureka的服务名</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</span><br><span class="line">    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</span><br><span class="line">    url: 填写你自己的mysql地址</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.atguigu.springcloud.entities    # 所有Entity别名类所在包</span><br></pre></td></tr></table></figure><p class='p small'>4、新建PaymentMain8001主启动类</p><p><strong><p class='p small'>注意：@EnableEurekaClient注解表示能够让注册中心发现、并扫描到PaymentMain8001服务</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class PaymentMain8001</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>5、在启动cloud-eureka-server7001服务的前提下启动cloud-provider-payment8001服务</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt=""></p><p><strong><p class='p small'>表示Eureka开启了自我保护机制</p></strong></p><br/><h4 id="搭建EurekaClient端的服务消费者consumer"><a href="#搭建EurekaClient端的服务消费者consumer" class="headerlink" title="搭建EurekaClient端的服务消费者consumer"></a>搭建EurekaClient端的服务消费者consumer</h4><p class='p small'>1、新建一个cloud-consumer-order80的maven工程</p><p class='p small'>目的是将其注册进EurekaServer成为服务消费者consumer（有服务提供者必然就会出现消费者）</p><p class='p small'>2、引入cloud-consumer-order80的pom坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在resources目录下新建application.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: cloud-order-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br></pre></td></tr></table></figure><p class='p small'>4、新建OrderMain80的主启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class OrderMain80</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>到此，我们的Eureka的单机版就已经全部搭建完成了</p><br/><h3 id="Eureka集群的搭建"><a href="#Eureka集群的搭建" class="headerlink" title="Eureka集群的搭建"></a>Eureka集群的搭建</h3><h4 id="Eureka集群原理说明"><a href="#Eureka集群原理说明" class="headerlink" title="Eureka集群原理说明"></a>Eureka集群原理说明</h4><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86.png" alt=""></p><p class='p small'>微服务RPC远程服务调用最核心的是什么 ?</p><p class='p small'>高可用，试想你的注册中心只有一个only one， 它出故障了那就呵呵(￣▽￣)了，会导致整个为服务环境不可用，也就是俗称的单点故障。%}{% p small</p><p class='p small'>2、导入7002的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-server--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--boot web actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--一般通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、修改映射配置</p><p class='p small'>找到C:\Windows\System32\drivers\etc路径下的hosts文件</p><p class='p small'>新增映射配置添加进hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1  eureka7001.com</span><br><span class="line">127.0.0.1  eureka7002.com</span><br></pre></td></tr></table></figure><p class='p small'>4、修改之前单机的yml配置文件（7001，7002）</p><p class='p small'>7001：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>7002：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p class='p small'>5、将支付服务8001微服务发布到上面2台Eureka集群配置中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      #defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka  # 集群版</span><br></pre></td></tr></table></figure><p class='p small'>6、将订单服务80微服务发布到上面2台Eureka集群配置中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: cloud-order-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br></pre></td></tr></table></figure><br/><h4 id="支付服务提供者8001集群环境构建"><a href="#支付服务提供者8001集群环境构建" class="headerlink" title="支付服务提供者8001集群环境构建"></a>支付服务提供者8001集群环境构建</h4><p class='p small'>1、参考cloud-provider-payment8001新建cloud-provider-payment8002</p><p class='p small'>2、导入8002的pom依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--mysql-connector-java--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--jdbc--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、写入8002的yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为true。</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br></pre></td></tr></table></figure><p class='p small'>至此，Eureka的集群就搭建好了</p><br/><h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p class='p small'>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p><p class='p small'>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：</p><p><strong><p class='p small'>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE</p></strong></p><h4 id="为什么会产生Eureka自我保护机制？"><a href="#为什么会产生Eureka自我保护机制？" class="headerlink" title="为什么会产生Eureka自我保护机制？"></a>为什么会产生Eureka自我保护机制？</h4><p class='p small'>为了防止EurekaClient可以正常运行，但是 与 EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</p><h4 id="什么是自我保护模式？"><a href="#什么是自我保护模式？" class="headerlink" title="什么是自我保护模式？"></a>什么是自我保护模式？</h4><p class='p small'>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/SpringCloud%20Netflix/Eureka/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.png" alt=""></p><p><strong><p class='p small'>一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存</p></strong></p><p><strong><p class='p small'>属于CAP里面的AP分支</p></strong></p><h4 id="怎么禁止自我保护"><a href="#怎么禁止自我保护" class="headerlink" title="怎么禁止自我保护"></a>怎么禁止自我保护</h4><p class='p small'>在yml中Eureka的配置进行修改</p><p class='p small'>使用eureka.server.enable-self-preservation = false 可以禁用自我保护模式</p><p class='p small'>或者修改Eureka的注销实例的默认时间（单位为秒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.lease-expiration-duration-in-seconds&#x3D;90</span><br></pre></td></tr></table></figure><p class='p small'>到此，Eureka的入门就完成了!</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringCloud</tag>

        </tags>

    </entry>


    <entry>
        <title>为什么要使用Optional?</title>
        <link href="/2021/07/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Optional/"/>
        <url>/2021/07/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Optional/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Java8_Optional类</p><h2 id="理解Optional"><a href="#理解Optional" class="headerlink" title="理解Optional"></a>理解Optional</h2><p><strong><p class='p small'>设计目的：</p></strong></p><p><strong><p class='p small'>我们的目的是为方法的返回类型提供一种有限的机制，其中需要一种明确的方式来表示“无结果”，并且对于这样的方法使用null绝对可能导致错误。</p></strong></p><p class='p small'>Optional 是一个可以包含NULL值的容器，或者叫做一个包装类，只包装了一个属性，这个属性的值可有可无。</p><br/><h2 id="Optional方法摘要"><a href="#Optional方法摘要" class="headerlink" title="Optional方法摘要"></a>Optional方法摘要</h2><p class='p small'>Optional继承自java.lang.Object类的方法</p><p class='p small'>所有方法：</p><table><thead><tr><th align="center">Method</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center"><code>empty()</code></td><td align="center">返回一个空的 <code>Optional</code>实例。</td></tr><tr><td align="center"><code>equals()</code></td><td align="center">指示某个其他对象是否等于此可选项。</td></tr><tr><td align="center"><code>filter()</code></td><td align="center">如果一个值存在，并且该值给定的谓词相匹配时，返回一个 <code>Optional</code>描述的值，否则返回一个空的 <code>Optional</code></td></tr><tr><td align="center"><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td align="center">如果一个值存在，应用提供的 <code>Optional</code>映射函数给它，返回该结果，否则返回一个空的 <code>Optional</code></td></tr><tr><td align="center"><code>get()</code></td><td align="center">如果 <code>Optional</code>中有一个值，返回值，否则抛出 <code>NoSuchElementException</code></td></tr><tr><td align="center"><code>hashCode()</code></td><td align="center">返回当前值的哈希码值（如果有的话），如果没有值，则返回0（零）</td></tr><tr><td align="center"><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code></td><td align="center">如果存在值，则使用该值调用指定的消费者，否则不执行任何操作</td></tr><tr><td align="center"><code>isPresent()</code></td><td align="center">返回 <code>true</code>如果存在值，否则为 <code>false</code></td></tr><tr><td align="center"><code>map(Function&lt;? super T,? extends U&gt; mapper)</code></td><td align="center">如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个 <code>Optional</code>结果的 <code>Optional</code></td></tr><tr><td align="center"><code>of(T value)</code></td><td align="center">返回具有 <code>Optional</code>的当前非空值的Optional</td></tr><tr><td align="center"><code>ofNullable(T value)</code></td><td align="center">返回一个 <code>Optional</code>指定值的Optional，如果非空，则返回一个空的 <code>Optional</code></td></tr><tr><td align="center"><code>orElse(T other)</code></td><td align="center">返回值如果存在，否则返回 <code>other</code></td></tr><tr><td align="center"><code>orElseGet(Supplier&lt;? extends T&gt; other)</code></td><td align="center">返回值（如果存在），否则调用 <code>other</code>并返回该调用的结果</td></tr><tr><td align="center"><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td><td align="center">返回包含的值（如果存在），否则抛出由提供的供应商创建的异常</td></tr><tr><td align="center"><code>toString()</code></td><td align="center">返回此可选的非空字符串表示，适用于调试</td></tr></tbody></table><br/><h2 id="Optional例子"><a href="#Optional例子" class="headerlink" title="Optional例子"></a>Optional例子</h2><h3 id="做为接口提供者"><a href="#做为接口提供者" class="headerlink" title="做为接口提供者"></a>做为接口提供者</h3><p class='p small'>我有一个方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">获取用户</span><br><span class="line">@param id 唯一id</span><br><span class="line">@return 用户 可能为null,代表不存在</span><br><span class="line">*&#x2F;</span><br><span class="line">public User getUser(Long id) &#123;</span><br><span class="line"> if (null !&#x3D; id) &#123;</span><br><span class="line">   return new User();</span><br><span class="line"> &#125;</span><br><span class="line"> return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>尽管已经在方法注释中说明返回的User可能为空，可我依然不敢保证其他开发成员都会进行 if (user == null) 判断，当没有这一步时，那么接下来就是大家最常见的NullPointerException</p><p class='p small'>此时，调用者会不会内心：MD</p><p class='p small'>提供者：（捂脸）冤枉啊！你自己不看方法注释，还怪我……</p><p><strong><p class='p small'>这个时候Optional就该上场了？</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;User&gt; getUser(Long id) &#123;</span><br><span class="line">if (null !&#x3D; id) &#123;</span><br><span class="line">return Optional.of(new User());</span><br><span class="line">&#125;</span><br><span class="line">return Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>你们看！现在已经明确的告诉了调用者，返回的用户对象是可能存在也可能不存在，你要注意两者的不同处理。</p><p><strong><p class='p small'>此时，仅仅改变一个返回值，就能很大程度上帮助调用者避免NPE的问题</p></strong></p><br/><h3 id="做为调用者"><a href="#做为调用者" class="headerlink" title="做为调用者"></a>做为调用者</h3><p>提供者返回的类型为Optional，那么就是说返回的对象可能为null,那么我要分别判断存在和不存在该如何处理了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">  Optional&lt;User&gt; userOp &#x3D; getUser(110L);</span><br><span class="line">  if (userOp.isPresent())&#123;</span><br><span class="line">    User user &#x3D; userOp.get();</span><br><span class="line">    &#x2F;&#x2F; TODO</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我现在只想对不为空的情况处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userOp.isPresent(user -&gt; log.info(user));</span><br></pre></td></tr></table></figure><p>如果现在我想获取用户住址中的国家：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userOp.map(User::getAddress).map(Address::getCountry);</span><br></pre></td></tr></table></figure><p>如果用户不存在或地址不存在，我需要抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userOp.map(User::getAddress)</span><br><span class="line">  .map(Address::getCountry)</span><br><span class="line">  .orElseThrow(NotExistException::new);</span><br></pre></td></tr></table></figure><p>如果想要设置默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userOp.map(User::getAddress)</span><br><span class="line">  .map(Address::getCountry)</span><br><span class="line">  .orElse(&quot;默认值&quot;);</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Redis持久化</title>
        <link href="/2021/07/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
        <url>/2021/07/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Redis 持久化</p><h2 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h2><p class='p small'>Redis 提供了一系列不同的持久性选项：</p><ul><li><strong>RDB</strong>（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。</li><li><strong>AOF</strong>（Append Only File）：AOF 持久化记录服务器收到的每个写操作，在服务器启动时会再次播放，重建原始数据集。命令使用与 Redis 协议本身相同的格式以仅附加的方式记录。当日志变得太大时，Redis 能够在后台重写日志。</li><li><strong>无持久性</strong>：如果您希望数据在服务器运行时一直存在，您可以完全禁用持久性。</li><li><strong>RDB + AOF</strong>：可以在同一个实例中组合 AOF 和 RDB。请注意，在这种情况下，当 Redis 重新启动时，AOF 文件将用于重建原始数据集，因为它保证是最完整的。</li></ul><br/><h2 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h2><p class='p small'>RDB是指在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p> <p class='p small'>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p><strong><p class='p small'>Fork：</p></strong></p><p class='p small'>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p><br/><h3 id="如何触发RDB快照？"><a href="#如何触发RDB快照？" class="headerlink" title="如何触发RDB快照？"></a>如何触发RDB快照？</h3><p class='p small'>RDB是redis配置文件中默认的快照配置</p><p class='p small'>或执行命令来进行保存save或者是bgsave</p><p class='p small'>Save：save时只管保存，其它不管，全部阻塞</p><p class='p small'>BGSAVE：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间</p><p><strong><span class='p small red'>Rdb 保存的是dump.rdb文件</span></strong></p><br/><h3 id="如何恢复？"><a href="#如何恢复？" class="headerlink" title="如何恢复？"></a>如何恢复？</h3><p class='p small'>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p><br/><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止?"></a>如何停止?</h3><p class='p small'>动态所有停止RDB保存规则的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config set save &quot;&quot;</span><br></pre></td></tr></table></figure><br/><h3 id="RDB的优劣势"><a href="#RDB的优劣势" class="headerlink" title="RDB的优劣势"></a>RDB的优劣势</h3><p class='p small'>优势：</p><p class='p small'>1、适合大规模的数据恢复</p><p class='p small'>2、对数据完整性和一致性要求不高</p><p class='p small'>劣势：</p><p class='p small'>1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</p><p class='p small'>2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/RDB%E6%80%BB%E7%BB%93.png" alt="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/RDB%E6%80%BB%E7%BB%93.png"></p><br/><h2 id="AOF是什么？"><a href="#AOF是什么？" class="headerlink" title="AOF是什么？"></a>AOF是什么？</h2><p class='p small'>AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><br/><h3 id="AOF启动-修复-恢复"><a href="#AOF启动-修复-恢复" class="headerlink" title="AOF启动/修复/恢复"></a>AOF启动/修复/恢复</h3><p><strong><p class='p small'>启动：</p></strong></p><p class='p small'>修改Redis配置文件中默认的appendonly no，改为yes</p><p><strong><p class='p small'>正常恢复：</p></strong></p><p class='p small'>重启redis之后会自动加载appendonly.aof文件</p><p><strong><p class='p small'>异常修复：</p></strong></p><p class='p small'>使用命令进行修复然后重启redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-check-aof --fix</span><br></pre></td></tr></table></figure><br/><h3 id="Rewrite是什么？"><a href="#Rewrite是什么？" class="headerlink" title="Rewrite是什么？"></a>Rewrite是什么？</h3><p class='p small'>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制</p><p><strong><p class='p small'>重写原理：</p></strong></p><p class='p small'>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p><p><strong><p class='p small'>触发机制：</p></strong></p><p class='p small'>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><br/><h3 id="AOF的优劣势"><a href="#AOF的优劣势" class="headerlink" title="AOF的优劣势"></a>AOF的优劣势</h3><p><strong><p class='p small'>优势：</p></strong></p><p class='p small'>每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p class='p small'>每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p class='p small'>不同步：appendfsync no 从不同步</p><p><strong>劣势：</strong></p><p class='p small'>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</p><p class='p small'>Aof运行效率要慢于rdb</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/AOF%E6%80%BB%E7%BB%93.png" alt="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Redis/AOF%E6%80%BB%E7%BB%93.png"></p><br/><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p class='p small'>总得来说RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储，而AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p><p><strong><p class='p small'>一般建议两种持久化同时开启</p></strong></p><p class='p small'>在这种情况下</p><p class='p small'>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p><p><strong><p class='p small'>性能建议：</p></strong></p><p class='p small'>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p><p class='p small'>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</p><p class='p small'>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</p><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Redis</tag>

        </tags>

    </entry>


    <entry>
        <title>热部署Devtools</title>
        <link href="/2021/07/13/%E7%83%AD%E9%83%A8%E7%BD%B2Devtools/"/>
        <url>/2021/07/13/%E7%83%AD%E9%83%A8%E7%BD%B2Devtools/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>热部署Devtools</p><p class='p small'>1、将Devtools添加到pom中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p class='p small'>2、将插件添加到pom文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">        &lt;addResources&gt;true&lt;&#x2F;addResources&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">  &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p class='p small'>3、在idea中找到File-Settings-Build-Compiler</p><p class='p small'>将以下四个选项全部勾上</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E7%83%AD%E9%83%A8%E7%BD%B2/%E7%83%AD%E9%83%A8%E7%BD%B2Dectools.png" alt=""></p><p class='p small'>4、在idea中使用ctrl+shift+Alt+/打开Registry配置</p><p class='p small'>将以下两个选项勾上</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E7%83%AD%E9%83%A8%E7%BD%B2/%E7%83%AD%E9%83%A8%E7%BD%B2Dectools02.png" alt=""></p><p class='p small'>5、重启idea查看热部署是否生效</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Devtools</tag>

        </tags>

    </entry>


    <entry>
        <title>Java的深拷贝和浅拷贝</title>
        <link href="/2021/07/12/Java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
        <url>/2021/07/12/Java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Java的浅拷贝和深拷贝</p><p class='p small'>关于Java的深拷贝和浅拷贝，简单来说就是创建一个和已知对象一模一样的对象。可能日常编码过程中用的不多，但是这是一个面试经常会问的问题，而且了解深拷贝和浅拷贝的原理，对于Java中的所谓值传递或者引用传递将会有更深的理解。</p><br/><h3 id="1、创建对象的5种方式"><a href="#1、创建对象的5种方式" class="headerlink" title="1、创建对象的5种方式"></a>1、创建对象的5种方式</h3><p><strong><p class='p small'>①、通过 new 关键字</p></strong></p><p class='p small'>这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。</p><p class='p small'>比如 Object obj = new Object();</p><p><strong><p class='p small'>②、通过 Class 类的 newInstance() 方法</p></strong></p><p class='p small'>这种默认是调用类的无参构造方法创建对象。比如 Person p2 = (Person) Class.forName(com.ys.test.Person).newInstance();</p><p><strong><p class='p small'>③、通过 Constructor 类的 newInstance 方法</p></strong></p><p class='p small'>这和第二种方法类时，都是通过反射来实现。通过 java.lang.relect.Constructor 类的 newInstance() 方法指定某个构造器来创建对象。</p><p class='p small'>Person p3 = (Person) Person.class.getConstructors()[0].newInstance();</p><p class='p small'>实际上第二种方法利用 Class 的 newInstance() 方法创建对象，其内部调用还是 Constructor 的newInstance() 方法。</p><p><strong><p class='p small'>④、利用 Clone 方法</p></strong></p><p class='p small'>Clone 是 Object 类中的一个方法，通过 对象A.clone() 方法会创建一个内容和对象 A 一模一样的对象 B，clone 克隆，顾名思义就是创建一个一模一样的对象出来。</p><p class='p small'>Person p4 = (Person) p3.clone();</p><p><strong><p class='p small'>⑤、反序列化</p></strong></p><p class='p small'>序列化是把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。而反序列化则是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。</p><br/><h3 id="2、Clone-方法"><a href="#2、Clone-方法" class="headerlink" title="2、Clone 方法"></a>2、Clone 方法</h3><p class='p small'>Java 的深拷贝和浅拷贝，其实现方式正是通过调用 Object 类的 clone() 方法来完成。在 Object.class 类中，源码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p class='p small'>这是一个用 native 关键字修饰的方法，不理解也没关系，只需要知道用 native 修饰的方法就是告诉操作系统，这个方法我不实现了，让操作系统去实现。具体怎么实现我们不需要了解，只需要知道 clone方法的作用就是复制对象，产生一个新的对象。那么这个新的对象和原对象是什么关系呢？</p><br/><h3 id="3、基本类型和引用类型"><a href="#3、基本类型和引用类型" class="headerlink" title="3、基本类型和引用类型"></a>3、基本类型和引用类型</h3><p class='p small'>这里再给大家普及一个概念，在 Java 中基本类型和引用类型的区别。</p><p class='p small'>在 Java 中数据类型可以分为两大类：基本类型和引用类型。</p><p class='p small'>基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。</p><p class='p small'>引用类型则包括类、接口、数组、枚举等。</p><p class='p small'>Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p><p>　　<img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt=""></p><p class='p small'>上图定义的 a 和 b 都是基本类型，其值是直接存放在栈中的；而 c 和 d 是 String 声明的，这是一个引用类型，引用地址是存放在 栈中，然后指向堆的内存空间。</p><p class='p small'>下面 d = c；这条语句表示将 c 的引用赋值给 d，那么 c 和 d 将指向同一块堆内存空间。</p><br/><h3 id="4、浅拷贝"><a href="#4、浅拷贝" class="headerlink" title="4、浅拷贝"></a>4、浅拷贝</h3><p class='p small'>以下代码为浅拷贝例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public Address address;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display(String name) &#123;</span><br><span class="line">        System.out.println(name + &quot;:&quot; + &quot;name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;,&quot; + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Address &#123;</span><br><span class="line">    private String provinces;</span><br><span class="line">    private String city;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address [provinces&#x3D;&quot; + provinces + &quot;, city&#x3D;&quot; + city + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address(String provinces, String city) &#123;</span><br><span class="line">        this.provinces &#x3D; provinces;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void testShallowClone() throws Exception &#123;</span><br><span class="line">        Person p1 &#x3D; new Person(&quot;张三&quot;, 21);</span><br><span class="line">        p1.setAddress(new Address(&quot;湖北省&quot;, &quot;武汉市&quot;));</span><br><span class="line">        Person p2 &#x3D; (Person) p1.clone();</span><br><span class="line">        System.out.println(&quot;p1:&quot; + p1.hashCode());</span><br><span class="line">        System.out.println(&quot;p1.getName:&quot; + p1.getName().hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;p2:&quot; + p2.hashCode());</span><br><span class="line">        System.out.println(&quot;p2.getName:&quot; + p2.getName().hashCode());</span><br><span class="line"></span><br><span class="line">        p1.display(&quot;p1&quot;);</span><br><span class="line">        p2.display(&quot;p2&quot;);</span><br><span class="line">        p2.setAddress(new Address(&quot;湖北省&quot;, &quot;荆州市&quot;));</span><br><span class="line">        System.out.println(&quot;将复制之后的对象地址修改：&quot;);</span><br><span class="line">        p1.display(&quot;p1&quot;);</span><br><span class="line">        p2.display(&quot;p2&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p class='p small'>测试结果为：</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E4%BE%8B.png" alt=""></p><p class='p small'>首先看原始类 Person 实现 Cloneable 接口，并且覆写 clone 方法</p><p class='p small'>接着看测试内容，首先我们创建一个Person 类的对象 p1，其pname 为zhangsan</p><p class='p small'>代码中我们只是更改了克隆对象 p2 的属性 Address 为湖北省荆州市（原对象 p1 是湖北省武汉市） ，但是从打印结果来看，原对象 p1 和克隆对象 p2 的 Address 属性都被修改了。</p><p class='p small'>也就是说对象 Person 的属性 Address，经过 clone 之后，其实只是复制了其引用，他们指向的还是同一块堆内存空间，当修改其中一个对象的属性 Address，另一个也会跟着变化。</p><p><img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt=""></p><p><strong><p class='p small'>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</p></strong></p><br/><h3 id="5、深拷贝"><a href="#5、深拷贝" class="headerlink" title="5、深拷贝"></a>5、深拷贝</h3><p class='p small'>弄清楚了浅拷贝，那么深拷贝就很容易理解了。</p><p><strong><p class='p small'>深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。</p></strong></p><p>　　<img src= "/img/loading.gif" data-src="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt=""></p><p><strong><p class='p small'>Object 类提供的 clone 是只能实现 浅拷贝的。</p></strong></p><br/><h3 id="6、如何实现深拷贝？"><a href="#6、如何实现深拷贝？" class="headerlink" title="6、如何实现深拷贝？"></a>6、如何实现深拷贝？</h3><p class='p small'>深拷贝的原理我们知道了，就是要让原始对象和克隆之后的对象所具有的引用类型属性不是指向同一块堆内存，这里有三种实现思路。</p><p><strong><p class='p small'>①、让每个引用类型属性内部都重写clone() 方法</p></strong></p><p class='p small'>既然引用类型不能实现深拷贝，那么我们将每个引用类型都拆分为基本类型，分别进行浅拷贝。比如上面的例子，Person 类有一个引用类型 Address(其实String 也是引用类型，但是String类型有点特殊，后面会详细讲解)，我们在 Address 类内部也重写 clone 方法。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String provices;</span><br><span class="line">    private String city;</span><br><span class="line">    public void setAddress(String provices,String city)&#123;</span><br><span class="line">        this.provices &#x3D; provices;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address [provices&#x3D;&quot; + provices + &quot;, city&#x3D;&quot; + city + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>Person.class 的 clone() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Person p &#x3D; (Person) super.clone();</span><br><span class="line">        p.address &#x3D; (Address) address.clone();</span><br><span class="line">        return p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p class='p small'>测试还是和上面一样，我们会发现更改了p2对象的Address属性，p1 对象的 Address 属性并没有变化。</p><p class='p small'>但是这种做法有个弊端，这里我们Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p><p><strong><p class='p small'>②、利用序列化</p></strong></p><p class='p small'>序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。</p><p class='p small'>注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;深度拷贝</span><br><span class="line">public Object deepClone() throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F; 序列化</span><br><span class="line">    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">    oos.writeObject(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 反序列化</span><br><span class="line">    ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">    ObjectInputStream ois &#x3D; new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">    return ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。</p></strong></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Java</tag>

        </tags>

    </entry>


    <entry>
        <title>Keepalived搭建Nginx集群</title>
        <link href="/2021/07/11/Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
        <url>/2021/07/11/Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Nginx 简介</p><h3 id="1-1-Nginx-概述"><a href="#1-1-Nginx-概述" class="headerlink" title="1.1 Nginx 概述"></a>1.1 Nginx 概述</h3><p class='p small'>Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负 载的考验</p><br/><h3 id="1-2-正向代理"><a href="#1-2-正向代理" class="headerlink" title="1.2 正向代理"></a>1.2 正向代理</h3><p class='p small'>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p><br/><h3 id="1-3-反向代理"><a href="#1-3-反向代理" class="headerlink" title="1.3 反向代理"></a>1.3 反向代理</h3><p class='p small'>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p><br/><h3 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h3><p class='p small'>第一步 联网下载 pcre 压缩文件依赖并放置到usr/src目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;pcre&#x2F;pcre&#x2F;8.37&#x2F;pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure><p class='p small'>博主链接：</p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/nginx-1.12.2.tar.gz" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/nginx-1.12.2.tar.gz</a></p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/pcre-8.37.tar.gz" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/pcre-8.37.tar.gz</a></p><p class='p small'>第二步 解压压缩文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –zxvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure><p class='p small'>第三步进入到pcre目录中./configure</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><p class='p small'>第四步执行 make && make install</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p class='p small'>第五步 安装 openssl 、zlib 、 gcc 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure><p class='p small'>第六步安装Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.12.2</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p class='p small'>第七步进入/usr/local/nginx/sbin/nginx目录启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p class='p small'>第八步测试nginx是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep ngix</span><br></pre></td></tr></table></figure><br/><h3 id="Nginx-的常用的命令（进入nginx-sbin目录中）"><a href="#Nginx-的常用的命令（进入nginx-sbin目录中）" class="headerlink" title="Nginx 的常用的命令（进入nginx/sbin目录中）"></a>Nginx 的常用的命令（进入nginx/sbin目录中）</h3><p class='p small'>1、查看 nginx 版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v</span><br></pre></td></tr></table></figure><p class='p small'>2、启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p class='p small'>3、停止nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure><p class='p small'>4、重新加载nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><br/><h3 id="Nginx-配置高可用的集群"><a href="#Nginx-配置高可用的集群" class="headerlink" title="Nginx 配置高可用的集群"></a>Nginx 配置高可用的集群</h3><p class='p small'>配置前操作</p><p class='p small'>（1）需要两台服务器 192.168.17.129 和 192.168.17.131</p><p class='p small'>（2）在两台服务器安装 nginx</p><p class='p small'>（3）在两台服务器安装 keepalived</p><p class='p small'>1、第一步安装 keepalived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived –y</span><br></pre></td></tr></table></figure><p class='p small'>2、第二步完成高可用配置（主从配置）</p><p><strong><p class='p small'>修改/etc/keepalived/keepalivec.conf 配置文件</p></strong></p><p class='p small'>192.168.17.129（主机）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line"> notification_email &#123;</span><br><span class="line"> acassen@firewall.loc</span><br><span class="line"> failover@firewall.loc</span><br><span class="line"> sysadmin@firewall.loc</span><br><span class="line"> &#125;</span><br><span class="line"> notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line"> smtp_server 192.168.17.129</span><br><span class="line"> smtp_connect_timeout 30</span><br><span class="line"> router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line"> script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line"> interval 2 #（检测脚本执行的间隔）</span><br><span class="line"> weight 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line"> state MASTER # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line"> interface ens33 &#x2F;&#x2F;网卡</span><br><span class="line"> virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同</span><br><span class="line"> priority 100 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line"> advert_int 1</span><br><span class="line"> authentication &#123;</span><br><span class="line"> auth_type PASS</span><br><span class="line"> auth_pass 1111</span><br><span class="line"> &#125;</span><br><span class="line"> virtual_ipaddress &#123;</span><br><span class="line"> 192.168.17.50 &#x2F;&#x2F; VRRP H 虚拟地址</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>192.168.17.131（从机）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line"> notification_email &#123;</span><br><span class="line"> acassen@firewall.loc</span><br><span class="line"> failover@firewall.loc</span><br><span class="line"> sysadmin@firewall.loc</span><br><span class="line"> &#125;</span><br><span class="line"> notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line"> smtp_server 192.168.17.129</span><br><span class="line"> smtp_connect_timeout 30</span><br><span class="line"> router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line"> script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line"> interval 2 #（检测脚本执行的间隔）</span><br><span class="line"> weight 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line"> state BACKUP # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line"> interface ens33 &#x2F;&#x2F;网卡</span><br><span class="line"> virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同</span><br><span class="line"> priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line"> advert_int 1</span><br><span class="line"> authentication &#123;</span><br><span class="line"> auth_type PASS</span><br><span class="line"> auth_pass 1111</span><br><span class="line"> &#125;</span><br><span class="line"> virtual_ipaddress &#123;</span><br><span class="line"> 192.168.17.50 &#x2F;&#x2F; VRRP H 虚拟地址</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class='p small'>3、第三步在/usr/local/src 添加名称为nginx_check.sh的检测脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx –no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line"> #nginx的路径</span><br><span class="line"> &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx    </span><br><span class="line"> sleep 2</span><br><span class="line"> if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line"> killall keepalived</span><br><span class="line"> fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p class='p small'>4、第四步，克隆一台虚拟机</p><p><strong><p class='p small'>右键虚拟机，选择管理，选择克隆，选择完整性克隆，接下来就是漫长的等待了</p></strong></p><p class='p small'>5、把两台服务器上 nginx 和 keepalived 启动</p><p><strong><p class='p small'>启动 nginx：./nginx</p></strong><br><strong><p class='p small'>启动 keepalived：systemctl start keepalived.service</p></strong></p><p class='p small'>至此nginx的集群就配置好啦</p><br/><h3 id="Nginx-的原理"><a href="#Nginx-的原理" class="headerlink" title="Nginx 的原理"></a>Nginx 的原理</h3><p class='p small'>1、mater 和 worker</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/Nginx%E5%8E%9F%E7%90%86.png'><p class='p small'>2、worker 如何进行工作的</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/Nginx/worker%20%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B7%A5%E4%BD%9C%E7%9A%84.png'><p class='p small'>3、一个 master 和多个 woker 有好处</p><p class='p small'>（1）可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作</p><p class='p small'>（2）每个 woker 是独立的进程，如果有其中的一个 woker 出现问题，其他 woker 独立的，继续进行争抢，实现请求过程，不会造成服务中断</p><p class='p small'>4、设置多少个 woker 合适</p><p><strong><p class='p small'>worker 数和服务器的 cpu 数相等是最为适宜的</p></strong></p><p class='p small'>5、连接数 worker_connection</p><p class='p small'>第一个：发送请求，占用了 woker 的几个连接数？</p><p class='p small'>答案：2 或者 4 个</p><p class='p small'>第二个：nginx 有一个 master，有四个 woker，每个 woker 支持最大的连接数 1024，支持的 最大并发数是多少？</p><p class='p small'>普通的静态访问最大并发数是： worker_connections * worker_processes /2，</p><p class='p small'>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Nginx</tag>

        </tags>

    </entry>


    <entry>
        <title>SpringBoot面试题</title>
        <link href="/2021/07/10/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
        <url>/2021/07/10/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>SpringBoot面试题</p><p><strong><p class='p small'>1、Spring 是什么?</p></strong></p><p class='p small'>Spring 是一个轻量级的 IoC 和 AOP 容器框架。是为 Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的 开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于 XML 的配置、基于注解的配置、基于 Java 的配置。主要由以下几个模块组成：</p><p class='p small'>Spring Core：核心容器，提供 IOC 服务；核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</p><p class='p small'>Spring Context：应用上下文。Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p><p class='p small'>Spring AOP：Spring面向切面编程。通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p><p class='p small'>Spring DAO：JDBC和DAO模块。JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</p><p class='p small'>Spring ORM：对象实体映射。Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事务和DAO异常层次结构。</p><p class='p small'>Spring Web：Web模块。Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><p class='p small'>Spring MVC：MVC模块。MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI、FreeMarker等，模型来有JavaBean来构成，存放于m当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</p><br/><p><strong><p class='p small'>2、Resource 是如何被查找、加载的？</p></strong></p><p class='p small'>Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。 Spring 为 Resource 接口提供了如下实现类：</p><ul><li><p class='p small'>UrlResource：访问网络资源的实现类。</p></li><li><p class='p small'>ClassPathResource：访问类加载路径里资源的实现类。</p></li><li><p class='p small'>FileSystemResource：访问文件系统里资源的实现类。</p></li><li><p class='p small'>ServletContextResource：访问相对于 ServletContext 路径里的资源的实现类</p></li><li><p class='p small'>InputStreamResource：访问输入流资源的实现类。</p></li><li><p class='p small'>ByteArrayResource：访问字节数组资源的实现类。</p></li></ul><p class='p small'>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><br/><p><strong><p class='p small'>3、Spring 的AOP 理解：</p></strong></p><p class='p small'>OOP 面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些不业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系 统的可维护性。可用于权限认证、日志、事务处理。</p><p class='p small'>AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。</p><p class='p small'>（1）AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为编译时增强，他 会在编译阶段将 AspectJ(切面)织入到 Java 字节码中，运行的时候就是增强后的 AOP 对象。</p><p class='p small'>（2）Spring AOP 使用的动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p><strong><p class='p small'>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理：</p></strong></p><p class='p small'>①JDK 动态代理只提供接口的代理，不支持类的代理。核心 InvocationHandler 接口和 Proxy 类，InvocationHandler 通 过 invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy 利用 InvocationHandler 动态创建一个符合某一接口的的实例</p><p class='p small'>②如果代理类没有实现 InvocationHandler接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现 AOP。CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p><p class='p small'>（3）静态代理不动态代理区别在于生成 AOP 代理对象的时机不同，相对来说 AspectJ 的静态代理方式具有更好的性能，但是 AspectJ 需要特定的编译器动行处理，而 Spring AOP 则无需特定的编译器处理。</p><p><strong><p class='p small'>InvocationHandler 的 invoke(Object proxy，Method method，Object[] args)：proxy 是最终生成的代理实例，method 是被代理目 标实例的某个具体方法， args 是被代理目标实例某个方法的具体入参，在方法反射调用时使用。</p></strong></p> <br/><p><strong><p class='p small'>4、Spring 的 IoC 理解：</p></strong></p><p class='p small'>（1）IOC 就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖 IoC容器来动态注入对象需要的外部资源。</p><p class='p small'>（2）最直观的表达就是，IOC 让对象的创建不用去 new 了，可以由 spring 自动生产，使用 java 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p class='p small'>（3）Spring 的 IOC 有三种注入方式 ：极造器注入、setter 方法注入、根据注解注入。</p><p><strong><p class='p small'>IoC 让相互协作的组件保持松散的耦合，而 AOP 编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></strong></p> <br/><p><strong><p class='p small'>5、BeanFactory 和 ApplicationContext 有什么区别？</p></strong></p><p class='p small'>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p><p class='p small'>（1）BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制</p><p class='p small'>bean 的生命周期，维护 bean 之间的依赖关系。ApplicationContext接口作为 BeanFactory 的派生，除了提供BeanFactory 所具有的 功能外，还提供了更完整的框架功能：</p><p class='p small'>①继承 MessageSource，因此支持国际化。</p><p class='p small'>②统一的资源文件访问方式。</p><p class='p small'>③提供在监听器中注册 bean 的事件。</p><p class='p small'>④同时加载多个配置文件。</p><p class='p small'>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都与注于一个特定的层次，比如应用的 web 层。</p><p class='p small'>（2）①BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 动行加载实 例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使 用调用 getBean 方法才会抛出异常。</p><p class='p small'>②ApplicationContext，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的 配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean</p><p class='p small'>③相对于基本的 BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置 Bean较多时，程序启动较慢。</p><p class='p small'>（3）BeanFactory 通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</p><p class='p small'>（4）BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：</p><p><strong><p class='p small'>BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。</p></strong></p><table><thead><tr><th><strong>BeanFactory</strong></th><th><strong>ApplicationContext</strong></th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table> <br/><p><strong><p class='p small'>6、请解释 Spring Bean 的生命周期？</p></strong></p><p class='p small'>1、Bean 容器找到配置文件中 Spring Bean 的定义。</p><p class='p small'>2、Bean 容器利用 Java 反射创建一个Bean的实例。</p><p class='p small'>3、如果涉及到一些属性值 利用 set()方法设置一些属性值。</p><p class='p small'>4、如果Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。</p><p class='p small'>5、如果Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</p><p class='p small'>6、如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</p><p class='p small'>7、与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</p><p class='p small'>8、 如果有和加载这个 Bean 的 Spring 容器相关的BeanPostProcessor 对象，执行postProcessBeforeInitialization()方法</p><p class='p small'>9、如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</p><p class='p small'>10、如果Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</p><p class='p small'>11、如果有和加载这个 Bean的 Spring 容器相关的BeanPostProcessor 对象，执行postProcessAfterInitialization()方法</p><p class='p small'>12、当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</p><p class='p small'>13、当要销毁 Bean 的时候，如果 Bean在配置文件中的定义destroy-method 属性，执行指定的方法。</p><br/><p><strong><p class='p small'>7、 解释 Spring 支持的几种 bean 的作用域。</p></strong></p><p class='p small'>Spring 容器中的 bean 可以分为 5 个范围：</p><p class='p small'>（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。</p><p class='p small'>（2）prototype：为每一个 bean 请求提供一个实例。</p><p class='p small'>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。</p><p class='p small'>（4）session：与request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</p><p class='p small'>（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与Servlet 中的 session 作用域效果相同</p> <br/><p><strong><p class='p small'>8、Spring 框架中的单例 Beans 是线程安全的么？</p></strong></p><p class='p small'>Spring 框架并没有对单例 bean 动行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。</p> <br/><p><strong><p class='p small'>9、Spring 如何处理线程并发问题？</p></strong></p><p class='p small'>在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 动行处理，解决线程安全问题。ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的 方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时 间”的方式。</p><p class='p small'>ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程 都拥有自己的变量副本，从而也就没有必要对该变量动行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程 代码时，可以把不安全的变量封装动 ThreadLocal。</p> <br/><p><strong><p class='p small'>10-1、Spring 基于 xml 注入bean 的几种方式：</p></strong></p><p class='p small'>平常的 Java 开发中，程序员在某个类中需要依赖其它类的方法。通常是 new 一个依赖类的实例再调用该实例的方 法，这种开发存在的问题是new 的类实例不好统一管理。</p><p class='p small'>Spring 提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过 Spring 容器帮我们 new 指定实例并且将实例注入 到需要该对象的类中。依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们 new 一个实例，这个实例的控制 权是我们程序员。而控制反转是指 new 实例工作不由我们程序员来做而是交给 Spring 容器来做。Spring 有多种依赖注入 的形式</p><p><strong><p class='p small'>（1） Set 方法注入；</p></strong></p><p><strong><p class='p small'>（2）极造器注入：①通过 index 设置参数的位置；②通过 type 设置参数类型；</p></strong></p><p><strong><p class='p small'>（3）静态工厂注入；</p></strong></p><p><strong><p class='p small'>（4）实例工厂；</p></strong></p><br/><p><strong><p class='p small'>10-2、Spring 的自动装配：</p></strong></p><p class='p small'>在 Spring 框架 xml 配置中共有 5 种自动装配：</p><p class='p small'>（1）no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。</p><p class='p small'>（2）byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 不另一bean 的 name 相同，就进行自动 装配。</p><p class='p small'>（3）byType：通过参数的数据类型进行自动装配。</p><p class='p small'>（4）constructor：利用极造函数进行装配，并且极造函数的参数通过 byType 进行装配。</p><p class='p small'>（5）autodetect：自动探测，如果有极造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。</p><p class='p small'>基于注解的方式：</p><p class='p small'>使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置，<context:annotation-config />。在吭动 spring IoC 时，容器自动装载了一个 AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该 对象的属性。在使用@Autowired 时，首先在容器中查询对应类型的 bean：</p><p><strong><p class='p small'>如果查询结果刚好为一个，就将该bean 装配给@Autowired 指定的数据；</p></strong></p><p><strong><p class='p small'>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p></strong></p><p><strong><p class='p small'>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用 required=false。</p></strong></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>SpringBoot</tag>

        </tags>

    </entry>


    <entry>
        <title>RabbitMQ集群</title>
        <link href="/2021/07/10/RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4/"/>
        <url>/2021/07/10/RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>RabbitMQ 集群</p><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><p class='p small'>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键</p><br/><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p><strong><p class='p small'>1.修改 3 台机器的主机名称</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure><p class='p small'>分别修改为node1，node2，node3</p><p><strong><p class='p small'>2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.186.110 node1</span><br><span class="line">192.168.186.111 node2</span><br><span class="line">192.168.186.112 node3</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>3.以确保各个节点的 cookie 文件使用的是同一个值</p></strong></p><p class='p small'>在 node1 上执行远程操作命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</span><br><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node3:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>4.启动 RabbitMQ 服务</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>5.在节点2 分别执行</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>6.在节点 3 分别执行</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>7.查看集群状态</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>8.需要重新设置用户</p></strong></p><p class='p small'>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123123</span><br></pre></td></tr></table></figure><p class='p small'>设置用户角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p class='p small'>设置用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><br/><h3 id="如何解除集群节点-node2-和-node3-机器分别执行"><a href="#如何解除集群节点-node2-和-node3-机器分别执行" class="headerlink" title="如何解除集群节点(node2 和 node3 机器分别执行)"></a>如何解除集群节点(node2 和 node3 机器分别执行)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>RabbitMQ</tag>

        </tags>

    </entry>


    <entry>
        <title>Mysql面试题总结</title>
        <link href="/2021/07/08/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
        <url>/2021/07/08/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Mysql面试题总结</p><h2 id="Q1：MySQL-的逻辑架构了解吗？"><a href="#Q1：MySQL-的逻辑架构了解吗？" class="headerlink" title="Q1：MySQL 的逻辑架构了解吗？"></a>Q1：MySQL 的逻辑架构了解吗？</h2><p class='p small'>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。</p><p class='p small'>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</p><p class='p small'>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p><br/><h2 id="Q2：谈一谈-MySQL-的读写锁"><a href="#Q2：谈一谈-MySQL-的读写锁" class="headerlink" title="Q2：谈一谈 MySQL 的读写锁"></a>Q2：谈一谈 MySQL 的读写锁</h2><p class='p small'>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p><p class='p small'>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。</p><br/><h2 id="Q3：MySQL-的锁策略有什么？"><a href="#Q3：MySQL-的锁策略有什么？" class="headerlink" title="Q3：MySQL 的锁策略有什么？"></a>Q3：MySQL 的锁策略有什么？</h2><p class='p small'>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。</p><p class='p small'>行锁可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。</p><br/><h2 id="Q4：数据库死锁如何解决？"><a href="#Q4：数据库死锁如何解决？" class="headerlink" title="Q4：数据库死锁如何解决？"></a>Q4：数据库死锁如何解决？</h2><p class='p small'>死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资源时也会产生死锁。</p><p class='p small'>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持有最少行级排它锁的事务进行回滚。</p><p class='p small'>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p><br/><h2 id="Q5：事务是什么"><a href="#Q5：事务是什么" class="headerlink" title="Q5：事务是什么?"></a>Q5：事务是什么?</h2><p class='p small'>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。</p><br/><h2 id="Q6：事务有什么特性？"><a href="#Q6：事务有什么特性？" class="headerlink" title="Q6：事务有什么特性？"></a>Q6：事务有什么特性？</h2><p><strong><p class='p small'>原子性 atomicity</p></strong></p><p class='p small'>一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。</p><p><strong><p class='p small'>一致性 consistency</p></strong></p><p class='p small'>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p><p><strong><p class='p small'>隔离性 isolation</p></strong></p><p class='p small'>针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong><p class='p small'>持久性 durability</p></strong></p><p class='p small'>一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p><br/><h2 id="Q7：MySQL-的隔离级别有哪些？"><a href="#Q7：MySQL-的隔离级别有哪些？" class="headerlink" title="Q7：MySQL 的隔离级别有哪些？"></a>Q7：MySQL 的隔离级别有哪些？</h2><p><strong><p class='p small'>未提交读 READ UNCOMMITTED</p></strong></p><p class='p small'>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有比其他级别好很多，很少使用。</p><p><strong><p class='p small'>提交读 READ COMMITTED</p></strong></p><p class='p small'>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能"看见"已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。</p><p><strong><p class='p small'>可重复读 REPEATABLE READ</p></strong>（MySQL默认的隔离级别）</p><p class='p small'>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。</p><p><strong><p class='p small'>可串行化 SERIALIZABLE</p></strong></p><p class='p small'>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。</p><br/><h2 id="Q8：MVCC-是什么？"><a href="#Q8：MVCC-是什么？" class="headerlink" title="Q8：MVCC 是什么？"></a>Q8：MVCC 是什么？</h2><p class='p small'>MVCC 是多版本并发控制，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p class='p small'>InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p class='p small'>MVCC 只能在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作，因为 `READ UNCOMMITTED` 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 `SERIALIZABLE` 则会对所有读取的行都加锁。</p><br/><h2 id="Q9：谈一谈-InnoDB"><a href="#Q9：谈一谈-InnoDB" class="headerlink" title="Q9：谈一谈 InnoDB"></a>Q9：谈一谈 InnoDB</h2><p class='p small'>InnoDB 是 MySQL 的默认事务型引擎，用来处理大量短期事务。InnoDB 的性能和自动崩溃恢复特性使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB。</p><p class='p small'>InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。</p><p class='p small'>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 `REPEATABLE READ`，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p><p class='p small'>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。</p><p class='p small'>InnoDB 的存储格式是平***立的，可以将数据和索引文件从一个平台复制到另一个平台。</p><p class='p small'>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><br/><h2 id="Q10：谈一谈-MyISAM"><a href="#Q10：谈一谈-MyISAM" class="headerlink" title="Q10：谈一谈 MyISAM"></a>Q10：谈一谈 MyISAM</h2><p class='p small'>MySQL5.1及之前，MyISAM 是默认存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。</p><p class='p small'>MyISAM 将表存储在数据文件和索引文件中，分别以 `.MYD` 和 `.MYI` 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。</p><p class='p small'>MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。</p><p class='p small'>对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。</p><p class='p small'>对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p><p class='p small'>MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。</p><br/><h2 id="Q11：谈一谈-Memory"><a href="#Q11：谈一谈-Memory" class="headerlink" title="Q11：谈一谈 Memory"></a>Q11：谈一谈 Memory</h2><p class='p small'>如果需要快速访问数据且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有数据都保存在内存，不需要磁盘 IO，Memory 表的结构在重启后会保留，但数据会丢失。</p><p class='p small'>Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存数据分析中产生的中间数据。</p><p class='p small'>Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。</p><p class='p small'>如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。</p><br/><h2 id="Q12：查询执行流程是什么？"><a href="#Q12：查询执行流程是什么？" class="headerlink" title="Q12：查询执行流程是什么？"></a>Q12：查询执行流程是什么？</h2><p class='p small'>简单来说分为五步： ① 客户端发送一条查询给服务器。 ② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。 ③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。 ④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。 ⑤ 将结果返回给客户端。</p><br/><h2 id="Q13：VARCHAR-和-CHAR-的区别？"><a href="#Q13：VARCHAR-和-CHAR-的区别？" class="headerlink" title="Q13：VARCHAR 和 CHAR 的区别？"></a>Q13：VARCHAR 和 CHAR 的区别？</h2><p class='p small'>VARCHAR用于存储可变字符串，是最常见的字符串数据类型。它比 CHAR 更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1 或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要 1 字节。VARCHAR 不会删除末尾空格。</p><p class='p small'>VARCHAR 适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。</p><p class='p small'>CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。</p><p class='p small'>CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。</p><br/><h2 id="Q14：DATETIME-和-TIMESTAMP-的区别？"><a href="#Q14：DATETIME-和-TIMESTAMP-的区别？" class="headerlink" title="Q14：DATETIME 和 TIMESTAMP 的区别？"></a>Q14：DATETIME 和 TIMESTAMP 的区别？</h2><p class='p small'>DATETIME能保存大范围的值，从 1001~9999 年，精度为秒。把日期和时间封装到了一个整数中，与时区无关，使用 8 字节存储空间。</p><p class='p small'>TIMESTAMP 和 UNIX 时间戳相同，只使用 4 字节的存储空间，范围比 DATETIME 小得多，只能表示 1970 ~2038 年，并且依赖于时区。</p><br/><h2 id="Q15：数据类型有哪些优化策略？"><a href="#Q15：数据类型有哪些优化策略？" class="headerlink" title="Q15：数据类型有哪些优化策略？"></a>Q15：数据类型有哪些优化策略？</h2><p><strong><p class='p small'>更小的通常更好</p></strong></p><p class='p small'>一般情况下尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常也更快，因为它们占用更少的磁盘、内存和 CPU 缓存。</p><p><strong><p class='p small'>尽可能简单</p></strong></p><p class='p small'>简单数据类型的操作通常需要更少的 CPU 周期，例如整数比字符操作代价更低，因为字符集和校对规则使字符相比整形更复杂。应该使用 MySQL 的内建类型 date、time 和 datetime 而不是字符串来存储日期和时间，另一点是应该使用整形存储 IP 地址。</p><p><strong><p class='p small'>尽量避免 NULL</p></strong></p><p class='p small'>通常情况下最好指定列为 NOT NULL，除非需要存储 NULL值。因为如果查询中包含可为 NULL 的列对 MySQL 来说更难优化，可为 NULL 的列使索引、索引统计和值比较都更复杂，并且会使用更多存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外字节，在MyISAM 中还可能导致固定大小的索引变成可变大小的索引。</p><p class='p small'>如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。</p><br/><h2 id="Q16：索引有什么作用？"><a href="#Q16：索引有什么作用？" class="headerlink" title="Q16：索引有什么作用？"></a>Q16：索引有什么作用？</h2><p class='p small'>索引也叫键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</p><p class='p small'>索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免排序和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。</p><p class='p small'>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能使用索引的最左前缀。</p><br/><h2 id="Q17：谈一谈-MySQL-的-B-Tree-索引"><a href="#Q17：谈一谈-MySQL-的-B-Tree-索引" class="headerlink" title="Q17：谈一谈 MySQL 的 B-Tree 索引"></a>Q17：谈一谈 MySQL 的 B-Tree 索引</h2><p class='p small'>大多数 MySQL 引擎都支持这种索引，但底层的存储引擎可能使用不同的存储结构，例如 NDB 使用 T-Tree，而 InnoDB 使用 B+ Tree。</p><p class='p small'>B-Tree 通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。</p><p class='p small'>B-Tree索引的限制：</p><ul><li><p class='p small'>如果不是按照索引的最左列开始查找，则无法使用索引。</p></li><li><p class='p small'>不能跳过索引中的列，例如索引为 (id，name，sex)，不能只使用 id 和 sex 而跳过 name。</p></li><li><p class='p small'>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</p></li></ul><br/><h2 id="Q18：了解-Hash-索引吗？"><a href="#Q18：了解-Hash-索引吗？" class="headerlink" title="Q18：了解 Hash 索引吗？"></a>Q18：了解 Hash 索引吗？</h2><p class='p small'>哈希索引基于[哈希表](https://www.cxyxiaowu.com/7741.html)实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在[哈希表](https://www.cxyxiaowu.com/7741.html)中保存指向每个数据行的指针。</p><p class='p small'>只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。</p><p class='p small'>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：</p><ul><li><p class='p small'>哈希索引数据不是按照索引值顺序存储的，无法用于排序。</p></li><li><p class='p small'>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a，b)上建立哈希索引，如果查询的列只有a就无法使用该索引。</p></li><li><p class='p small'>哈希索引只支持等值比较查询，不支持任何范围查询。</p></li></ul><br/><h2 id="Q19：什么是自适应哈希索引？"><a href="#Q19：什么是自适应哈希索引？" class="headerlink" title="Q19：什么是自适应哈希索引？"></a>Q19：什么是自适应哈希索引？</h2><p class='p small'>自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</p><br/><h2 id="Q20-：什么是空间索引？"><a href="#Q20-：什么是空间索引？" class="headerlink" title="Q20 ：什么是空间索引？"></a>Q20 ：什么是空间索引？</h2><p class='p small'>MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。</p><br/><h2 id="Q21：什么是全文索引？"><a href="#Q21：什么是全文索引？" class="headerlink" title="Q21：什么是全文索引？"></a>Q21：什么是全文索引？</h2><p class='p small'>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><p class='p small'>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的"文档指针"。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p><br/><h2 id="Q22：什么是聚簇索引？"><a href="#Q22：什么是聚簇索引？" class="headerlink" title="Q22：什么是聚簇索引？"></a>Q22：什么是聚簇索引？</h2><p class='p small'>聚簇索引不是一种索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p class='p small'>优点：① 可以把相关数据保存在一起。② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p><p class='p small'>缺点：① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。② 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。③ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</p><br/><h2 id="Q23：什么是覆盖索引？"><a href="#Q23：什么是覆盖索引？" class="headerlink" title="Q23：什么是覆盖索引？"></a>Q23：什么是覆盖索引？</h2><p class='p small'>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p><p class='p small'>优点：① 索引条目通常远小于数据行大小，可以极大减少数据访问量。② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</p><br/><h2 id="Q24：你知道哪些索引使用原则？"><a href="#Q24：你知道哪些索引使用原则？" class="headerlink" title="Q24：你知道哪些索引使用原则？"></a>Q24：你知道哪些索引使用原则？</h2><p><strong><p class='p small'>建立索引</p></strong></p><p class='p small'>对查询频次较高且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，应当挑选最常用、过滤效果最好的列的组合。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p><p><strong><p class='p small'>使用前缀索引</p></strong></p><p class='p small'>索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p><p><strong><p class='p small'>选择合适的索引顺序</p></strong></p><p class='p small'>当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。</p><p><strong><p class='p small'>删除无用索引</p></strong></p><p class='p small'>MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A，B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p><br/><h2 id="Q25：索引失效的情况有哪些？"><a href="#Q25：索引失效的情况有哪些？" class="headerlink" title="Q25：索引失效的情况有哪些？"></a>Q25：索引失效的情况有哪些？</h2><p class='p small'>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p><p class='p small'>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</p><p class='p small'>MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做比较。这种情况下 MySQL 只能提取数据行的值而不是索引值来做比较。</p><p class='p small'>如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。</p><p class='p small'>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。</p><p class='p small'>如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p><p class='p small'>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><br/><h2 id="Q26：如何定位低效-SQL？"><a href="#Q26：如何定位低效-SQL？" class="headerlink" title="Q26：如何定位低效 SQL？"></a>Q26：如何定位低效 SQL？</h2><p class='p small'>可以通过两种方式来定位执行效率较低的 SQL 语句。一种是通过慢查询日志定位，可以通过慢查询日志定位那些已经执行完毕的 SQL 语句。另一种是使用 SHOW PROCESSLIST 查询，慢查询日志在查询结束以后才记录，所以在应用反应执行效率出现问题的时候查询慢查询日志不能定位问题，此时可以使用 SHOW PROCESSLIST 命令查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实时查看 SQL 的执行情况，同时对一些锁表操作进行优化。找到执行效率低的 SQL 语句后，就可以通过 SHOW PROFILE、EXPLAIN 或 trace 等丰富来继续优化语句。</p><br/><h2 id="Q27：SHOW-PROFILE-的作用？"><a href="#Q27：SHOW-PROFILE-的作用？" class="headerlink" title="Q27：SHOW PROFILE 的作用？"></a>Q27：SHOW PROFILE 的作用？</h2><p class='p small'>通过 SHOW PROFILE 可以分析 SQL 语句性能消耗，例如查询到 SQL 会执行多少时间，并显示 CPU、内存使用量，执行过程中系统锁及表锁的花费时间等信息。例如 `SHOW PROFILE CPU/MEMORY/BLOCK IO FOR QUERY N` 分别查询 id 为 N 的 SQL 语句的 CPU、内存以及 IO 的消耗情况。</p><br/><h2 id="Q28：trace-是干什么的？"><a href="#Q28：trace-是干什么的？" class="headerlink" title="Q28：trace 是干什么的？"></a>Q28：trace 是干什么的？</h2><p class='p small'>从 MySQL5.6 开始，可以通过 trace 文件进一步获取优化器是是如何选择执行计划的，在使用时需要先打开设置，然后执行一次 SQL，最后查看 information_schema.optimizer_trace 表而都内容，该表为联合i表，只能在当前会话进行查询，每次查询后返回的都是最近一次执行的 SQL 语句。</p><br/><h2 id="Q29：EXPLAIN-的字段有哪些，具有什么含义？"><a href="#Q29：EXPLAIN-的字段有哪些，具有什么含义？" class="headerlink" title="Q29：EXPLAIN 的字段有哪些，具有什么含义？"></a>Q29：EXPLAIN 的字段有哪些，具有什么含义？</h2><p class='p small'>执行计划是 SQL 调优的一个重要依据，可以通过 EXPLAIN 命令查看 SQL 语句的执行计划，如果作用在表上，那么该命令相当于 DESC。EXPLAIN 的指标及含义如下：</p><table><thead><tr><th>指标名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>表示 SELECT 子句或操作表的顺序，执行顺序从大到小执行，当 id 一样时，执行顺序从上往下。</td></tr><tr><td>select_type</td><td>表示查询中每个 SELECT 子句的类型，例如 SIMPLE 表示不包含子查询、表连接或其他复杂语法的简单查询，PRIMARY 表示复杂查询的最外层查询，SUBQUERY 表示在 SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>type</td><td>表示访问类型，性能由差到好为：ALL 全表扫描、index 索引全扫描、range 索引范围扫描、ref 返回匹配某个单独值得所有行，常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找，也经常出现在 join 操作中、eq_ref 唯一性索引扫描，对于每个索引键只有一条记录与之匹配、const 当 MySQL 对查询某部分进行优化，并转为一个常量时，使用这些访问类型，例如将主键或唯一索引置于 WHERE 列表就能将该查询转为一个 const、system 表中只有一行数据或空表，只能用于 MyISAM 和 Memory 表、NULL 执行时不用访问表或索引就能得到结果。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</td></tr><tr><td>possible_keys</td><td>表示查询时可能用到的索引，但不一定使用。列出大量可能索引时意味着备选索引数量太多了。</td></tr><tr><td>key</td><td>显示 MySQL 在查询时实际使用的索引，如果没有使用则显示为 NULL。</td></tr><tr><td>key_len</td><td>表示使用到索引字段的长度，可通过该列计算查询中使用的索引的长度，对于确认索引有效性以及多列索引中用到的列数目很重要。</td></tr><tr><td>ref</td><td>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</td></tr><tr><td>rows</td><td>表示 MySQL 根据表统计信息及索引选用情况，估算找到所需记录所需要读取的行数。</td></tr><tr><td>Extra</td><td>表示额外信息，例如 Using temporary 表示需要使用临时表存储结果集，常见于排序和分组查询。Using filesort 表示无法利用索引完成的文件排序，这是 ORDER BY 的结果，可以通过合适的索引改进性能。Using index 表示只需要使用索引就可以满足查询表得要求，说明表正在使用覆盖索引。</td></tr></tbody></table><br/><h2 id="Q30：有哪些优化-SQL-的策略？"><a href="#Q30：有哪些优化-SQL-的策略？" class="headerlink" title="Q30：有哪些优化 SQL 的策略？"></a>Q30：有哪些优化 SQL 的策略？</h2><p><strong><p class='p small'>优化 COUNT 查询</p></strong></p><p class='p small'>COUNT 是一个特殊的函数，它可以统计某个列值的数量，在统计列值时要求列值是非空的，不会统计 NULL 值。如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。</p><p class='p small'>COUNT 的另一个作用是统计结果集的行数，当 MySQL 确定括号内的表达式不可能为 NULL 时，实际上就是在统计行数。当使用 COUNT(*) 时，\* 不会扩展成所有列，它会忽略所有的列而直接统计所有的行数。</p><p class='p small'>某些业务场景并不要求完全精确的 COUNT 值，此时可以使用近似值来代替，EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，因为执行 EXPLAIN 并不需要真正地执行查询。</p><p class='p small'>通常来说 COUNT 都需要扫描大量的行才能获取精确的结果，因此很难优化。在 MySQL 层还能做的就只有覆盖扫描了，如果还不够就需要修改应用的架构，可以增加汇总表或者外部缓存系统。</p><p><strong><p class='p small'>优化关联查询</p></strong></p><p class='p small'>确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p><p class='p small'>确保任何 GROUP BY 和 ORDER BY 的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化这个过程。</p><p class='p small'>在 MySQL 5.5 及以下版本尽量避免子查询，可以用关联查询代替，因为执行器会先执行外部的 SQL 再执行内部的 SQL。</p><p><strong><p class='p small'>优化 GROUP BY</p></strong></p><p class='p small'>如果没有通过 ORDER BY 子句显式指定要[排序](https://www.cxyxiaowu.com/11390.html)的列，当查询使用 GROUP BY 时，结果***自动按照分组的字段进行[排序](https://www.cxyxiaowu.com/11390.html)，如果不关心结果集的顺序，可以使用 ORDER BY NULL 禁止[排序](https://www.cxyxiaowu.com/11390.html)。</p><p><strong><p class='p small'>优化 LIMIT 分页</p></strong></p><p class='p small'>在偏移量非常大的时候，需要查询很多条数据再舍弃，这样的代价非常高。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。最简单的办法是尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p><p class='p small'>还有一种方法是从上一次取数据的位置开始扫描，这样就可以避免使用 OFFSET。其他优化方法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做[排序](https://www.cxyxiaowu.com/11390.html)的数据列。</p><p><strong><p class='p small'>优化 UNION 查询</p></strong></p><p class='p small'>MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。</p><p><strong><p class='p small'>使用用户自定义变量</p></strong></p><p class='p small'>在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在，可以在任何可以使用表达式的地方使用自定义变量。例如可以使用变量来避免重复查询刚刚更新过的数据、统计更新和插入的数量等。</p><p><strong><p class='p small'>优化 INSERT</p></strong></p><p class='p small'>需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句，这种方式将缩减客户端与数据库之间的连接、关闭等消耗，效率比多条插入单个值的 INSERT 语句高。也可以关闭事务的自动提交，在插入完数据后提交。当插入的数据是按主键的顺序插入时，效率更高。</p><br/><h2 id="Q31：MySQL-主从复制的作用？"><a href="#Q31：MySQL-主从复制的作用？" class="headerlink" title="Q31：MySQL 主从复制的作用？"></a>Q31：MySQL 主从复制的作用？</h2><p class='p small'>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。</p><p class='p small'>MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p><p class='p small'>MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。</p><p class='p small'>复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。</p><br/><h2 id="Q32：MySQL-主从复制的步骤？"><a href="#Q32：MySQL-主从复制的步骤？" class="headerlink" title="Q32：MySQL 主从复制的步骤？"></a>Q32：MySQL 主从复制的步骤？</h2><p class='p small'>① 在主库上把数据更改记录到二进制日志中。</p><p class='p small'>② 备库将主库的日志复制到自己的中继日志中。</p><p class='p small'>③ 备库读取中继日志中的事件，将其重放到备库数据之上。</p><p class='p small'>第一步是在主库上记录二进制日志，每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p><p class='p small'>下一步，备库将主库的二进制日志复制到其本地的中继日志中。备库首先会启动一个工作的 IO 线程，IO 线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库 IO 线程会将接收到的事件记录到中继日志中。</p><p class='p small'>备库的 SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当 SQL 线程追赶上 IO 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL 线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Mysql</tag>

        </tags>

    </entry>


    <entry>
        <title>Redis的五大数据类型及操作命令</title>
        <link href="/2021/07/07/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
        <url>
            /2021/07/07/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/
        </url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Redis的五大数据类型及常用命令</p><h3 id=""><a href="#" class="headerlink" title=""></a><p class='p small'>Redis 键(key) 的常用命令</p></h3><p class='p small'>该命令用在key存在时删除key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Del key</span><br></pre></td></tr></table></figure><p class='p small'>序列化给定key，并返回被序列化的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DUMP key</span><br></pre></td></tr></table></figure><p class='p small'>检查给定的key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS key</span><br></pre></td></tr></table></figure><p class='p small'>为给定key设置过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure><p class='p small'>EXPIREAT的作用和EXPIRE类似，都用于为key设置过期时间，不同在于EXPIREAT命令接受的时间参数是时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure><p class='p small'>设置key的过期时间以毫秒计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure><p class='p small'>查找所以符合给定模式的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure><p class='p small'>将当前数据库的key移动到给定的数据库db当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVE key db</span><br></pre></td></tr></table></figure><p class='p small'>移除key的过期时间，key将持久保持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSIST key</span><br></pre></td></tr></table></figure><p class='p small'>以毫秒为单位返回key的剩余过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTTL key</span><br></pre></td></tr></table></figure><p class='p small'>以秒为单位返回key的剩余过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL key</span><br></pre></td></tr></table></figure><p class='p small'>从当前库中随机返回一个key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANDOMKEY</span><br></pre></td></tr></table></figure><p class='p small'>修改key的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME key newkey</span><br></pre></td></tr></table></figure><p class='p small'>返回key所储存值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure><br/><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><p class='p small'>String（字符串）</p></h3><p class='p small'>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value，String类型是二进制安全的，意思是Redis的String可以包含任何数据，比如jpg图片或者序列化的对象</p><p><strong><span class='p small red'>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</span></strong></p><h4 id="Redis中String的常用命令"><a href="#Redis中String的常用命令" class="headerlink" title="Redis中String的常用命令"></a>Redis中String的常用命令</h4><p class='p small'>设置指定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure><p class='p small'>获取指定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><p class='p small'>获返回key中字符串值的子字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETRANGE key start end</span><br></pre></td></tr></table></figure><p class='p small'>将给定的key的值设为value，并返回key的旧值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><p class='p small'>对key所存储的字符串值，获取指定偏移量上的位（bit）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure><p class='p small'>获取一个或多个给定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key1 key2 key3......</span><br></pre></td></tr></table></figure><p class='p small'>对key所存储的字符串值，设置或清除指定偏移量上的位（bit）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure><p class='p small'>只有在key不存在时设置key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p class='p small'>将值value关联到key，并设置key的过期时间（秒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br></pre></td></tr></table></figure><p class='p small'>返回key所存储的字符串值的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p class='p small'>同时设置多个key value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>同时设置一个或者多个键值对，仅当前所有key都不存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSETNX k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>以毫秒为单位设置key的生存时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSETEX key milliseconds value</span><br></pre></td></tr></table></figure><p class='p small'>将key中存储的数字值增1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值加上给定的增量值（inceement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key inceement</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值加上给定的浮点增量值（inceement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><p class='p small'>将key中存储的数字减一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值减去给定的减量值（decrement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><p class='p small'>如果key存在并且是一个字符串，将值追加到key的末尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><br/><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><p class='p small'>Hash（哈希，类似java里的Map）</p></h3><p><strong><span class='p small red'>Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</span></strong></p><p class='p small'>类似Java里面的Map<String</p><p class='p small'>删除一个或多个哈西表字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key fieId2 field2.....</span><br></pre></td></tr></table></figure><p class='p small'>查看哈西表key中，指定的字段是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p class='p small'>获取存储在哈希表中指定字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p class='p small'>获取在哈希表中指定key的所有字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p class='p small'>为哈希表key中的指定字段的整数值加上增量increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure><p class='p small'>为哈希表key中的指定字段的浮点数值加上增量increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBYELOAT key field increment</span><br></pre></td></tr></table></figure><p class='p small'>获取所有哈希表中的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p class='p small'>获取哈希表中字段的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p class='p small'>获取所有给定字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field1 field2</span><br></pre></td></tr></table></figure><p class='p small'>同时将多个field-value对设置到哈希表key中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key firld1 value1 firld2 value2</span><br></pre></td></tr></table></figure><p class='p small'>将哈希表key中的字段firld的值设value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key firld value</span><br></pre></td></tr></table></figure><p class='p small'>只有在字段field不存在时，设置哈希表字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key firld value</span><br></pre></td></tr></table></figure><p class='p small'>获取哈希表中所有值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p class='p small'>迭代哈希表中的键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><br/><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><p class='p small'>List（列表）</p></h3><p><strong><span class='p small red'>Redis 列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素导列表的头部（左边）或者尾部（右边）它的底层实际是个链表</span></strong></p><p class='p small'>通过索引获取列表中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p class='p small'>在列表的元素前或后插入元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFOREIAFTER pivot value</span><br></pre></td></tr></table></figure><p class='p small'>获取列表长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p class='p small'>移出并获取列表的第一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br></pre></td></tr></table></figure><p class='p small'>将一个或多个值插入到列表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>将一个或多个值插入到已存在的列表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>获取列表指定范围内的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p class='p small'>移除列表元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></table></figure><p class='p small'>通过索引设置列表元素的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表最后一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p class='p small'>移除列表最后一个元素，并将该元素添加到另一个列表并返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure><p class='p small'>在列表中添加一个或多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key v1 v2 v3......</span><br></pre></td></tr></table></figure><p class='p small'>为已存在的列表添加值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSHX key value</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表第一个元素，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLPOP k1 k2 timeout</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表最后一个元素，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP k1 k2 timeout</span><br></pre></td></tr></table></figure><p class='p small'>从列表弹出一个值，并将该元素插入到另一个列表中并返回他，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOPLPUSH source destination timeout</span><br></pre></td></tr></table></figure><br/><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><p class='p small'>Set（集合）</p></h3><p>**<span class='p small red'>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的**</span></p><p class='p small'>向集合添加一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 member2</span><br></pre></td></tr></table></figure><p class='p small'>获取集合的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key1 key2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的差集并存储在destination中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的交集并存储在destination中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>判断member元素是否是集合key的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p class='p small'>返回集合中所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p class='p small'>将member元素从source集合移动到destination集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p class='p small'>移除并返回集合中一个随机元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></table></figure><p class='p small'>返回集合中一个或多个随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key count</span><br></pre></td></tr></table></figure><p class='p small'>移除集合中一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member1 member2</span><br></pre></td></tr></table></figure><p class='p small'>返回所有给定集合的并集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>所有给定集合的并集存储在destination集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>迭代集合中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSCAN key cursor [MATCH pattem][COUNT count]</span><br></pre></td></tr></table></figure><br/><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><p class='p small'>Zset(sorted set：有序集合)</p></h3><p><strong><span class='p small red'>Redis zset 和 set 一样也是string类型元素的集合</span></strong></p><p class='p small'>Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的</p><p class='p small'>向有序集合添加一个或多个成员，或者更新已存在成员的分数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure><p class='p small'>获取有序集合的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p class='p small'>计算在有序集合中指定区间分数的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p class='p small'>有序集合中对指定成员的分数加上增量 increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p class='p small'>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><p class='p small'>在有序集合中计算指定字典区间内成员数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZLEXCOUNT key min max</span><br></pre></td></tr></table></figure><p class='p small'>通过索引区间返回有序集合指定区间内的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>通过字典区间返回有序集合的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br></pre></td></tr></table></figure><p class='p small'>通过分数返回有序集合指定区间内的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集合中指定成员的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中的一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的字典区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYLEX key min max</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的排名区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的排名区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中指定区间内的成员，通过索引，分数从高到低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中指定分数区间内的成员，分数从高到低排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中，成员的分数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p class='p small'>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><p class='p small'>迭代有序集合中的元素（包括元素成员和元素分值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Redis</tag>

        </tags>

    </entry>


    <entry>
        <title>RabbitMQ安装教程及安装包</title>
        <link href="/2021/07/05/RabbitMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/"/>
        <url>/2021/07/05/RabbitMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p class='p small'>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><br/><h2 id="RabbitMQ-的概念"><a href="#RabbitMQ-的概念" class="headerlink" title="RabbitMQ 的概念"></a>RabbitMQ 的概念</h2><p class='p small'>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><br/><h2 id="RabbitMQ四大核心概念"><a href="#RabbitMQ四大核心概念" class="headerlink" title="RabbitMQ四大核心概念"></a>RabbitMQ四大核心概念</h2><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p class='p small'>产生数据发送消息的程序是生产者</p><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p class='p small'>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p class='p small'>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p class='p small'>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者</p><h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><h5 id="1、下载RabbitMQ，官网地址"><a href="#1、下载RabbitMQ，官网地址" class="headerlink" title="1、下载RabbitMQ，官网地址"></a>1、下载RabbitMQ，官网地址</h5><p><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p><p class='p small'>博主链接：</p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/erlang-21.3-1.el7.x86_64.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/erlang-21.3-1.el7.x86_64.rpm</a></p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/rabbitmq-server-3.8.8-1.el7.noarch.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p><h5 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h5><p class='p small'>上传到/usr/local/software 目录下(如果没有 software 需要自己创建)</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8501.png'><h5 id="3、安装文件-分别按照以下顺序安装"><a href="#3、安装文件-分别按照以下顺序安装" class="headerlink" title="3、安装文件(分别按照以下顺序安装)"></a>3、安装文件(分别按照以下顺序安装)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h5 id="4、常用命令-按照以下顺序执行"><a href="#4、常用命令-按照以下顺序执行" class="headerlink" title="4、常用命令(按照以下顺序执行)"></a>4、常用命令(按照以下顺序执行)</h5><p class='p small'>添加开机启动 RabbitMQ 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure><p class='p small'>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server start</span><br></pre></td></tr></table></figure><p class='p small'>查看服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server status</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8502.png'><p class='p small'>停止服务(选择执行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server stop</span><br></pre></td></tr></table></figure><p class='p small'>开启 web 管理插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p class='p small'>第一次用默认账号密码(guest)访问地址 http://127.0.0.1:15672/出现权限问题</p><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8503.png'><h5 id="5、添加一个新的用户"><a href="#5、添加一个新的用户" class="headerlink" title="5、添加一个新的用户"></a>5、添加一个新的用户</h5><p class='p small'>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123</span><br></pre></td></tr></table></figure><p class='p small'>设置用户角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p class='p small'>设置用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><p class='p small'>查看RabbitMQ中当前所有用户和角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h5 id="6、再次利用-admin-用户登录"><a href="#6、再次利用-admin-用户登录" class="headerlink" title="6、再次利用 admin 用户登录"></a>6、再次利用 admin 用户登录</h5><img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/RabbitMQ/RabbitMQ%E5%AE%89%E8%A3%8504.png'><h5 id="7、重置命令"><a href="#7、重置命令" class="headerlink" title="7、重置命令"></a>7、重置命令</h5><p class='p small'>关闭应用的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p class='p small'>清除的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure><p class='p small'>重新启动命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>RabbitMQ</tag>

        </tags>

    </entry>


    <entry>
        <title>Centos7防火墙设置</title>
        <link href="/2021/07/01/Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/"/>
        <url>/2021/07/01/Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/</url>

        <content type="html">
            <![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><p class='p center logo large'>Centos7防火墙设置</p><p class='p small'>查看已开放的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p class='p small'>开放端口（开放后需要要重启防火墙才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3338&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p class='p small'>关闭端口（关闭后需要要重启防火墙才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --remove-port&#x3D;3338&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p class='p small'>重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p class='p small'>开机启动防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p class='p small'>开启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p class='p small'>禁止防火墙开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p class='p small'>停止防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>


        <tags>

            <tag>Linux</tag>

        </tags>

    </entry>


</search>
